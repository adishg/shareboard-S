[{"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/pwa.ts":"1","/var/www/html/whiteboard_micro/sharewhiteboard/src/serviceWorker.tsx":"2","/var/www/html/whiteboard_micro/sharewhiteboard/src/i18n.ts":"3","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/localStorage.ts":"4","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ErrorDialog.tsx":"5","/var/www/html/whiteboard_micro/sharewhiteboard/src/packages/excalidraw/index.tsx":"6","/var/www/html/whiteboard_micro/sharewhiteboard/src/bug-issue-template.js":"7","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Dialog.tsx":"8","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/Portal.tsx":"9","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LoadingMessage.tsx":"10","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/blob.ts":"11","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/textElement.ts":"12","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/showSelectedShapeActions.ts":"13","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/transformHandles.ts":"14","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/bounds.ts":"15","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/export.ts":"16","/var/www/html/whiteboard_micro/sharewhiteboard/src/charts.ts":"17","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/mutateElement.ts":"18","/var/www/html/whiteboard_micro/sharewhiteboard/src/math.ts":"19","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/Scene.ts":"20","/var/www/html/whiteboard_micro/sharewhiteboard/src/gapoints.ts":"21","/var/www/html/whiteboard_micro/sharewhiteboard/src/gadirections.ts":"22","/var/www/html/whiteboard_micro/sharewhiteboard/src/galines.ts":"23","/var/www/html/whiteboard_micro/sharewhiteboard/src/gatransforms.ts":"24","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/index.ts":"25","/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/renderElement.ts":"26","/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/renderScene.ts":"27","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/comparisons.ts":"28","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/selection.ts":"29","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/scrollbars.ts":"30","/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/roundRect.ts":"31","/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/index.ts":"32","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/index.ts":"33","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/FixedSideContainer.tsx":"34","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LockIcon.tsx":"35","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/UserList.tsx":"36","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/PasteChartDialog.tsx":"37","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/MobileMenu.tsx":"38","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionSelectAll.ts":"39","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionAddToLibrary.ts":"40","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionStyles.ts":"41","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDeleteSelected.tsx":"42","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDuplicateSelection.tsx":"43","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionFinalize.tsx":"44","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionAlign.tsx":"45","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/DarkModeToggle.tsx":"46","/var/www/html/whiteboard_micro/sharewhiteboard/src/align.ts":"47","/var/www/html/whiteboard_micro/sharewhiteboard/src/zindex.ts":"48","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ButtonIconSelect.tsx":"49","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/IconPicker.tsx":"50","/var/www/html/whiteboard_micro/sharewhiteboard/src/constants.ts":"51","/var/www/html/whiteboard_micro/sharewhiteboard/src/utils.ts":"52","/var/www/html/whiteboard_micro/sharewhiteboard/src/colors.ts":"53","/var/www/html/whiteboard_micro/sharewhiteboard/src/keys.ts":"54","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/restore.ts":"55","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/json.ts":"56","/var/www/html/whiteboard_micro/sharewhiteboard/src/random.ts":"57","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Island.tsx":"58","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ToolButton.tsx":"59","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/dragElements.ts":"60","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/icons.tsx":"61","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/App.tsx":"62","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/shortcuts.ts":"63","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/BackgroundPickerAndDarkModeToggle.tsx":"64","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/GitHubCorner.tsx":"65","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Section.tsx":"66","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Tooltip.tsx":"67","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Actions.tsx":"68","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionNavigate.tsx":"69","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionMenu.tsx":"70","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionExport.tsx":"71","/var/www/html/whiteboard_micro/sharewhiteboard/src/disitrubte.ts":"72","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HelpIcon.tsx":"73","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ColorPicker.tsx":"74","/var/www/html/whiteboard_micro/sharewhiteboard/src/index.tsx":"75","/var/www/html/whiteboard_micro/sharewhiteboard/src/analytics.ts":"76","/var/www/html/whiteboard_micro/sharewhiteboard/src/appState.ts":"77","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/TopErrorBoundary.tsx":"78","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/index.ts":"79","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/InitializeApp.tsx":"80","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/RoomDialog.tsx":"81","/var/www/html/whiteboard_micro/sharewhiteboard/src/clipboard.ts":"82","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/resizeTest.ts":"83","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/collision.ts":"84","/var/www/html/whiteboard_micro/sharewhiteboard/src/errors.ts":"85","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/image.ts":"86","/var/www/html/whiteboard_micro/sharewhiteboard/src/points.ts":"87","/var/www/html/whiteboard_micro/sharewhiteboard/src/ga.ts":"88","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/zoom.ts":"89","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Toast.tsx":"90","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ContextMenu.tsx":"91","/var/www/html/whiteboard_micro/sharewhiteboard/src/shapes.tsx":"92","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LayerUI.tsx":"93","/var/www/html/whiteboard_micro/sharewhiteboard/src/clients.ts":"94","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HintViewer.tsx":"95","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LibraryUnit.tsx":"96","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionZindex.tsx":"97","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDistribute.tsx":"98","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionProperties.tsx":"99","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/index.tsx":"100","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Modal.tsx":"101","/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/scroll.ts":"102","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/encode.ts":"103","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/linearElementEditor.ts":"104","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionGroup.tsx":"105","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ExportDialog.tsx":"106","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/sentry.ts":"107","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/CollabWrapper.tsx":"108","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/newElement.ts":"109","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/resizeElements.ts":"110","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/binding.ts":"111","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Avatar.tsx":"112","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Stack.tsx":"113","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HelpDialog.tsx":"114","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/components/LanguageList.tsx":"115","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/typeChecks.ts":"116","/var/www/html/whiteboard_micro/sharewhiteboard/src/data/library.ts":"117","/var/www/html/whiteboard_micro/sharewhiteboard/src/groups.ts":"118","/var/www/html/whiteboard_micro/sharewhiteboard/src/gesture.ts":"119","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/register.ts":"120","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionHistory.tsx":"121","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Popover.tsx":"122","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/firebase.ts":"123","/var/www/html/whiteboard_micro/sharewhiteboard/src/is-mobile.tsx":"124","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/index.ts":"125","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Stats.tsx":"126","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/manager.tsx":"127","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionCanvas.tsx":"128","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ProjectName.tsx":"129","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ButtonSelect.tsx":"130","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/app_constants.ts":"131","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/textWysiwyg.tsx":"132","/var/www/html/whiteboard_micro/sharewhiteboard/src/history.ts":"133","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/index.ts":"134","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/CollabButton.tsx":"135","/var/www/html/whiteboard_micro/sharewhiteboard/src/element/sizeHelpers.ts":"136","/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/LoginPage.tsx":"137","/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/RegisterPage.tsx":"138","/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/authenticationRoute.ts":"139","/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/auth.api.ts":"140","/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/Auth.component.ts":"141"},{"size":1077,"mtime":1612693890923,"results":"142","hashOfConfig":"143"},{"size":5294,"mtime":1612693890951,"results":"144","hashOfConfig":"143"},{"size":3461,"mtime":1612693890923,"results":"145","hashOfConfig":"143"},{"size":3594,"mtime":1612693890923,"results":"146","hashOfConfig":"143"},{"size":803,"mtime":1613191233300,"results":"147","hashOfConfig":"143"},{"size":2808,"mtime":1617024728293,"results":"148","hashOfConfig":"143"},{"size":136,"mtime":1612693890883,"results":"149","hashOfConfig":"143"},{"size":2949,"mtime":1612693890907,"results":"150","hashOfConfig":"143"},{"size":6711,"mtime":1616432503940,"results":"151","hashOfConfig":"143"},{"size":253,"mtime":1612693890895,"results":"152","hashOfConfig":"143"},{"size":4078,"mtime":1612693890911,"results":"153","hashOfConfig":"143"},{"size":420,"mtime":1612693890919,"results":"154","hashOfConfig":"143"},{"size":409,"mtime":1612693890919,"results":"155","hashOfConfig":"143"},{"size":6388,"mtime":1612693890919,"results":"156","hashOfConfig":"143"},{"size":13206,"mtime":1612693890915,"results":"157","hashOfConfig":"143"},{"size":5971,"mtime":1612693890947,"results":"158","hashOfConfig":"143"},{"size":12089,"mtime":1612693890883,"results":"159","hashOfConfig":"143"},{"size":2839,"mtime":1612693890915,"results":"160","hashOfConfig":"143"},{"size":7119,"mtime":1612693890935,"results":"161","hashOfConfig":"143"},{"size":3939,"mtime":1612693890947,"results":"162","hashOfConfig":"143"},{"size":949,"mtime":1612693890923,"results":"163","hashOfConfig":"143"},{"size":631,"mtime":1612693890923,"results":"164","hashOfConfig":"143"},{"size":1802,"mtime":1612693890923,"results":"165","hashOfConfig":"143"},{"size":1083,"mtime":1612693890923,"results":"166","hashOfConfig":"143"},{"size":540,"mtime":1612693890947,"results":"167","hashOfConfig":"143"},{"size":20543,"mtime":1616687493459,"results":"168","hashOfConfig":"143"},{"size":23117,"mtime":1616687493459,"results":"169","hashOfConfig":"143"},{"size":2380,"mtime":1616687493459,"results":"170","hashOfConfig":"143"},{"size":1985,"mtime":1612693890951,"results":"171","hashOfConfig":"143"},{"size":4268,"mtime":1612693890947,"results":"172","hashOfConfig":"143"},{"size":1125,"mtime":1612693890947,"results":"173","hashOfConfig":"143"},{"size":45,"mtime":1612693890947,"results":"174","hashOfConfig":"143"},{"size":2947,"mtime":1612693890911,"results":"175","hashOfConfig":"143"},{"size":467,"mtime":1612693890891,"results":"176","hashOfConfig":"143"},{"size":1921,"mtime":1612693890899,"results":"177","hashOfConfig":"143"},{"size":641,"mtime":1616687493455,"results":"178","hashOfConfig":"143"},{"size":3060,"mtime":1612693890899,"results":"179","hashOfConfig":"143"},{"size":5970,"mtime":1612693890899,"results":"180","hashOfConfig":"143"},{"size":901,"mtime":1612693890879,"results":"181","hashOfConfig":"143"},{"size":682,"mtime":1612693890875,"results":"182","hashOfConfig":"143"},{"size":2481,"mtime":1612693890883,"results":"183","hashOfConfig":"143"},{"size":4399,"mtime":1612693890879,"results":"184","hashOfConfig":"143"},{"size":4785,"mtime":1612693890879,"results":"185","hashOfConfig":"143"},{"size":5316,"mtime":1612693890879,"results":"186","hashOfConfig":"143"},{"size":6375,"mtime":1616689518306,"results":"187","hashOfConfig":"143"},{"size":2343,"mtime":1612693890891,"results":"188","hashOfConfig":"143"},{"size":2524,"mtime":1612693890883,"results":"189","hashOfConfig":"143"},{"size":7834,"mtime":1612693890967,"results":"190","hashOfConfig":"143"},{"size":815,"mtime":1612693890887,"results":"191","hashOfConfig":"143"},{"size":5463,"mtime":1612693890895,"results":"192","hashOfConfig":"143"},{"size":2299,"mtime":1612693890911,"results":"193","hashOfConfig":"143"},{"size":10256,"mtime":1612693890967,"results":"194","hashOfConfig":"143"},{"size":528,"mtime":1612693890887,"results":"195","hashOfConfig":"143"},{"size":1436,"mtime":1612693890927,"results":"196","hashOfConfig":"143"},{"size":6251,"mtime":1616687493455,"results":"197","hashOfConfig":"143"},{"size":2399,"mtime":1612693890915,"results":"198","hashOfConfig":"143"},{"size":399,"mtime":1612693890947,"results":"199","hashOfConfig":"143"},{"size":485,"mtime":1612693890895,"results":"200","hashOfConfig":"143"},{"size":2803,"mtime":1616431833516,"results":"201","hashOfConfig":"143"},{"size":2576,"mtime":1612693890915,"results":"202","hashOfConfig":"143"},{"size":35871,"mtime":1612693890903,"results":"203","hashOfConfig":"143"},{"size":118992,"mtime":1617038028230,"results":"204","hashOfConfig":"143"},{"size":1778,"mtime":1612693890883,"results":"205","hashOfConfig":"143"},{"size":715,"mtime":1612693890887,"results":"206","hashOfConfig":"143"},{"size":231,"mtime":1612693890907,"results":"207","hashOfConfig":"143"},{"size":670,"mtime":1612693890899,"results":"208","hashOfConfig":"143"},{"size":585,"mtime":1612693890903,"results":"209","hashOfConfig":"143"},{"size":7160,"mtime":1612693890907,"results":"210","hashOfConfig":"143"},{"size":1509,"mtime":1613198820336,"results":"211","hashOfConfig":"143"},{"size":2286,"mtime":1612693890883,"results":"212","hashOfConfig":"143"},{"size":5435,"mtime":1612693890879,"results":"213","hashOfConfig":"143"},{"size":3437,"mtime":1612693890915,"results":"214","hashOfConfig":"143"},{"size":364,"mtime":1612693890907,"results":"215","hashOfConfig":"143"},{"size":8197,"mtime":1612693890887,"results":"216","hashOfConfig":"143"},{"size":1061,"mtime":1617212693018,"results":"217","hashOfConfig":"143"},{"size":691,"mtime":1612693890883,"results":"218","hashOfConfig":"143"},{"size":7057,"mtime":1617025531432,"results":"219","hashOfConfig":"143"},{"size":4076,"mtime":1612693890903,"results":"220","hashOfConfig":"143"},{"size":7689,"mtime":1616687493455,"results":"221","hashOfConfig":"143"},{"size":746,"mtime":1617037998435,"results":"222","hashOfConfig":"143"},{"size":4090,"mtime":1616687493455,"results":"223","hashOfConfig":"143"},{"size":6211,"mtime":1612693890887,"results":"224","hashOfConfig":"143"},{"size":4319,"mtime":1612693890919,"results":"225","hashOfConfig":"143"},{"size":24036,"mtime":1616687493455,"results":"226","hashOfConfig":"143"},{"size":297,"mtime":1612693890919,"results":"227","hashOfConfig":"143"},{"size":3944,"mtime":1612693890911,"results":"228","hashOfConfig":"143"},{"size":1612,"mtime":1612693890943,"results":"229","hashOfConfig":"143"},{"size":7611,"mtime":1612693890923,"results":"230","hashOfConfig":"143"},{"size":961,"mtime":1612693890951,"results":"231","hashOfConfig":"143"},{"size":775,"mtime":1612693890903,"results":"232","hashOfConfig":"143"},{"size":2773,"mtime":1612693890891,"results":"233","hashOfConfig":"143"},{"size":3340,"mtime":1616687493459,"results":"234","hashOfConfig":"143"},{"size":19456,"mtime":1616687493451,"results":"235","hashOfConfig":"143"},{"size":844,"mtime":1612693890883,"results":"236","hashOfConfig":"143"},{"size":2008,"mtime":1612693890895,"results":"237","hashOfConfig":"143"},{"size":2810,"mtime":1612693890895,"results":"238","hashOfConfig":"143"},{"size":3685,"mtime":1612693890883,"results":"239","hashOfConfig":"143"},{"size":3025,"mtime":1612693890879,"results":"240","hashOfConfig":"143"},{"size":21773,"mtime":1612693890879,"results":"241","hashOfConfig":"143"},{"size":10753,"mtime":1617096229672,"results":"242","hashOfConfig":"143"},{"size":1678,"mtime":1612693890899,"results":"243","hashOfConfig":"143"},{"size":2312,"mtime":1612693890947,"results":"244","hashOfConfig":"143"},{"size":3428,"mtime":1612693890911,"results":"245","hashOfConfig":"143"},{"size":16185,"mtime":1612693890915,"results":"246","hashOfConfig":"143"},{"size":6305,"mtime":1616431749631,"results":"247","hashOfConfig":"143"},{"size":8267,"mtime":1612693890891,"results":"248","hashOfConfig":"143"},{"size":1195,"mtime":1612693890923,"results":"249","hashOfConfig":"143"},{"size":14564,"mtime":1616687493455,"results":"250","hashOfConfig":"143"},{"size":8230,"mtime":1612693890915,"results":"251","hashOfConfig":"143"},{"size":23142,"mtime":1612693890919,"results":"252","hashOfConfig":"143"},{"size":21495,"mtime":1612693890915,"results":"253","hashOfConfig":"143"},{"size":430,"mtime":1612693890887,"results":"254","hashOfConfig":"143"},{"size":1043,"mtime":1612693890899,"results":"255","hashOfConfig":"143"},{"size":10530,"mtime":1612693890891,"results":"256","hashOfConfig":"143"},{"size":996,"mtime":1612693890919,"results":"257","hashOfConfig":"143"},{"size":1936,"mtime":1616687493455,"results":"258","hashOfConfig":"143"},{"size":3272,"mtime":1612693890915,"results":"259","hashOfConfig":"143"},{"size":4745,"mtime":1612693890923,"results":"260","hashOfConfig":"143"},{"size":620,"mtime":1612693890923,"results":"261","hashOfConfig":"143"},{"size":190,"mtime":1612693890883,"results":"262","hashOfConfig":"143"},{"size":2822,"mtime":1612693890879,"results":"263","hashOfConfig":"143"},{"size":1582,"mtime":1612693890899,"results":"264","hashOfConfig":"143"},{"size":4533,"mtime":1616687493455,"results":"265","hashOfConfig":"143"},{"size":1031,"mtime":1612693890927,"results":"266","hashOfConfig":"143"},{"size":3071,"mtime":1612693890915,"results":"267","hashOfConfig":"143"},{"size":4990,"mtime":1612693890903,"results":"268","hashOfConfig":"143"},{"size":4161,"mtime":1612693890883,"results":"269","hashOfConfig":"143"},{"size":8108,"mtime":1616687493447,"results":"270","hashOfConfig":"143"},{"size":1521,"mtime":1612693890899,"results":"271","hashOfConfig":"143"},{"size":657,"mtime":1612693890887,"results":"272","hashOfConfig":"143"},{"size":355,"mtime":1612693890919,"results":"273","hashOfConfig":"143"},{"size":6123,"mtime":1612693890919,"results":"274","hashOfConfig":"143"},{"size":7616,"mtime":1612693890923,"results":"275","hashOfConfig":"143"},{"size":1588,"mtime":1616994547025,"results":"276","hashOfConfig":"143"},{"size":927,"mtime":1612693890887,"results":"277","hashOfConfig":"143"},{"size":2844,"mtime":1612693890919,"results":"278","hashOfConfig":"143"},{"size":1430,"mtime":1617212915794,"results":"279","hashOfConfig":"143"},{"size":762,"mtime":1617102261941,"results":"280","hashOfConfig":"143"},{"size":242,"mtime":1617213285677,"results":"281","hashOfConfig":"143"},{"size":871,"mtime":1617212837589,"results":"282","hashOfConfig":"143"},{"size":221,"mtime":1617213148144,"results":"283","hashOfConfig":"143"},{"filePath":"284","messages":"285","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},"17lh5zw",{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"295","messages":"296","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"300","messages":"301","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"302"},{"filePath":"303","messages":"304","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"305","messages":"306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"307","messages":"308","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"309","messages":"310","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"312","messages":"313","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"314","messages":"315","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"316","messages":"317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"322","messages":"323","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"328","messages":"329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"330","messages":"331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"340","messages":"341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"342","messages":"343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"344","messages":"345","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"346","messages":"347","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"348"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"351","messages":"352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"353","messages":"354","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"355","messages":"356","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"357","messages":"358","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"359","messages":"360","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"361","messages":"362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"363","messages":"364","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"365","usedDeprecatedRules":"292"},{"filePath":"366","messages":"367","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"368"},{"filePath":"369","messages":"370","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"371","messages":"372","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"373","messages":"374","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"375","messages":"376","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"377","messages":"378","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"379","messages":"380","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"383","messages":"384","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"385","messages":"386","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"387","messages":"388","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"389","messages":"390","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"391"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"398","messages":"399","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"400","messages":"401","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"402","messages":"403","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"404","messages":"405","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"348"},{"filePath":"406","messages":"407","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"408","messages":"409","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"410","messages":"411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"412","messages":"413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"414","messages":"415","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"416","messages":"417","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":7,"source":"418","usedDeprecatedRules":"292"},{"filePath":"419","messages":"420","errorCount":0,"warningCount":45,"fixableErrorCount":0,"fixableWarningCount":45,"source":"421","usedDeprecatedRules":"299"},{"filePath":"422","messages":"423","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"424","messages":"425","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"426","messages":"427","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"428","usedDeprecatedRules":"289"},{"filePath":"429","messages":"430","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"431","messages":"432","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"433","messages":"434","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"435","messages":"436","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"391"},{"filePath":"437","messages":"438","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"439","messages":"440","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"441","messages":"442","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"443","messages":"444","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"445","messages":"446","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"447","messages":"448","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":18,"source":null},{"filePath":"449","messages":"450","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"451","messages":"452","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"453","messages":"454","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"455","messages":"456","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"457","messages":"458","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"459","messages":"460","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"461","messages":"462","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"463","messages":"464","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"465","messages":"466","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"467","messages":"468","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"391"},{"filePath":"469","messages":"470","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"471","messages":"472","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"473"},{"filePath":"474","messages":"475","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"476","messages":"477","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"478","messages":"479","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"480","messages":"481","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"482","messages":"483","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"484","messages":"485","errorCount":0,"warningCount":34,"fixableErrorCount":0,"fixableWarningCount":32,"source":"486","usedDeprecatedRules":"289"},{"filePath":"487","messages":"488","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"473"},{"filePath":"489","messages":"490","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"491","messages":"492","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"493","messages":"494","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"495","messages":"496","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"497","messages":"498","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"499","messages":"500","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"501","messages":"502","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"503","messages":"504","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"505","messages":"506","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"507","messages":"508","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"509","messages":"510","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"511"},{"filePath":"512","messages":"513","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"514","messages":"515","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"516","messages":"517","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"299"},{"filePath":"518","messages":"519","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"520","messages":"521","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"522","messages":"523","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"524","messages":"525","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"526","messages":"527","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"528","messages":"529","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"530","usedDeprecatedRules":"289"},{"filePath":"531","messages":"532","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"533","messages":"534","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"535","messages":"536","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"292"},{"filePath":"537","messages":"538","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"539","messages":"540","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"541","messages":"542","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"543","messages":"544","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"339"},{"filePath":"545","messages":"546","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"547","messages":"548","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"549","messages":"550","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"551","messages":"552","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"553","messages":"554","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"555","messages":"556","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"557","messages":"558","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":3,"source":null},{"filePath":"559","messages":"560","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"561","messages":"562","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"473"},{"filePath":"563","messages":"564","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"565","messages":"566","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"567","messages":"568","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"569","messages":"570","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"289"},{"filePath":"571","messages":"572","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"348"},{"filePath":"573","messages":"574","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"286"},{"filePath":"575","messages":"576","errorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":26,"source":null},{"filePath":"577","messages":"578","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":13,"source":null},{"filePath":"579","messages":"580","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":null},{"filePath":"581","messages":"582","errorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":28,"source":null},{"filePath":"583","messages":"584","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":null},"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/pwa.ts",[],["585","586"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/serviceWorker.tsx",[],["587","588"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/i18n.ts",[],["589","590"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/localStorage.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ErrorDialog.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/packages/excalidraw/index.tsx",[],["591","592"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/bug-issue-template.js",[],["593","594"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Dialog.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/Portal.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LoadingMessage.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/blob.ts",[],["595","596"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/textElement.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/showSelectedShapeActions.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/transformHandles.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/bounds.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/export.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/charts.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/mutateElement.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/math.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/Scene.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/gapoints.ts",[],["597","598"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/gadirections.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/galines.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/gatransforms.ts",[],["599","600"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/renderElement.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/renderScene.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/comparisons.ts",[],["601","602"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/selection.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/scrollbars.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/roundRect.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/renderer/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/FixedSideContainer.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LockIcon.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/UserList.tsx",["603","604","605","606"],"import \"./UserList.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\nimport { ToolButton } from \"./ToolButton\";\nimport { logout } from \"./icons\";\nimport { t } from \"../i18n\";\n\ntype UserListProps = {\n  children: React.ReactNode;\n  className?: string;\n  mobile?: boolean;\n};\n\nexport const UserList = ({ children, className, mobile }: UserListProps) => {\n  return (\n    <div className={clsx(\"UserList\", className, { UserList_mobile: mobile })}>\n      {children},\n      <ToolButton\n        type=\"button\"\n        icon={logout}\n        title={t(\"buttons.logout\")}\n        aria-label={t(\"buttons.logout\")}\n      />\n\n    </div>\n\n  );\n\n};\n\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/PasteChartDialog.tsx",[],["607","608"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/MobileMenu.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionSelectAll.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionAddToLibrary.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionStyles.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDeleteSelected.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDuplicateSelection.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionFinalize.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionAlign.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/DarkModeToggle.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/align.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/zindex.ts",[],["609","610"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ButtonIconSelect.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/IconPicker.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/constants.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/utils.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/colors.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/keys.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/restore.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/json.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/random.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Island.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ToolButton.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/dragElements.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/icons.tsx",["611","612","613","614","615","616","617","618","619","620","621"],"//\n// All icons are imported from https://fontawesome.com/icons?d=gallery\n// Icons are under the license https://fontawesome.com/license\n//\n\n// Note: when adding new icons, review https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/RTL_Guidelines\n// to determine whether or not the icons should be mirrored in right-to-left languages.\n\nimport React from \"react\";\nimport { AiFillWechat, AiOutlineWechat } from \"react-icons/ai\"\n\nimport oc from \"open-color\";\nimport clsx from \"clsx\";\n\nconst activeElementColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.orange[4] : oc.orange[9];\nconst iconFillColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.black : oc.gray[4];\nconst handlerColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.white : \"#1e1e1e\";\n\ntype Opts = {\n  width?: number;\n  height?: number;\n  mirror?: true;\n} & React.SVGProps<SVGSVGElement>;\n\nconst createIcon = (d: string | React.ReactNode, opts: number | Opts = 512) => {\n  const { width = 512, height = width, mirror, style } =\n    typeof opts === \"number\" ? ({ width: opts } as Opts) : opts;\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      role=\"img\"\n      viewBox={`0 0 ${width} ${height}`}\n      className={clsx({ \"rtl-mirror\": mirror })}\n      style={style}\n    >\n      {typeof d === \"string\" ? <path fill=\"currentColor\" d={d} /> : d}\n    </svg>\n  );\n};\n\nexport const link = createIcon(\n  \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\",\n  { mirror: true },\n);\n\nexport const save = createIcon(\n  \"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z\",\n  { width: 448, height: 512 },\n);\n\nexport const saveAs = createIcon(\n  \"M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z\",\n  { width: 448, height: 512 },\n);\n\nexport const load = createIcon(\n  \"M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const clipboard = createIcon(\n  \"M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z\",\n  { width: 384, height: 512 },\n);\n\nexport const trash = createIcon(\n  \"M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z\",\n  { width: 448, height: 512 },\n);\n\nexport const chat = createIcon(\n  \"M388.226,0H123.774C76.607,0,38.233,38.374,38.233,85.541v215.933    c0,47.167,38.374,85.541,85.541,85.541h44.257l-8.725,103.57c-1.454,17.244,18.352,27.698,31.795,17.234l155.205-120.804h41.92    c47.167,0,85.541-38.373,85.541-85.541V85.541C473.766,38.374,435.393,0,388.226,0z M346.991,282.558H165.01    c-10.902,0-19.74-8.838-19.74-19.74c0-10.902,8.838-19.74,19.74-19.74h181.982c10.902,0,19.74,8.838,19.74,19.74    C366.731,273.719,357.893,282.558,346.991,282.558z M346.991,213.247H165.01c-10.902,0-19.74-8.838-19.74-19.74    c0-10.902,8.838-19.74,19.74-19.74h181.982c10.902,0,19.74,8.838,19.74,19.74C366.731,204.409,357.893,213.247,346.991,213.247z     M346.991,143.937H165.01c-10.902,0-19.74-8.838-19.74-19.74s8.838-19.74,19.74-19.74h181.982c10.902,0,19.74,8.838,19.74,19.74    S357.893,143.937,346.991,143.937z\"\n)\nexport const logout = createIcon(\n  \"M430.471,352.317c-7.169-4.146-16.347-1.698-20.496,5.474c-35.236,60.916-101.103,101.811-176.372,101.811    c-112.266,0-203.602-91.336-203.602-203.602S121.337,52.398,233.603,52.398c75.319,0,141.156,40.933,176.371,101.809    c4.148,7.172,13.328,9.619,20.496,5.474c7.171-4.148,9.621-13.325,5.474-20.496C395.418,69.127,319.729,22.397,233.603,22.397    C104.49,22.397,0,126.876,0,256c0,129.113,104.479,233.603,233.603,233.603c86.163,0,161.833-46.763,202.342-116.79    C440.092,365.642,437.642,356.466,430.471,352.317z\"\n)\nexport const mute = createIcon(\n  \"M383.459,210.189c0,43.52-17.995,85.062-49.378,113.975c-30.158,27.791-69.23,41.338-109.936,37.903    c-27.494-2.262-52.703-12.345-73.795-27.749l34.952-34.949c14.871,9.095,32.292,14.408,51.006,14.408h0.001    c54.324,0,98.363-44.039,98.363-98.362v-65.417L471.223,13.445L457.778,0L334.671,123.107v-0.009L169.922,287.845    c0.002,0.002,0.004,0.002,0.004,0.002l-34.335,34.339c-0.002-0.003-0.003-0.005-0.005-0.005l-13.404,13.404    c0.001,0.002,0.003,0.002,0.005,0.004L1.393,456.385l13.445,13.445L136.81,347.858c24.298,18.431,53.656,30.523,85.775,33.169    c1.412,0.114,2.807,0.094,4.215,0.172v72.401h-86.565v19.016h192.147v-19.016h-86.565v-72.443    c37.535-2.149,72.825-16.908,101.153-43.009c35.275-32.498,55.507-79.138,55.507-127.959v-80.382h-19.016V210.189z\"\n)\n\nexport const palette = createIcon(\n  \"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\",\n);\n\nexport const exportFile = createIcon(\n  \"M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const zoomIn = createIcon(\n  \"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const zoomOut = createIcon(\n  \"M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const done = createIcon(\n  \"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z\",\n);\n\nexport const menu = createIcon(\n  \"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z\",\n);\n\nexport const undo = createIcon(\n  \"M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z\",\n  { mirror: true },\n);\n\nexport const redo = createIcon(\n  \"M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z\",\n  { mirror: true },\n);\n\nexport const questionCircle = createIcon(\n  \"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z\",\n  { mirror: true },\n);\n\n// Icon imported form Storybook\n// Storybook is licensed under MIT https://github.com/storybookjs/storybook/blob/next/LICENSE\nexport const resetZoom = createIcon(\n  <path\n    stroke=\"currentColor\"\n    strokeWidth=\"40\"\n    fill=\"currentColor\"\n    d=\"M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z\"\n  />,\n  { width: 1024 },\n);\n\nexport const BringForwardIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H16v8H8v4.444C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendBackwardIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H9.556C8.696 8 8 8.697 8 9.556v10.888C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const BringToFrontIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M13 21a1 1 0 001 1h7a1 1 0 001-1v-7a1 1 0 00-1-1h-3v5h-5v3zM11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h3V6h5V3z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendToBackIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeLinejoin=\"round\"\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h8V3zM22 14a1 1 0 00-1-1h-7a1 1 0 00-1 1v7a1 1 0 001 1h8v-8z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeLinejoin=\"round\"\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\n//\n// Align action icons created from scratch to match those of z-index actions\n// Note: vertical align icons are flipped so the larger item is always the\n// first one the user sees. Horizontal align icons should not be flipped since\n// that would make them lie about their function.\n//\nexport const AlignTopIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,5 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M 6,7 C 5.446,7 5,7.446 5,8 v 9.999992 c 0,0.554 0.446,1 1,1 h 3.0000001 c 0.554,0 0.9999999,-0.446 0.9999999,-1 V 8 C 10,7.446 9.5540001,7 9.0000001,7 Z m 9,0 c -0.554,0 -1,0.446 -1,1 v 5.999992 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 V 8 C 19,7.446 18.554,7 18,7 Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignBottomIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,19 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 6,16.999992 c -0.554,0 -1,-0.446 -1,-1 V 6 C 5,5.446 5.446,5 6,5 H 9.0000001 C 9.5540001,5 10,5.446 10,6 v 9.999992 c 0,0.554 -0.4459999,1 -0.9999999,1 z m 9,0 c -0.554,0 -1,-0.446 -1,-1 V 10 c 0,-0.554 0.446,-1 1,-1 h 3 c 0.554,0 1,0.446 1,1 v 5.999992 c 0,0.554 -0.446,1 -1,1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignLeftIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 5,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 7.000004,5.999996 c 0,-0.554 0.446,-1 1,-1 h 9.999992 c 0.554,0 1,0.446 1,1 v 3.0000001 c 0,0.554 -0.446,0.9999999 -1,0.9999999 H 8.000004 c -0.554,0 -1,-0.4459999 -1,-0.9999999 z m 0,9 c 0,-0.554 0.446,-1 1,-1 h 5.999992 c 0.554,0 1,0.446 1,1 v 3 c 0,0.554 -0.446,1 -1,1 H 8.000004 c -0.554,0 -1,-0.446 -1,-1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const AlignRightIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 19,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 16.999996,5.999996 c 0,-0.554 -0.446,-1 -1,-1 H 6.000004 c -0.554,0 -1,0.446 -1,1 v 3.0000001 c 0,0.554 0.446,0.9999999 1,0.9999999 h 9.999992 c 0.554,0 1,-0.4459999 1,-0.9999999 z m 0,9 c 0,-0.554 -0.446,-1 -1,-1 h -5.999992 c -0.554,0 -1,0.446 -1,1 v 3 c 0,0.554 0.446,1 1,1 h 5.999992 c 0.554,0 1,-0.446 1,-1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const DistributeHorizontallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M5 5V19Z\" fill=\"black\" />\n        <path\n          d=\"M19 5V19M5 5V19\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\n<svg\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n></svg>;\n\nexport const DistributeVerticallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M5 5L19 5M5 19H19\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const CenterVerticallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"m 5.000004,16.999996 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -10 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z m 9,-2 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -6 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 2,12 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const CenterHorizontallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 7 5 C 6.446 5 6 5.446 6 6 L 6 9 C 6 9.554 6.446 10 7 10 L 17 10 C 17.554 10 18 9.554 18 9 L 18 6 C 18 5.446 17.554 5 17 5 L 7 5 z M 9 14 C 8.446 14 8 14.446 8 15 L 8 18 C 8 18.554 8.446 19 9 19 L 15 19 C 15.554 19 16 18.554 16 18 L 16 15 C 16 14.446 15.554 14 15 14 L 9 14 z \"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 12,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const users = createIcon(\n  \"M192 256c61.9 0 112-50.1 112-112S253.9 32 192 32 80 82.1 80 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C51.6 288 0 339.6 0 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zM480 256c53 0 96-43 96-96s-43-96-96-96-96 43-96 96 43 96 96 96zm48 32h-3.8c-13.9 4.8-28.6 8-44.2 8s-30.3-3.2-44.2-8H432c-20.4 0-39.2 5.9-55.7 15.4 24.4 26.3 39.7 61.2 39.7 99.8v38.4c0 2.2-.5 4.3-.6 6.4H592c26.5 0 48-21.5 48-48 0-61.9-50.1-112-112-112z\",\n  { width: 640, height: 512, mirror: true },\n);\n\n// not mirrored because it's inspired by a playback control, which is always RTL\nexport const start = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z\",\n);\n\nexport const stop = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z\",\n);\n\nexport const close = createIcon(\n  \"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\",\n  { width: 352, height: 512 },\n);\n\nexport const back = createIcon(\n  \"M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z\",\n  { width: 320, height: 512, style: { marginLeft: \"-0.2rem\" }, mirror: true },\n);\n\nexport const clone = createIcon(\n  \"M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z\",\n  { mirror: true },\n);\n\n// modified https://feathericons.com/?query=shield\nexport const shield = createIcon(\n  \"M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z\",\n  { width: 24 },\n);\n\nexport const GroupIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M25 26H111V111H25\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path d=\"M100 100H160V160H100\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n      </>,\n      { width: 182, height: 182, mirror: true },\n    ),\n);\n\nexport const UngroupIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M25 26H111V111H25\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path d=\"M100 100H160V160H100\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"78.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"78.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"105.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"102.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n      </>,\n      { width: 182, height: 182, mirror: true },\n    ),\n);\n\nexport const FillHachureIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\"\n        fill={iconFillColor(appearance)}\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillCrossHatchIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <g fill={iconFillColor(appearance)} fillRule=\"evenodd\" clipRule=\"evenodd\">\n        <path d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\" />\n        <path d=\"M14.0001 18L3.00006 4.00002L4.5727 2.76438L15.5727 16.7644L14.0001 18ZM25.0001 18L14.0001 4.00002L15.5727 2.76438L26.5727 16.7644L25.0001 18ZM36.0001 18L25.0001 4.00002L26.5727 2.76438L37.5727 16.7644L36.0001 18Z\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillSolidIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(<path d=\"M2 2H38V18H2V2Z\" fill={iconFillColor(appearance)} />, {\n      width: 40,\n      height: 20,\n    }),\n);\n\nexport const StrokeWidthIcon = React.memo(\n  ({\n    appearance,\n    strokeWidth,\n  }: {\n    appearance: \"light\" | \"dark\";\n    strokeWidth: number;\n  }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={strokeWidth}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleSolidIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const StrokeStyleDashedIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2.5}\n        strokeDasharray={\"10, 8\"}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleDottedIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2.5}\n        strokeDasharray={\"4, 4\"}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const SloppinessArchitectIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3.00098 16.1691C6.28774 13.9744 19.6399 2.8905 22.7215 3.00082C25.8041 3.11113 19.1158 15.5488 21.4962 16.8309C23.8757 18.1131 34.4155 11.7148 37.0001 10.6919\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessArtistIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 17C6.68158 14.8752 16.1296 9.09849 22.0648 6.54922C28 3.99995 22.2896 13.3209 25 14C27.7104 14.6791 36.3757 9.6471 36.3757 9.6471M6.40706 15C13 11.1918 20.0468 1.51045 23.0234 3.0052C26 4.49995 20.457 12.8659 22.7285 16.4329C25 20 36.3757 13 36.3757 13\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessCartoonistIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 15.6468C6.93692 13.5378 22.5544 2.81528 26.6206 3.00242C30.6877 3.18956 25.6708 15.3346 27.4009 16.7705C29.1309 18.2055 35.4001 12.4762 37 11.6177M3.97143 10.4917C6.61158 9.24563 16.3706 2.61886 19.8104 3.01724C23.2522 3.41472 22.0773 12.2013 24.6181 12.8783C27.1598 13.5536 33.3179 8.04068 35.0571 7.07244\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeSharpIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17L10 5L35 5\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeRoundIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17V15C10 8 13 5 21 5L33.5 5\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const ArrowheadNoneIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const ArrowheadArrowIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      >\n        <path d=\"M34 10H6M34 10L27 5M34 10L27 15\" />\n        <path d=\"M27.5 5L34.5 10L27.5 15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDotIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g\n        stroke={iconFillColor(appearance)}\n        fill={iconFillColor(appearance)}\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadBarIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}>\n        <path\n          d=\"M34 10H5.99996M34 10L34 5M34 10L34 15\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth={2}\n          fill=\"none\"\n        />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/App.tsx",["622","623","624","625","626","627","628","629","630","631","632","633","634","635","636","637","638","639","640","641","642","643","644","645","646","647","648","649","650","651","652","653","654","655","656","657","658","659","660","661","662","663","664","665","666"],"import { Point, simplify } from \"points-on-curve\";\nimport React from \"react\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport \"../actions\";\nimport { actionDeleteSelected, actionFinalize } from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  copyToClipboard,\n  parseClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport {\n  APP_NAME,\n  CANVAS_ONLY_ACTIONS,\n  CURSOR_TYPE,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  GRID_SIZE,\n  LINE_CONFIRM_THRESHOLD,\n  MIME_TYPES,\n  POINTER_BUTTON,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  TOUCH_CTX_MENU_TIMEOUT,\n} from \"../constants\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { restore } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNonDeletedElements,\n  getNormalizedDimensions,\n  getPerfectElementSize,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n} from \"../element\";\nimport {\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { deepCopyElement } from \"../element/newElement\";\nimport { MaybeTransformHandleType } from \"../element/transformHandles\";\nimport {\n  isBindingElement,\n  isBindingElementType,\n  isLinearElement,\n  isLinearElementType,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport { createHistory, SceneHistory } from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  getResizeCenterPointKey,\n  getResizeWithSidesSameLengthKey,\n  getRotateWithDiscreteAngleKey,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementContainingPosition,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  isOverScrollBars,\n  isSomeElementSelected,\n  normalizeScroll,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { SceneState, ScrollBars } from \"../scene/types\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport {\n  AppState,\n  ExcalidrawProps,\n  Gesture,\n  GestureEvent,\n  SceneData,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  ResolvablePromise,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n} from \"../utils\";\nimport ContextMenu from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\n\nconst { history } = createHistory();\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  drag: {\n    // Might change during the pointer interation\n    hasOccurred: boolean;\n    // Might change during the pointer interation\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  setScrollToCenter: InstanceType<typeof App>[\"setScrollToCenter\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n};\n\nclass App extends React.Component<ExcalidrawProps, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<ExcalidrawProps> = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n  private scene: Scene;\n  constructor(props: ExcalidrawProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n\n    const {\n      width = window.innerWidth,\n      height = window.innerHeight,\n      offsetLeft,\n      offsetTop,\n      excalidrawRef,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      isLoading: true,\n      width,\n      height,\n      ...this.getCanvasOffsets({ offsetLeft, offsetTop }),\n    };\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        setScrollToCenter: this.setScrollToCenter,\n        getSceneElements: this.getSceneElements,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n    this.scene = new Scene();\n\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  public render() {\n    const {\n      zenModeEnabled,\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      offsetTop,\n      offsetLeft,\n    } = this.state;\n\n    const { onCollabButtonClick, onExportToBackend, renderFooter } = this.props;\n    const canvasScale = window.devicePixelRatio;\n\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n\n    const DEFAULT_PASTE_X = canvasDOMWidth / 2;\n    const DEFAULT_PASTE_Y = canvasDOMHeight / 2;\n\n    return (\n      <div\n        className=\"excalidraw\"\n        ref={this.excalidrawContainerRef}\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n          top: offsetTop,\n          left: offsetLeft,\n        }}\n      >\n        <LayerUI\n          canvas={this.canvas}\n          appState={this.state}\n          setAppState={this.setAppState}\n          actionManager={this.actionManager}\n          elements={this.scene.getElements()}\n          onCollabButtonClick={onCollabButtonClick}\n          onLockToggle={this.toggleLock}\n          onInsertElements={(elements) =>\n            this.addElementsFromPasteOrLibrary(\n              elements,\n              DEFAULT_PASTE_X,\n              DEFAULT_PASTE_Y,\n            )\n          }\n          zenModeEnabled={zenModeEnabled}\n          toggleZenMode={this.toggleZenMode}\n          langCode={getLanguage().code}\n          isCollaborating={this.props.isCollaborating || false}\n          onExportToBackend={onExportToBackend}\n          renderCustomFooter={renderFooter}\n        />\n        {this.state.showStats && (\n          <Stats\n            appState={this.state}\n            elements={this.scene.getElements()}\n            onClose={this.toggleStats}\n          />\n        )}\n        {this.state.toastMessage !== null && (\n          <Toast\n            message={this.state.toastMessage}\n            clearToast={this.clearToast}\n          />\n        )}\n        <main>\n          <canvas\n            id=\"canvas\"\n            style={{\n              width: canvasDOMWidth,\n              height: canvasDOMHeight,\n            }}\n            width={canvasWidth}\n            height={canvasHeight}\n            ref={this.handleCanvasRef}\n            onContextMenu={this.handleCanvasContextMenu}\n            onPointerDown={this.handleCanvasPointerDown}\n            onDoubleClick={this.handleCanvasDoubleClick}\n            onPointerMove={this.handleCanvasPointerMove}\n            onPointerUp={this.removePointer}\n            onPointerCancel={this.removePointer}\n            onTouchMove={this.handleTouchMove}\n            onDrop={this.handleCanvasOnDrop}\n          >\n            {t(\"labels.drawingCanvas\")}\n          </canvas>\n        </main>\n      </div>\n    );\n  }\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getElements();\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n        this.setState(\n          (state) => ({\n            ...actionResult.appState,\n            editingElement:\n              editingElement || actionResult.appState?.editingElement || null,\n            width: state.width,\n            height: state.height,\n            offsetTop: state.offsetTop,\n            offsetLeft: state.offsetLeft,\n          }),\n          () => {\n            if (actionResult.syncHistory) {\n              history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventHandlerNonNull = (event) => {\n    event.preventDefault();\n  };\n\n  private onFontLoaded = () => {\n    this.scene.getElementsIncludingDeleted().forEach((element) => {\n      if (isTextElement(element)) {\n        invalidateShapeForElement(element);\n      }\n    });\n    this.onSceneUpdated();\n  };\n\n  private importLibraryFromUrl = async (url: string) => {\n    window.history.replaceState({}, APP_NAME, window.location.origin);\n    try {\n      const request = await fetch(url);\n      const blob = await request.blob();\n      const json = JSON.parse(await blob.text());\n      if (!isValidLibrary(json)) {\n        throw new Error();\n      }\n      if (\n        window.confirm(\n          t(\"alerts.confirmAddLibrary\", { numShapes: json.library.length }),\n        )\n      ) {\n        await Library.importLibrary(blob);\n        this.setState({\n          isLibraryOpen: true,\n        });\n      }\n    } catch (error) {\n      window.alert(t(\"alerts.errorLoadingLibrary\"));\n      console.error(error);\n    }\n  };\n\n  private resetHistory = () => {\n    history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        appearance: this.state.appearance,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(blob, this.state)\n            .then(({ elements, appState }) =>\n              this.syncActionResult({\n                elements,\n                appState: {\n                  ...(appState || this.state),\n                  isLoading: false,\n                },\n                commitToHistory: true,\n              }),\n            )\n            .catch((error) => {\n              this.setState({ isLoading: false, errorMessage: error.message });\n            });\n        },\n      );\n    }\n\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n    } catch (error) {\n      console.error(error);\n    }\n\n    const scene = restore(initialData, null);\n\n    scene.appState = {\n      ...scene.appState,\n      ...calculateScrollCenter(\n        scene.elements,\n        {\n          ...scene.appState,\n          width: this.state.width,\n          height: this.state.height,\n          offsetTop: this.state.offsetTop,\n          offsetLeft: this.state.offsetLeft,\n        },\n        null,\n      ),\n      isLoading: false,\n    };\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n\n    const addToLibraryUrl = new URLSearchParams(window.location.search).get(\n      \"addLibrary\",\n    );\n\n    if (addToLibraryUrl) {\n      await this.importLibraryFromUrl(addToLibraryUrl);\n    }\n  };\n\n  public async componentDidMount() {\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n\n    this.addEventListeners();\n\n    // optim to avoid extra render on init\n    if (\n      typeof this.props.offsetLeft === \"number\" &&\n      typeof this.props.offsetTop === \"number\"\n    ) {\n      this.initializeScene();\n    } else {\n      this.setState(this.getCanvasOffsets(this.props), () => {\n        this.initializeScene();\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n  }\n\n  private addEventListeners() {\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n\n    document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false);\n\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", this.onFontLoaded);\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n  }\n\n  componentDidUpdate(prevProps: ExcalidrawProps, prevState: AppState) {\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      (typeof this.props.offsetLeft === \"number\" &&\n        prevProps.offsetLeft !== this.props.offsetLeft) ||\n      (typeof this.props.offsetTop === \"number\" &&\n        prevProps.offsetTop !== this.props.offsetTop)\n    ) {\n      this.setState({\n        width: this.props.width ?? window.innerWidth,\n        height: this.props.height ?? window.innerHeight,\n        ...this.getCanvasOffsets(this.props),\n      });\n    }\n\n    document\n      .querySelector(\".excalidraw\")\n      ?.classList.toggle(\"Appearance_dark\", this.state.appearance === \"dark\");\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n    const { multiElement } = prevState;\n    if (\n      prevState.elementType !== this.state.elementType &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n    const elements = this.scene.getElements();\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements.filter((element) => {\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      }),\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n      },\n      {\n        renderOptimizations: true,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingElement?.type === \"text\"\n        ? false\n        : !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n      );\n    }\n  }\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private cutAll = () => {\n    this.copyAll();\n    this.actionManager.executeAction(actionDeleteSelected);\n  };\n\n  private copyAll = () => {\n    copyToClipboard(this.scene.getElements(), this.state);\n  };\n\n  private copyToClipboardAsPng = async () => {\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length ? selectedElements : elements,\n        this.state,\n        this.canvas!,\n        this.state,\n      );\n      this.setState({ toastMessage: t(\"toast.copyToClipboardAsPng\") });\n    } catch (error) {\n      console.error(error);\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  private copyToClipboardAsSvg = async () => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length ? selectedElements : this.scene.getElements(),\n        this.state,\n        this.canvas!,\n        this.state,\n      );\n    } catch (error) {\n      console.error(error);\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds,\n      });\n    }\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        // thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n      const data = await parseClipboard(event);\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (\n    clipboardElements: readonly ExcalidrawElement[],\n    clientX = cursorX,\n    clientY = cursorY,\n  ) => {\n    const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n    const groupIdMap = new Map();\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const oldIdToDuplicatedId = new Map();\n    const newElements = clipboardElements.map((element) => {\n      const newElement = duplicateElement(\n        this.state.editingGroupId,\n        groupIdMap,\n        element,\n        {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        },\n      );\n      oldIdToDuplicatedId.set(element.id, newElement.id);\n      return newElement;\n    });\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n    fixBindingsAfterDuplication(\n      nextElements,\n      clipboardElements,\n      oldIdToDuplicatedId,\n    );\n\n    this.scene.replaceAllElements(nextElements);\n    history.resumeRecording();\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          isLibraryOpen: false,\n          selectedElementIds: newElements.reduce((map, element) => {\n            map[element.id] = true;\n            return map;\n          }, {} as any),\n          selectedGroupIds: {},\n        },\n        this.scene.getElements(),\n      ),\n    );\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n    );\n\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    // remove touch handler for context menu on touch devices\n    if (event.pointerType === \"touch\" && touchTimeout) {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => {\n      return {\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked\n          ? \"selection\"\n          : prevState.elementType,\n      };\n    });\n  };\n\n  toggleZenMode = () => {\n    this.setState({\n      zenModeEnabled: !this.state.zenModeEnabled,\n    });\n  };\n\n  toggleGridMode = () => {\n    this.setState({\n      gridSize: this.state.gridSize ? null : GRID_SIZE,\n    });\n  };\n\n  toggleStats = () => {\n    if (!this.state.showStats) {\n      trackEvent(\"dialog\", \"stats\");\n    }\n    this.setState({\n      showStats: !this.state.showStats,\n    });\n  };\n\n  setScrollToCenter = (remoteElements: readonly ExcalidrawElement[]) => {\n    this.setState({\n      ...calculateScrollCenter(\n        getNonDeletedElements(remoteElements),\n        this.state,\n        this.canvas,\n      ),\n    });\n  };\n\n  clearToast = () => {\n    this.setState({ toastMessage: null });\n  };\n\n  public updateScene = withBatchedUpdates((sceneData: SceneData) => {\n    if (sceneData.commitToHistory) {\n      history.resumeRecording();\n    }\n\n    // currently we only support syncing background color\n    if (sceneData.appState?.viewBackgroundColor) {\n      this.setState({\n        viewBackgroundColor: sceneData.appState.viewBackgroundColor,\n      });\n    }\n\n    if (sceneData.elements) {\n      this.scene.replaceAllElements(sceneData.elements);\n    }\n\n    if (sceneData.collaborators) {\n      this.setState({ collaborators: sceneData.collaborators });\n    }\n  });\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.x;\n      cursorY = event.y;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates((event: KeyboardEvent) => {\n    // normalize `event.key` when CapsLock is pressed #2372\n    if (\n      \"Proxy\" in window &&\n      ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n        (event.shiftKey && /^[a-z]$/.test(event.key)))\n    ) {\n      event = new Proxy(event, {\n        get(ev: any, prop) {\n          const value = ev[prop];\n          if (typeof value === \"function\") {\n            // fix for Proxies hijacking `this`\n            return value.bind(ev);\n          }\n          return prop === \"key\"\n            ? // CapsLock inverts capitalization based on ShiftKey, so invert\n            // it back\n            event.shiftKey\n              ? ev.key.toUpperCase()\n              : ev.key.toLowerCase()\n            : value;\n        },\n      });\n    }\n\n    if (\n      (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n      // case: using arrows to move between buttons\n      (isArrowKey(event.key) && isInputLike(event.target))\n    ) {\n      return;\n    }\n\n    if (event.key === KEYS.QUESTION_MARK) {\n      this.setState({\n        showHelpDialog: true,\n      });\n    }\n\n    if (!event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z) {\n      this.toggleZenMode();\n    }\n\n    if (event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE) {\n      this.toggleGridMode();\n    }\n    if (event[KEYS.CTRL_OR_CMD]) {\n      this.setState({ isBindingEnabled: false });\n    }\n\n    if (event.code === CODES.C && event.altKey && event.shiftKey) {\n      this.copyToClipboardAsPng();\n      event.preventDefault();\n      return;\n    }\n\n    if (this.actionManager.handleKeyDown(event)) {\n      return;\n    }\n\n    if (event.code === CODES.NINE) {\n      this.setState({ isLibraryOpen: !this.state.isLibraryOpen });\n    }\n\n    if (isArrowKey(event.key)) {\n      const step =\n        (this.state.gridSize &&\n          (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize)) ||\n        (event.shiftKey\n          ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n          : ELEMENT_TRANSLATE_AMOUNT);\n\n      const selectedElements = this.scene\n        .getElements()\n        .filter((element) => this.state.selectedElementIds[element.id]);\n\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (event.key === KEYS.ARROW_LEFT) {\n        offsetX = -step;\n      } else if (event.key === KEYS.ARROW_RIGHT) {\n        offsetX = step;\n      } else if (event.key === KEYS.ARROW_UP) {\n        offsetY = -step;\n      } else if (event.key === KEYS.ARROW_DOWN) {\n        offsetY = step;\n      }\n\n      selectedElements.forEach((element) => {\n        mutateElement(element, {\n          x: element.x + offsetX,\n          y: element.y + offsetY,\n        });\n\n        updateBoundElements(element, {\n          simultaneouslyUpdated: selectedElements,\n        });\n      });\n\n      this.maybeSuggestBindingForAll(selectedElements);\n\n      event.preventDefault();\n    } else if (event.key === KEYS.ENTER) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n\n      if (\n        selectedElements.length === 1 &&\n        isLinearElement(selectedElements[0])\n      ) {\n        if (\n          !this.state.editingLinearElement ||\n          this.state.editingLinearElement.elementId !== selectedElements[0].id\n        ) {\n          history.resumeRecording();\n          this.setState({\n            editingLinearElement: new LinearElementEditor(\n              selectedElements[0],\n              this.scene,\n            ),\n          });\n        }\n      } else if (\n        selectedElements.length === 1 &&\n        !isLinearElement(selectedElements[0])\n      ) {\n        const selectedElement = selectedElements[0];\n        this.startTextEditing({\n          sceneX: selectedElement.x + selectedElement.width / 2,\n          sceneY: selectedElement.y + selectedElement.height / 2,\n        });\n        event.preventDefault();\n        return;\n      }\n    } else if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      this.state.draggingElement === null\n    ) {\n      const shape = findShapeByKey(event.key);\n      if (shape) {\n        this.selectShapeTool(shape);\n      } else if (event.key === KEYS.Q) {\n        this.toggleLock();\n      }\n    }\n    if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n      isHoldingSpace = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    }\n  });\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    if (!isLinearElementType(elementType)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      selectedElementIds: {},\n    });\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location on the touchMove handler already.\n    // On Macbook, we don't have those events so will zoom in at the\n    // current location instead.\n    if (gesture.pointers.size === 2) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * event.scale),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          { x: cursorX, y: cursorY },\n        ),\n      }));\n    }\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      previousSelectedElementIds: {},\n      selectedElementIds: this.state.previousSelectedElementIds,\n    });\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (text: string, isDeleted = false) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [viewportX, viewportY];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates((text) => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n        if (!isDeleted) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n        } else {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n      }),\n      element,\n    });\n    // deselect all other elements when inserting text\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(x, y);\n    if (allHitElements.length > 1) {\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement>[] {\n    return getElementsAtPosition(this.scene.getElements(), (element) =>\n      hitTest(element, this.state, x, y),\n    );\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n  }) => {\n    const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n\n    const parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n        x: parentCenterPosition\n          ? parentCenterPosition.elementCenterX\n          : sceneX,\n        y: parentCenterPosition\n          ? parentCenterPosition.elementCenterY\n          : sceneY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemStrokeSharpness,\n        text: \"\",\n        fontSize: this.state.currentItemFontSize,\n        fontFamily: this.state.currentItemFontFamily,\n        textAlign: parentCenterPosition\n          ? \"center\"\n          : this.state.currentItemTextAlign,\n        verticalAlign: parentCenterPosition\n          ? \"middle\"\n          : DEFAULT_VERTICAL_ALIGN,\n      });\n\n    this.setState({ editingElement: element });\n\n    if (existingTextElement) {\n      // if text element is no longer centered to a container, reset\n      // verticalAlign to default because it's currently internal-only\n      if (!parentCenterPosition || element.textAlign !== \"center\") {\n        mutateElement(element, { verticalAlign: DEFAULT_VERTICAL_ALIGN });\n      }\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      // case: creating new text not centered to parent elemenent  offset Y\n      // so that the text is centered to cursor position\n      if (!parentCenterPosition) {\n        mutateElement(element, {\n          y: element.y - element.baseline / 2,\n        });\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        !this.state.editingLinearElement ||\n        this.state.editingLinearElement.elementId !== selectedElements[0].id\n      ) {\n        history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n      }\n      return;\n    }\n\n    resetCursor();\n\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getElements(),\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor();\n\n    if (!event[KEYS.CTRL_OR_CMD]) {\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n      });\n    }\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      this.setState(({ zoom, scrollX, scrollY, offsetLeft, offsetTop }) => ({\n        scrollX: normalizeScroll(scrollX + deltaX / zoom.value),\n        scrollY: normalizeScroll(scrollY + deltaY / zoom.value),\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * scaleFactor),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          center,\n        ),\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX,\n      event.clientY,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state.editingLinearElement,\n        this.state.gridSize,\n      );\n      if (editingLinearElement !== this.state.editingLinearElement) {\n        this.setState({ editingLinearElement });\n      }\n      if (editingLinearElement.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        this.setState({ suggestedBindings: [] });\n      }\n    }\n\n    if (isBindingElementType(this.state.elementType)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement)) {\n        this.maybeSuggestBindingForLinearElementAtCursor(\n          draggingElement,\n          \"end\",\n          scenePointer,\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        if (isPathALoop(points)) {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [scenePointerX - rx, scenePointerY - ry],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          elementWithTransformHandleType,\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType,\n        });\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (this.state.elementType === \"text\") {\n      document.documentElement.style.cursor = isTextElement(hitElement)\n        ? CURSOR_TYPE.TEXT\n        : CURSOR_TYPE.CROSSHAIR;\n    } else if (isOverScrollBar) {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    } else if (\n      hitElement ||\n      this.isHittingCommonBoundingBoxOfSelectedElements(\n        scenePointer,\n        selectedElements,\n      )\n    ) {\n      document.documentElement.style.cursor = CURSOR_TYPE.MOVE;\n    } else {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    }\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.persist();\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // fixes pointermove causing selection of UI texts #32\n    event.preventDefault();\n    // Preventing the event above disables default behavior\n    // of defocusing potentially focused element, which is what we\n    // want when clicking inside the canvas.\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur();\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    if (this.state.elementType === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"draw\" ||\n      this.state.elementType === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else {\n      this.createGenericElementOnPointerDown(\n        this.state.elementType,\n        pointerDownState,\n      );\n    }\n\n    const onPointerMove = this.onPointerMoveFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onPointerUp = this.onPointerUpFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n    window.addEventListener(EVENT.KEYUP, onKeyUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n    pointerDownState.eventListeners.onKeyUp = onKeyUp;\n    pointerDownState.eventListeners.onKeyDown = onKeyDown;\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.openContextMenu({\n              clientX: event.clientX,\n              clientY: event.clientY,\n            });\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size === 0 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace))\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - rigth click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.setState({\n        scrollX: normalizeScroll(\n          this.state.scrollX - deltaX / this.state.zoom.value,\n        ),\n        scrollY: normalizeScroll(\n          this.state.scrollY - deltaY / this.state.zoom.value,\n        ),\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          setCursorForShape(this.state.elementType);\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX,\n        event.clientY,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(\n          origin,\n          selectedElements,\n        ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.elementType !== \"selection\") {\n      this.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.elementType === \"selection\") {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(\n          elements,\n          this.state,\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType: pointerDownState.resize.handleType,\n        });\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.editingLinearElement) {\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            (appState) => this.setState(appState),\n            history,\n            pointerDownState.origin,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(\n          (element) => this.isASelectedElement(element),\n        );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        // If we click on something\n        if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: {},\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement.id]: true,\n                    },\n                  },\n                  this.scene.getElements(),\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.elementLocked)\n    if (this.state.editingElement?.type === \"text\") {\n      return;\n    }\n\n    this.startTextEditing({\n      sceneX: pointerDownState.origin.x,\n      sceneY: pointerDownState.origin.y,\n      insertAtParentCenter: !event.altKey,\n    });\n\n    resetCursor();\n    if (!this.state.elementLocked) {\n      this.setState({\n        elementType: \"selection\",\n      });\n    }\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone  finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [multiElement.id]: true,\n        },\n      }));\n      // clicking outside commit zone  update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        elementType === \"draw\" ? null : this.state.gridSize,\n      );\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n        startArrowhead,\n        endArrowhead,\n      });\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [element.id]: false,\n        },\n      }));\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            getSelectedElements(this.scene.getElements(), this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(\n          this.state,\n          (appState) => this.setState(appState),\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, startOrEnd) => {\n            this.maybeSuggestBindingForLinearElementAtCursor(\n              element,\n              startOrEnd,\n              pointerCoords,\n            );\n          },\n        );\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n      if (\n        hasHitASelectedElement ||\n        pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n      ) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        if (selectedElements.length > 0) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          dragSelectedElements(\n            pointerDownState,\n            selectedElements,\n            dragX,\n            dragY,\n            this.scene,\n            lockDirection,\n            dragDistanceX,\n            dragDistanceY,\n          );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx: number;\n        let dy: number;\n        if (draggingElement.type === \"draw\") {\n          dx = pointerCoords.x - draggingElement.x;\n          dy = pointerCoords.y - draggingElement.y;\n        } else {\n          dx = gridX - draggingElement.x;\n          dy = gridY - draggingElement.y;\n        }\n\n        if (getRotateWithDiscreteAngleKey(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          if (draggingElement.type === \"draw\") {\n            mutateElement(draggingElement, {\n              points: simplify(\n                [...(points as Point[]), [dx, dy]],\n                0.7 / this.state.zoom.value,\n              ),\n            });\n          } else {\n            mutateElement(draggingElement, {\n              points: [...points.slice(0, -1), [dx, dy]],\n            });\n          }\n        }\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(\n            draggingElement,\n            \"end\",\n            pointerCoords,\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({\n            selectedElementIds: {},\n            selectedGroupIds: {},\n            editingGroupId: null,\n          });\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                ...elementsWithinSelection.reduce((map, element) => {\n                  map[element.id] = true;\n                  return map;\n                }, {} as any),\n              },\n            },\n            this.scene.getElements(),\n          ),\n        );\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: normalizeScroll(\n          this.state.scrollX - dx / this.state.zoom.value,\n        ),\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: normalizeScroll(\n          this.state.scrollY - dy / this.state.zoom.value,\n        ),\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(\n          childEvent,\n          this.state.editingLinearElement,\n          this.state,\n        );\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: [],\n          });\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (draggingElement?.type === \"draw\") {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!elementLocked && elementType !== \"draw\") {\n            resetCursor();\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection\n      ) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds\n                .flatMap((groupId) =>\n                  getElementsInGroup(this.scene.getElements(), groupId),\n                )\n                .map((element) => ({ [element.id]: false }))\n                .reduce((prevId, acc) => ({ ...prevId, ...acc }), {});\n\n              this.setState((_prevState) => ({\n                selectedGroupIds: {\n                  ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds\n                    .map((gId) => ({ [gId]: false }))\n                    .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                },\n                selectedElementIds: {\n                  ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups,\n                },\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState((prevState) => ({\n                selectedElementIds: {\n                  ...prevState.selectedElementIds,\n                  [hitElement!.id]: false,\n                },\n              }));\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: {\n                ..._prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getElements(),\n            ),\n          }));\n        }\n      }\n\n      if (\n        !this.state.editingLinearElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"draw\" && draggingElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(this.scene.getElements(), this.state)\n      ) {\n        history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(\n            getSelectedElements(this.scene.getElements(), this.state),\n          );\n      }\n\n      if (!elementLocked && elementType !== \"draw\") {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingForLinearElementAtCursor = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    startOrEnd: \"start\" | \"end\",\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null &&\n          !isLinearElementSimpleAndAlreadyBound(\n            linearElement,\n            oppositeBindingBoundElement?.id,\n            hoveredBindableElement,\n          )\n          ? [hoveredBindableElement]\n          : [],\n    });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n          hitElement != null &&\n          isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleCanvasOnDrop = async (\n    event: React.DragEvent<HTMLCanvasElement>,\n  ) => {\n    try {\n      const file = event.dataTransfer.files[0];\n      if (file?.type === \"image/png\" || file?.type === \"image/svg+xml\") {\n        const { elements, appState } = await loadFromBlob(file, this.state);\n        this.syncActionResult({\n          elements,\n          appState: {\n            ...(appState || this.state),\n            isLoading: false,\n          },\n          commitToHistory: true,\n        });\n        return;\n      }\n    } catch (error) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryShapes !== \"\") {\n      this.addElementsFromPasteOrLibrary(\n        JSON.parse(libraryShapes),\n        event.clientX,\n        event.clientY,\n      );\n      return;\n    }\n\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === \"application/json\" ||\n      file?.name.endsWith(\".excalidraw\")\n    ) {\n      this.setState({ isLoading: true });\n      if (\n        \"chooseFileSystemEntries\" in window ||\n        \"showOpenFilePicker\" in window\n      ) {\n        try {\n          // This will only work as of Chrome 86,\n          // but can be safely ignored on older releases.\n          const item = event.dataTransfer.items[0];\n          // TODO: Make this part of `AppState`.\n          (file as any).handle = await (item as any).getAsFileSystemHandle();\n        } catch (error) {\n          console.warn(error.name, error.message);\n        }\n      }\n      loadFromBlob(file, this.state)\n        .then(({ elements, appState }) =>\n          this.syncActionResult({\n            elements,\n            appState: {\n              ...(appState || this.state),\n              isLoading: false,\n            },\n            commitToHistory: true,\n          }),\n        )\n        .catch((error) => {\n          this.setState({ isLoading: false, errorMessage: error.message });\n        });\n    } else if (\n      file?.type === MIME_TYPES.excalidrawlib ||\n      file?.name.endsWith(\".excalidrawlib\")\n    ) {\n      Library.importLibrary(file)\n        .then(() => {\n          this.setState({ isLibraryOpen: false });\n        })\n        .catch((error) =>\n          this.setState({ isLoading: false, errorMessage: error.message }),\n        );\n    } else {\n      this.setState({\n        isLoading: false,\n        errorMessage: t(\"alerts.couldNotLoadInvalidFile\"),\n      });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n    this.openContextMenu(event);\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (draggingElement.type === \"selection\") {\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n      this.maybeSuggestBindingForAll([draggingElement]);\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const transformHandleType = pointerDownState.resize.handleType;\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        getRotateWithDiscreteAngleKey(event),\n        getResizeCenterPointKey(event),\n        getResizeWithSidesSameLengthKey(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n      return true;\n    }\n    return false;\n  };\n\n  private openContextMenu = ({\n    clientX,\n    clientY,\n  }: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const elements = this.scene.getElements();\n    const element = this.getElementAtPosition(x, y);\n    if (!element) {\n      ContextMenu.push({\n        options: [\n          navigator.clipboard && {\n            shortcutName: \"paste\",\n            label: t(\"labels.paste\"),\n            action: () => this.pasteFromClipboard(null),\n          },\n          probablySupportsClipboardBlob &&\n          elements.length > 0 && {\n            shortcutName: \"copyAsPng\",\n            label: t(\"labels.copyAsPng\"),\n            action: this.copyToClipboardAsPng,\n          },\n          probablySupportsClipboardWriteText &&\n          elements.length > 0 && {\n            shortcutName: \"copyAsSvg\",\n            label: t(\"labels.copyAsSvg\"),\n            action: this.copyToClipboardAsSvg,\n          },\n          ...this.actionManager.getContextMenuItems((action) =>\n            CANVAS_ONLY_ACTIONS.includes(action.name),\n          ),\n          {\n            checked: this.state.gridSize !== null,\n            shortcutName: \"gridMode\",\n            label: t(\"labels.gridMode\"),\n            action: this.toggleGridMode,\n          },\n          {\n            checked: this.state.zenModeEnabled,\n            shortcutName: \"zenMode\",\n            label: t(\"buttons.zenMode\"),\n            action: this.toggleZenMode,\n          },\n          {\n            checked: this.state.showStats,\n            shortcutName: \"stats\",\n            label: t(\"stats.title\"),\n            action: this.toggleStats,\n          },\n        ],\n        top: clientY,\n        left: clientX,\n      });\n      return;\n    }\n\n    if (!this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } });\n    }\n\n    ContextMenu.push({\n      options: [\n        {\n          shortcutName: \"cut\",\n          label: t(\"labels.cut\"),\n          action: this.cutAll,\n        },\n        navigator.clipboard && {\n          shortcutName: \"copy\",\n          label: t(\"labels.copy\"),\n          action: this.copyAll,\n        },\n        navigator.clipboard && {\n          shortcutName: \"paste\",\n          label: t(\"labels.paste\"),\n          action: () => this.pasteFromClipboard(null),\n        },\n        probablySupportsClipboardBlob && {\n          shortcutName: \"copyAsPng\",\n          label: t(\"labels.copyAsPng\"),\n          action: this.copyToClipboardAsPng,\n        },\n        probablySupportsClipboardWriteText && {\n          shortcutName: \"copyAsSvg\",\n          label: t(\"labels.copyAsSvg\"),\n          action: this.copyToClipboardAsSvg,\n        },\n        ...this.actionManager.getContextMenuItems(\n          (action) => !CANVAS_ONLY_ACTIONS.includes(action.name),\n        ),\n      ],\n      top: clientY,\n      left: clientX,\n    });\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n\n    if (isPanning) {\n      return;\n    }\n\n    const { deltaX, deltaY } = event;\n    const { selectedElementIds, previousSelectedElementIds } = this.state;\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      if (Object.keys(previousSelectedElementIds).length !== 0) {\n        setTimeout(() => {\n          this.setState({\n            selectedElementIds: previousSelectedElementIds,\n            previousSelectedElementIds: {},\n          });\n        }, 1000);\n      }\n\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(zoom.value - delta / 100),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          {\n            x: cursorX,\n            y: cursorY,\n          },\n        ),\n        selectedElementIds: {},\n        previousSelectedElementIds:\n          Object.keys(selectedElementIds).length !== 0\n            ? selectedElementIds\n            : previousSelectedElementIds,\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n      return;\n    }\n\n    // scroll horizontally when shift pressed\n    if (event.shiftKey) {\n      this.setState(({ zoom, scrollX }) => ({\n        // on Mac, shift+wheel tends to result in deltaX\n        scrollX: normalizeScroll(scrollX - (deltaY || deltaX) / zoom.value),\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: normalizeScroll(scrollX - deltaX / zoom.value),\n      scrollY: normalizeScroll(scrollY - deltaY / zoom.value),\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      this.scene\n        .getElementsIncludingDeleted()\n        .filter((element) => !isTextElement(element)),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private getCanvasOffsets(offsets?: {\n    offsetLeft?: number;\n    offsetTop?: number;\n  }): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (\n      typeof offsets?.offsetLeft === \"number\" &&\n      typeof offsets?.offsetTop === \"number\"\n    ) {\n      return {\n        offsetLeft: offsets.offsetLeft,\n        offsetTop: offsets.offsetTop,\n      };\n    }\n    if (this.excalidrawContainerRef?.current?.parentElement) {\n      const parentElement = this.excalidrawContainerRef.current.parentElement;\n      const { left, top } = parentElement.getBoundingClientRect();\n      return {\n        offsetLeft:\n          typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : left,\n        offsetTop:\n          typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : top,\n      };\n    }\n    return {\n      offsetLeft:\n        typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : 0,\n      offsetTop: typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      history: SceneHistory;\n      app: InstanceType<typeof App>;\n      library: typeof Library;\n      collab: InstanceType<\n        typeof import(\"../excalidraw-app/collab/CollabWrapper\").default\n      >;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app.scene.replaceAllElements(elements);\n      },\n    },\n    history: {\n      configurable: true,\n      get: () => history,\n    },\n    library: {\n      configurable: true,\n      value: Library,\n    },\n  });\n}\nexport default App;\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/shortcuts.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/BackgroundPickerAndDarkModeToggle.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/GitHubCorner.tsx",["667","668","669"],"import oc from \"open-color\";\nimport React from \"react\";\n\n// https://github.com/tholman/github-corners\nexport const GitHubCorner = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) => (\n    <span>\n    </span>\n  ),\n);\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Section.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Tooltip.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Actions.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionNavigate.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionMenu.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionExport.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/disitrubte.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HelpIcon.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ColorPicker.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/index.tsx",["670","671","672","673","674","675","676","677","678","679","680","681","682","683","684","685","686","687"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/analytics.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/appState.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/TopErrorBoundary.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/InitializeApp.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/RoomDialog.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/clipboard.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/resizeTest.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/collision.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/errors.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/image.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/points.ts",[],["688","689"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/ga.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/zoom.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Toast.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ContextMenu.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/shapes.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LayerUI.tsx",["690","691","692","693","694","695","696","697","698","699","700","701","702","703","704","705","706","707","708","709","710","711","712","713","714","715","716","717","718","719","720","721","722","723"],"import clsx from \"clsx\";\nimport React, {\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { CLASSES } from \"../constants\";\nimport { exportCanvas } from \"../data\";\nimport { importLibraryFromJSON, saveLibraryAsJSON } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { Language, t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { calculateScrollCenter, getSelectedElements } from \"../scene\";\nimport { ExportType } from \"../scene/types\";\nimport { AppState, LibraryItem, LibraryItems } from \"../types\";\nimport { muteFSAbortError } from \"../utils\";\nimport { SelectedShapeActions, ShapesSwitcher, ZoomActions } from \"./Actions\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport CollabButton from \"./CollabButton\";\nimport { ErrorDialog } from \"./ErrorDialog\";\nimport { ExportCB, ExportDialog } from \"./ExportDialog\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { GitHubCorner } from \"./GitHubCorner\";\nimport { HintViewer } from \"./HintViewer\";\nimport { exportFile, load, logout, mute, shield } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./LayerUI.scss\";\nimport { LibraryUnit } from \"./LibraryUnit\";\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { LockIcon } from \"./LockIcon\";\nimport { MobileMenu } from \"./MobileMenu\";\nimport { PasteChartDialog } from \"./PasteChartDialog\";\nimport { Section } from \"./Section\";\nimport { HelpDialog } from \"./HelpDialog\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { Tooltip } from \"./Tooltip\";\nimport { UserList } from \"./UserList\";\n\ninterface LayerUIProps {\n  actionManager: ActionManager;\n  appState: AppState;\n  canvas: HTMLCanvasElement | null;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  onInsertElements: (elements: readonly NonDeletedExcalidrawElement[]) => void;\n  zenModeEnabled: boolean;\n  toggleZenMode: () => void;\n  langCode: Language[\"code\"];\n  isCollaborating: boolean;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  renderCustomFooter?: (isMobile: boolean) => JSX.Element;\n}\n\nconst useOnClickOutside = (\n  ref: RefObject<HTMLElement>,\n  cb: (event: MouseEvent) => void,\n) => {\n  useEffect(() => {\n    const listener = (event: MouseEvent) => {\n      if (!ref.current) {\n        return;\n      }\n\n      if (\n        event.target instanceof Element &&\n        (ref.current.contains(event.target) ||\n          !document.body.contains(event.target))\n      ) {\n        return;\n      }\n\n      cb(event);\n    };\n    document.addEventListener(\"pointerdown\", listener, false);\n\n    return () => {\n      document.removeEventListener(\"pointerdown\", listener);\n    };\n  }, [ref, cb]);\n};\n\nconst LibraryMenuItems = ({\n  library,\n  onRemoveFromLibrary,\n  onAddToLibrary,\n  onInsertShape,\n  pendingElements,\n  setAppState,\n}: {\n  library: LibraryItems;\n  pendingElements: LibraryItem;\n  onRemoveFromLibrary: (index: number) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: (elements: LibraryItem) => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => {\n  const isMobile = useIsMobile();\n  const numCells = library.length + (pendingElements.length > 0 ? 1 : 0);\n  const CELLS_PER_ROW = isMobile ? 4 : 6;\n  const numRows = Math.max(1, Math.ceil(numCells / CELLS_PER_ROW));\n  const rows = [];\n  let addedPendingElements = false;\n\n  rows.push(\n    <div className=\"layer-ui__library-header\">\n      <ToolButton\n        key=\"import\"\n        type=\"button\"\n        title={t(\"buttons.load\")}\n        aria-label={t(\"buttons.load\")}\n        icon={load}\n        onClick={() => {\n          importLibraryFromJSON()\n            .then(() => {\n              // Maybe we should close and open the menu so that the items get updated.\n              // But for now we just close the menu.\n              setAppState({ isLibraryOpen: false });\n            })\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n      <ToolButton\n        key=\"export\"\n        type=\"button\"\n        title={t(\"buttons.export\")}\n        aria-label={t(\"buttons.export\")}\n        icon={exportFile}\n        onClick={() => {\n          saveLibraryAsJSON()\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n\n      <a href=\"https://libraries.excalidraw.com\" target=\"_excalidraw_libraries\">\n        {t(\"labels.libraries\")}\n      </a>\n    </div>,\n  );\n\n  for (let row = 0; row < numRows; row++) {\n    const y = CELLS_PER_ROW * row;\n    const children = [];\n    for (let x = 0; x < CELLS_PER_ROW; x++) {\n      const shouldAddPendingElements: boolean =\n        pendingElements.length > 0 &&\n        !addedPendingElements &&\n        y + x >= library.length;\n      addedPendingElements = addedPendingElements || shouldAddPendingElements;\n\n      children.push(\n        <Stack.Col key={x}>\n          <LibraryUnit\n            elements={library[y + x]}\n            pendingElements={\n              shouldAddPendingElements ? pendingElements : undefined\n            }\n            onRemoveFromLibrary={onRemoveFromLibrary.bind(null, y + x)}\n            onClick={\n              shouldAddPendingElements\n                ? onAddToLibrary.bind(null, pendingElements)\n                : onInsertShape.bind(null, library[y + x])\n            }\n          />\n        </Stack.Col>,\n      );\n    }\n    rows.push(\n      <Stack.Row align=\"center\" gap={1} key={row}>\n        {children}\n      </Stack.Row>,\n    );\n  }\n\n  return (\n    <Stack.Col align=\"start\" gap={1} className=\"layer-ui__library-items\">\n      {rows}\n    </Stack.Col>\n  );\n};\n\nconst LibraryMenu = ({\n  onClickOutside,\n  onInsertShape,\n  pendingElements,\n  onAddToLibrary,\n  setAppState,\n}: {\n  pendingElements: LibraryItem;\n  onClickOutside: (event: MouseEvent) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: () => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useOnClickOutside(ref, (event) => {\n    // If click on the library icon, do nothing.\n    if ((event.target as Element).closest(\".ToolIcon_type_button__library\")) {\n      return;\n    }\n    onClickOutside(event);\n  });\n\n  const [libraryItems, setLibraryItems] = useState<LibraryItems>([]);\n\n  const [loadingState, setIsLoading] = useState<\n    \"preloading\" | \"loading\" | \"ready\"\n  >(\"preloading\");\n\n  const loadingTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    Promise.race([\n      new Promise((resolve) => {\n        loadingTimerRef.current = setTimeout(() => {\n          resolve(\"loading\");\n        }, 100);\n      }),\n      Library.loadLibrary().then((items) => {\n        setLibraryItems(items);\n        setIsLoading(\"ready\");\n      }),\n    ]).then((data) => {\n      if (data === \"loading\") {\n        setIsLoading(\"loading\");\n      }\n    });\n    return () => {\n      clearTimeout(loadingTimerRef.current!);\n    };\n  }, []);\n\n  const removeFromLibrary = useCallback(async (indexToRemove) => {\n    const items = await Library.loadLibrary();\n    const nextItems = items.filter((_, index) => index !== indexToRemove);\n    Library.saveLibrary(nextItems);\n    setLibraryItems(nextItems);\n  }, []);\n\n  const addToLibrary = useCallback(\n    async (elements: LibraryItem) => {\n      const items = await Library.loadLibrary();\n      const nextItems = [...items, elements];\n      onAddToLibrary();\n      Library.saveLibrary(nextItems);\n      setLibraryItems(nextItems);\n    },\n    [onAddToLibrary],\n  );\n\n  return loadingState === \"preloading\" ? null : (\n    <Island padding={1} ref={ref} className=\"layer-ui__library\">\n      {loadingState === \"loading\" ? (\n        <div className=\"layer-ui__library-message\">\n          {t(\"labels.libraryLoadingMessage\")}\n        </div>\n      ) : (\n          <LibraryMenuItems\n            library={libraryItems}\n            onRemoveFromLibrary={removeFromLibrary}\n            onAddToLibrary={addToLibrary}\n            onInsertShape={onInsertShape}\n            pendingElements={pendingElements}\n            setAppState={setAppState}\n          />\n        )}\n    </Island>\n  );\n};\n\nconst LayerUI = ({\n  actionManager,\n  appState,\n  setAppState,\n  canvas,\n  elements,\n  onCollabButtonClick,\n  onLockToggle,\n  onInsertElements,\n  zenModeEnabled,\n  toggleZenMode,\n  isCollaborating,\n  onExportToBackend,\n  renderCustomFooter,\n}: LayerUIProps) => {\n  const isMobile = useIsMobile();\n\n  const renderEncryptedIcon = () => (\n    <a\n      className={clsx(\"encrypted-icon tooltip zen-mode-visibility\", {\n        \"zen-mode-visibility--hidden\": zenModeEnabled,\n      })}\n      href=\"https://blog.excalidraw.com/end-to-end-encryption/\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      <Tooltip label={t(\"encrypted.tooltip\")} position=\"above\" long={true}>\n        {shield}\n      </Tooltip>\n    </a>\n  );\n\n  const renderExportDialog = () => {\n    const createExporter = (type: ExportType): ExportCB => async (\n      exportedElements,\n      scale,\n    ) => {\n      if (canvas) {\n        await exportCanvas(type, exportedElements, appState, canvas, {\n          exportBackground: appState.exportBackground,\n          name: appState.name,\n          viewBackgroundColor: appState.viewBackgroundColor,\n          scale,\n          shouldAddWatermark: appState.shouldAddWatermark,\n        })\n          .catch(muteFSAbortError)\n          .catch((error) => {\n            console.error(error);\n            setAppState({ errorMessage: error.message });\n          });\n      }\n    };\n\n    return (\n      <ExportDialog\n        elements={elements}\n        appState={appState}\n        actionManager={actionManager}\n        onExportToPng={createExporter(\"png\")}\n        onExportToSvg={createExporter(\"svg\")}\n        onExportToClipboard={createExporter(\"clipboard\")}\n        onExportToBackend={\n          onExportToBackend\n            ? (elements) => {\n              onExportToBackend &&\n                onExportToBackend(elements, appState, canvas);\n            }\n            : undefined\n        }\n      />\n    );\n  };\n\n  const renderCanvasActions = () => (\n    <Section\n      heading=\"canvasActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n      <Island padding={2} style={{ zIndex: 1 }}>\n        <Stack.Col gap={4}>\n          <Stack.Row gap={1} justifyContent=\"space-between\">\n            {actionManager.renderAction(\"loadScene\")}\n            {actionManager.renderAction(\"saveScene\")}\n            {actionManager.renderAction(\"saveAsScene\")}\n            {renderExportDialog()}\n            {actionManager.renderAction(\"clearCanvas\")}\n            {actionManager.renderAction(\"Startchat\")}\n            {onCollabButtonClick && (\n              <CollabButton\n                isCollaborating={isCollaborating}\n                collaboratorCount={appState.collaborators.size}\n                onClick={onCollabButtonClick}\n              />\n            )}\n          </Stack.Row>\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n          />\n        </Stack.Col>\n      </Island>\n    </Section>\n  );\n\n  const renderSelectedShapeActions = () => (\n    <Section\n      heading=\"selectedShapeActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      <Island className={CLASSES.SHAPE_ACTIONS_MENU} padding={2}>\n        <SelectedShapeActions\n          appState={appState}\n          elements={elements}\n          renderAction={actionManager.renderAction}\n          elementType={appState.elementType}\n        />\n      </Island>\n    </Section>\n  );\n\n  const closeLibrary = useCallback(\n    (event) => {\n      setAppState({ isLibraryOpen: false });\n    },\n    [setAppState],\n  );\n\n  const deselectItems = useCallback(() => {\n    setAppState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n    });\n  }, [setAppState]);\n\n  const libraryMenu = appState.isLibraryOpen ? (\n    <LibraryMenu\n      pendingElements={getSelectedElements(elements, appState)}\n      onClickOutside={closeLibrary}\n      onInsertShape={onInsertElements}\n      onAddToLibrary={deselectItems}\n      setAppState={setAppState}\n    />\n  ) : null;\n\n  const renderFixedSideContainer = () => {\n    const shouldRenderSelectedShapeActions = showSelectedShapeActions(\n      appState,\n      elements,\n    );\n\n    return (\n      <FixedSideContainer side=\"top\">\n        <div className=\"App-menu App-menu_top\">\n          <Stack.Col\n            gap={4}\n            className={clsx({ \"disable-pointerEvents\": zenModeEnabled })}\n          >\n            {renderCanvasActions()}\n            {shouldRenderSelectedShapeActions && renderSelectedShapeActions()}\n          </Stack.Col>\n          <Section heading=\"shapes\">\n            {(heading) => (\n              <Stack.Col gap={4} align=\"start\">\n                <Stack.Row gap={1}>\n                  <Island\n                    padding={1}\n                    className={clsx({ \"zen-mode\": zenModeEnabled })}\n                  >\n                    <HintViewer appState={appState} elements={elements} />\n                    {heading}\n                    <Stack.Row gap={1}>\n                      <ShapesSwitcher\n                        elementType={appState.elementType}\n                        setAppState={setAppState}\n                        isLibraryOpen={appState.isLibraryOpen}\n                      />\n                    </Stack.Row>\n                  </Island>\n                  <ToolButton\n                    type=\"button\"\n                    icon={mute}\n                    title={t(\"buttons.mute\")}\n                    aria-label={t(\"buttons.mute\")}\n                  />\n                  <LockIcon\n                    zenModeEnabled={zenModeEnabled}\n                    checked={appState.elementLocked}\n                    onChange={onLockToggle}\n                    title={t(\"toolBar.lock\")}\n                  />\n\n                </Stack.Row>\n                {libraryMenu}\n              </Stack.Col>\n            )}\n          </Section>\n          <UserList\n            className={clsx(\"zen-mode-transition\", {\n              \"transition-right\": zenModeEnabled,\n            })}\n          >\n            {Array.from(appState.collaborators)\n              // Collaborator is either not initialized or is actually the current user.\n              .filter(([_, client]) => Object.keys(client).length !== 0)\n              .map(([clientId, client]) => (\n                <Tooltip\n                  label={client.username || \"Unknown user\"}\n                  key={clientId}\n                >\n                  {actionManager.renderAction(\"goToCollaborator\", clientId)}\n                </Tooltip>\n              ))}\n          </UserList>\n        </div>\n      </FixedSideContainer>\n    );\n  };\n\n  const renderBottomAppMenu = () => {\n    return (\n      <div\n        className={clsx(\"App-menu App-menu_bottom zen-mode-transition\", {\n          \"App-menu_bottom--transition-left\": zenModeEnabled,\n        })}\n      >\n        <Stack.Col gap={2}>\n          <Section heading=\"canvasActions\">\n            <Island padding={1}>\n              <ZoomActions\n                renderAction={actionManager.renderAction}\n                zoom={appState.zoom}\n              />\n            </Island>\n            {renderEncryptedIcon()}\n          </Section>\n        </Stack.Col>\n      </div>\n    );\n  };\n\n  const renderFooter = () => (\n    <footer role=\"contentinfo\" className=\"layer-ui__wrapper__footer\">\n      <div\n        className={clsx(\"zen-mode-transition\", {\n          \"transition-right disable-pointerEvents\": zenModeEnabled,\n        })}\n      >\n        {renderCustomFooter?.(false)}\n        {actionManager.renderAction(\"toggleShortcuts\")}\n      </div>\n      <button\n        className={clsx(\"disable-zen-mode\", {\n          \"disable-zen-mode--visible\": zenModeEnabled,\n        })}\n        onClick={toggleZenMode}\n      >\n        {t(\"buttons.exitZenMode\")}\n      </button>\n      {appState.scrolledOutside && (\n        <button\n          className=\"scroll-back-to-content\"\n          onClick={() => {\n            setAppState({\n              ...calculateScrollCenter(elements, appState, canvas),\n            });\n          }}\n        >\n          {t(\"buttons.scrollBackToContent\")}\n        </button>\n      )}\n    </footer>\n  );\n\n  const dialogs = (\n    <>\n      {appState.isLoading && <LoadingMessage />}\n      {appState.errorMessage && (\n        <ErrorDialog\n          message={appState.errorMessage}\n          onClose={() => setAppState({ errorMessage: null })}\n        />\n      )}\n      {appState.showHelpDialog && (\n        <HelpDialog onClose={() => setAppState({ showHelpDialog: false })} />\n      )}\n      {appState.pasteDialog.shown && (\n        <PasteChartDialog\n          setAppState={setAppState}\n          appState={appState}\n          onInsertChart={onInsertElements}\n          onClose={() =>\n            setAppState({\n              pasteDialog: { shown: false, data: null },\n            })\n          }\n        />\n      )}\n    </>\n  );\n\n  return isMobile ? (\n    <>\n      {dialogs}\n      <MobileMenu\n        appState={appState}\n        elements={elements}\n        actionManager={actionManager}\n        libraryMenu={libraryMenu}\n        exportButton={renderExportDialog()}\n        setAppState={setAppState}\n        onCollabButtonClick={onCollabButtonClick}\n        onLockToggle={onLockToggle}\n        canvas={canvas}\n        isCollaborating={isCollaborating}\n        renderCustomFooter={renderCustomFooter}\n      />\n    </>\n  ) : (\n      <div className=\"layer-ui__wrapper\">\n        {dialogs}\n        {renderFixedSideContainer()}\n        {renderBottomAppMenu()}\n        {\n          <aside\n            className={clsx(\n              \"layer-ui__wrapper__github-corner zen-mode-transition\",\n              {\n                \"transition-right\": zenModeEnabled,\n              },\n            )}\n          >\n            <GitHubCorner appearance={appState.appearance} />\n          </aside>\n        }\n        {renderFooter()}\n      </div>\n    );\n};\n\nconst areEqual = (prev: LayerUIProps, next: LayerUIProps) => {\n  const getNecessaryObj = (appState: AppState): Partial<AppState> => {\n    const {\n      suggestedBindings,\n      startBoundElement: boundElement,\n      ...ret\n    } = appState;\n    return ret;\n  };\n  const prevAppState = getNecessaryObj(prev.appState);\n  const nextAppState = getNecessaryObj(next.appState);\n\n  const keys = Object.keys(prevAppState) as (keyof Partial<AppState>)[];\n  return (\n    prev.langCode === next.langCode &&\n    prev.elements === next.elements &&\n    keys.every((key) => prevAppState[key] === nextAppState[key])\n  );\n};\n\nexport default React.memo(LayerUI, areEqual);\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/clients.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HintViewer.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/LibraryUnit.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionZindex.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionDistribute.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionProperties.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/index.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Modal.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/scene/scroll.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/encode.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/linearElementEditor.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionGroup.tsx",[],["724","725"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ExportDialog.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/sentry.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/collab/CollabWrapper.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/newElement.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/resizeElements.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/binding.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Avatar.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Stack.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/HelpDialog.tsx",["726"],"import React from \"react\";\nimport { t } from \"../i18n\";\nimport { isDarwin } from \"../keys\";\nimport { Dialog } from \"./Dialog\";\nimport { getShortcutKey } from \"../utils\";\nimport \"./HelpDialog.scss\";\n\nconst Header = () => (\n  <div className=\"HelpDialog--header\">\n  </div>\n);\n\nconst Section = (props: { title: string; children: React.ReactNode }) => (\n  <>\n    <h3>{props.title}</h3>\n    {props.children}\n  </>\n);\n\nconst Columns = (props: { children: React.ReactNode }) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n    }}\n  >\n    {props.children}\n  </div>\n);\n\nconst Column = (props: { children: React.ReactNode }) => (\n  <div style={{ width: \"49%\" }}>{props.children}</div>\n);\n\nconst ShortcutIsland = (props: {\n  caption: string;\n  children: React.ReactNode;\n}) => (\n  <div className=\"HelpDialog--island\">\n    <h3 className=\"HelpDialog--island-title\">{props.caption}</h3>\n    {props.children}\n  </div>\n);\n\nconst Shortcut = (props: {\n  label: string;\n  shortcuts: string[];\n  isOr: boolean;\n}) => {\n  return (\n    <div className=\"HelpDialog--shortcut\">\n      <div\n        style={{\n          display: \"flex\",\n          margin: \"0\",\n          padding: \"4px 8px\",\n          alignItems: \"center\",\n        }}\n      >\n        <div\n          style={{\n            lineHeight: 1.4,\n          }}\n        >\n          {props.label}\n        </div>\n        <div\n          style={{\n            display: \"flex\",\n            flex: \"0 0 auto\",\n            justifyContent: \"flex-end\",\n            marginInlineStart: \"auto\",\n            minWidth: \"30%\",\n          }}\n        >\n          {props.shortcuts.map((shortcut, index) => (\n            <React.Fragment key={index}>\n              <ShortcutKey>{shortcut}</ShortcutKey>\n              {props.isOr &&\n                index !== props.shortcuts.length - 1 &&\n                t(\"helpDialog.or\")}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nShortcut.defaultProps = {\n  isOr: true,\n};\n\nconst ShortcutKey = (props: { children: React.ReactNode }) => (\n  <kbd className=\"HelpDialog--key\" {...props} />\n);\n\nexport const HelpDialog = ({ onClose }: { onClose?: () => void }) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      <Dialog\n        onCloseRequest={handleClose}\n        title={t(\"helpDialog.title\")}\n        className={\"HelpDialog\"}\n      >\n        <Header />\n        <Section title={t(\"helpDialog.shortcuts\")}>\n          <Columns>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.shapes\")}>\n                <Shortcut\n                  label={t(\"toolBar.selection\")}\n                  shortcuts={[\"V\", \"1\"]}\n                />\n                <Shortcut\n                  label={t(\"toolBar.rectangle\")}\n                  shortcuts={[\"R\", \"2\"]}\n                />\n                <Shortcut label={t(\"toolBar.diamond\")} shortcuts={[\"D\", \"3\"]} />\n                <Shortcut label={t(\"toolBar.ellipse\")} shortcuts={[\"E\", \"4\"]} />\n                <Shortcut label={t(\"toolBar.arrow\")} shortcuts={[\"A\", \"5\"]} />\n                <Shortcut label={t(\"toolBar.line\")} shortcuts={[\"P\", \"6\"]} />\n                <Shortcut\n                  label={t(\"toolBar.draw\")}\n                  shortcuts={[\"Shift+P\", \"7\"]}\n                />\n                <Shortcut label={t(\"toolBar.text\")} shortcuts={[\"T\", \"8\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.textNewLine\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    getShortcutKey(\"Shift+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textFinish\")}\n                  shortcuts={[\n                    getShortcutKey(\"Esc\"),\n                    getShortcutKey(\"CtrlOrCmd+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedArrow\")}\n                  shortcuts={[\n                    \"A\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedLine\")}\n                  shortcuts={[\n                    \"L\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut label={t(\"toolBar.lock\")} shortcuts={[\"Q\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.preventBinding\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd\")]}\n                />\n              </ShortcutIsland>\n              <ShortcutIsland caption={t(\"helpDialog.view\")}>\n                <Shortcut\n                  label={t(\"buttons.zoomIn\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd++\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.zoomOut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+-\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.resetZoom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+0\")]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToFit\")}\n                  shortcuts={[\"Shift+1\"]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToSelection\")}\n                  shortcuts={[\"Shift+2\"]}\n                />\n                <Shortcut label={t(\"buttons.fullScreen\")} shortcuts={[\"F\"]} />\n                <Shortcut\n                  label={t(\"buttons.zenMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.gridMode\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+'\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.editor\")}>\n                <Shortcut\n                  label={t(\"labels.selectAll\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+A\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.multiSelect\")}\n                  shortcuts={[getShortcutKey(`Shift+${t(\"helpDialog.click\")}`)]}\n                />\n                <Shortcut\n                  label={t(\"labels.moveCanvas\")}\n                  shortcuts={[\n                    getShortcutKey(`Space+${t(\"helpDialog.drag\")}`),\n                    getShortcutKey(`Wheel+${t(\"helpDialog.drag\")}`),\n                  ]}\n                  isOr={true}\n                />\n                <Shortcut\n                  label={t(\"labels.cut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+X\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copy\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.paste\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyAsPng\")}\n                  shortcuts={[getShortcutKey(\"Shift+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.pasteStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.delete\")}\n                  shortcuts={[getShortcutKey(\"Del\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendToBack\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringToFront\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendBackward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+[\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringForward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+]\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignTop\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Up\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignBottom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Down\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignLeft\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Left\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignRight\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Right\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.duplicateSelection\")}\n                  shortcuts={[\n                    getShortcutKey(\"CtrlOrCmd+D\"),\n                    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"buttons.undo\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.redo\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.group\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.ungroup\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+G\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n          </Columns>\n        </Section>\n      </Dialog>\n    </>\n  );\n};\n","/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/components/LanguageList.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/typeChecks.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/data/library.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/groups.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/gesture.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/register.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionHistory.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Popover.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/data/firebase.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/is-mobile.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/Stats.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/manager.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/actionCanvas.tsx",["727","728","729","730","731","732","733"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ProjectName.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/ButtonSelect.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/excalidraw-app/app_constants.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/textWysiwyg.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/history.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/actions/index.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/components/CollabButton.tsx",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/element/sizeHelpers.ts",[],"/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/LoginPage.tsx",["734","735","736","737","738","739","740","741","742","743","744","745","746","747","748","749","750","751","752","753","754","755","756","757","758","759","760","761","762","763","764","765","766"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/RegisterPage.tsx",["767","768","769","770","771","772","773","774","775","776","777","778","779","780","781","782","783","784"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/authenticationRoute.ts",["785","786","787","788","789"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/auth.api.ts",["790","791","792","793","794","795","796","797","798","799","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819"],"/var/www/html/whiteboard_micro/sharewhiteboard/src/auth/Auth.component.ts",["820","821","822","823","824"],{"ruleId":"825","replacedBy":"826"},{"ruleId":"827","replacedBy":"828"},{"ruleId":"825","replacedBy":"829"},{"ruleId":"827","replacedBy":"830"},{"ruleId":"825","replacedBy":"831"},{"ruleId":"827","replacedBy":"832"},{"ruleId":"825","replacedBy":"833"},{"ruleId":"827","replacedBy":"834"},{"ruleId":"825","replacedBy":"826"},{"ruleId":"827","replacedBy":"828"},{"ruleId":"825","replacedBy":"835"},{"ruleId":"827","replacedBy":"836"},{"ruleId":"825","replacedBy":"837"},{"ruleId":"827","replacedBy":"838"},{"ruleId":"825","replacedBy":"839"},{"ruleId":"827","replacedBy":"840"},{"ruleId":"825","replacedBy":"841"},{"ruleId":"827","replacedBy":"842"},{"ruleId":"843","severity":1,"message":"844","line":25,"column":1,"nodeType":null,"endLine":26,"endColumn":1,"fix":"845"},{"ruleId":"843","severity":1,"message":"844","line":27,"column":1,"nodeType":null,"endLine":28,"endColumn":1,"fix":"846"},{"ruleId":"843","severity":1,"message":"844","line":29,"column":1,"nodeType":null,"endLine":30,"endColumn":1,"fix":"847"},{"ruleId":"843","severity":1,"message":"844","line":31,"column":1,"nodeType":null,"endLine":32,"endColumn":1,"fix":"848"},{"ruleId":"825","replacedBy":"849"},{"ruleId":"827","replacedBy":"850"},{"ruleId":"825","replacedBy":"851"},{"ruleId":"827","replacedBy":"852"},{"ruleId":"853","severity":1,"message":"854","line":10,"column":10,"nodeType":"855","messageId":"856","endLine":10,"endColumn":22},{"ruleId":"857","severity":1,"message":"854","line":10,"column":10,"nodeType":"855","messageId":"856","endLine":10,"endColumn":22},{"ruleId":"853","severity":1,"message":"858","line":10,"column":24,"nodeType":"855","messageId":"856","endLine":10,"endColumn":39},{"ruleId":"857","severity":1,"message":"858","line":10,"column":24,"nodeType":"855","messageId":"856","endLine":10,"endColumn":39},{"ruleId":"843","severity":1,"message":"859","line":10,"column":63,"nodeType":null,"endLine":10,"endColumn":63,"fix":"860"},{"ruleId":"843","severity":1,"message":"861","line":76,"column":816,"nodeType":null,"endLine":76,"endColumn":816,"fix":"862"},{"ruleId":"843","severity":1,"message":"859","line":77,"column":2,"nodeType":null,"endLine":77,"endColumn":2,"fix":"863"},{"ruleId":"843","severity":1,"message":"861","line":79,"column":516,"nodeType":null,"endLine":79,"endColumn":516,"fix":"864"},{"ruleId":"843","severity":1,"message":"859","line":80,"column":2,"nodeType":null,"endLine":80,"endColumn":2,"fix":"865"},{"ruleId":"843","severity":1,"message":"861","line":82,"column":761,"nodeType":null,"endLine":82,"endColumn":761,"fix":"866"},{"ruleId":"843","severity":1,"message":"859","line":83,"column":2,"nodeType":null,"endLine":83,"endColumn":2,"fix":"867"},{"ruleId":"843","severity":1,"message":"868","line":1233,"column":13,"nodeType":null,"endLine":1233,"endColumn":13,"fix":"869"},{"ruleId":"843","severity":1,"message":"868","line":1234,"column":1,"nodeType":null,"endLine":1234,"endColumn":1,"fix":"870"},{"ruleId":"843","severity":1,"message":"868","line":1619,"column":9,"nodeType":null,"endLine":1619,"endColumn":9,"fix":"871"},{"ruleId":"843","severity":1,"message":"868","line":1620,"column":1,"nodeType":null,"endLine":1620,"endColumn":1,"fix":"872"},{"ruleId":"843","severity":1,"message":"868","line":1621,"column":1,"nodeType":null,"endLine":1621,"endColumn":1,"fix":"873"},{"ruleId":"843","severity":1,"message":"868","line":1622,"column":9,"nodeType":null,"endLine":1622,"endColumn":9,"fix":"874"},{"ruleId":"843","severity":1,"message":"868","line":1623,"column":1,"nodeType":null,"endLine":1623,"endColumn":1,"fix":"875"},{"ruleId":"843","severity":1,"message":"868","line":1624,"column":1,"nodeType":null,"endLine":1624,"endColumn":1,"fix":"876"},{"ruleId":"843","severity":1,"message":"868","line":1625,"column":9,"nodeType":null,"endLine":1625,"endColumn":9,"fix":"877"},{"ruleId":"843","severity":1,"message":"868","line":1626,"column":1,"nodeType":null,"endLine":1626,"endColumn":1,"fix":"878"},{"ruleId":"843","severity":1,"message":"868","line":1627,"column":1,"nodeType":null,"endLine":1627,"endColumn":1,"fix":"879"},{"ruleId":"843","severity":1,"message":"868","line":1628,"column":9,"nodeType":null,"endLine":1628,"endColumn":9,"fix":"880"},{"ruleId":"843","severity":1,"message":"868","line":1629,"column":1,"nodeType":null,"endLine":1629,"endColumn":1,"fix":"881"},{"ruleId":"843","severity":1,"message":"868","line":1630,"column":1,"nodeType":null,"endLine":1630,"endColumn":1,"fix":"882"},{"ruleId":"843","severity":1,"message":"868","line":1631,"column":9,"nodeType":null,"endLine":1631,"endColumn":9,"fix":"883"},{"ruleId":"843","severity":1,"message":"868","line":1632,"column":1,"nodeType":null,"endLine":1632,"endColumn":1,"fix":"884"},{"ruleId":"843","severity":1,"message":"868","line":1633,"column":1,"nodeType":null,"endLine":1633,"endColumn":1,"fix":"885"},{"ruleId":"843","severity":1,"message":"868","line":1634,"column":9,"nodeType":null,"endLine":1634,"endColumn":9,"fix":"886"},{"ruleId":"843","severity":1,"message":"868","line":1635,"column":1,"nodeType":null,"endLine":1635,"endColumn":1,"fix":"887"},{"ruleId":"843","severity":1,"message":"868","line":1636,"column":1,"nodeType":null,"endLine":1636,"endColumn":1,"fix":"888"},{"ruleId":"843","severity":1,"message":"868","line":1637,"column":11,"nodeType":null,"endLine":1637,"endColumn":11,"fix":"889"},{"ruleId":"843","severity":1,"message":"868","line":1638,"column":1,"nodeType":null,"endLine":1638,"endColumn":1,"fix":"890"},{"ruleId":"843","severity":1,"message":"868","line":1639,"column":1,"nodeType":null,"endLine":1639,"endColumn":1,"fix":"891"},{"ruleId":"843","severity":1,"message":"868","line":1640,"column":11,"nodeType":null,"endLine":1640,"endColumn":11,"fix":"892"},{"ruleId":"843","severity":1,"message":"868","line":1641,"column":1,"nodeType":null,"endLine":1641,"endColumn":1,"fix":"893"},{"ruleId":"843","severity":1,"message":"868","line":1642,"column":1,"nodeType":null,"endLine":1642,"endColumn":1,"fix":"894"},{"ruleId":"843","severity":1,"message":"895","line":3311,"column":11,"nodeType":null,"endLine":3311,"endColumn":13,"fix":"896"},{"ruleId":"843","severity":1,"message":"895","line":3312,"column":1,"nodeType":null,"endLine":3312,"endColumn":3,"fix":"897"},{"ruleId":"843","severity":1,"message":"895","line":3372,"column":9,"nodeType":null,"endLine":3372,"endColumn":11,"fix":"898"},{"ruleId":"843","severity":1,"message":"895","line":3373,"column":11,"nodeType":null,"endLine":3373,"endColumn":13,"fix":"899"},{"ruleId":"843","severity":1,"message":"900","line":3374,"column":1,"nodeType":null,"endLine":3374,"endColumn":13,"fix":"901"},{"ruleId":"843","severity":1,"message":"895","line":3375,"column":11,"nodeType":null,"endLine":3375,"endColumn":13,"fix":"902"},{"ruleId":"843","severity":1,"message":"895","line":3376,"column":1,"nodeType":null,"endLine":3376,"endColumn":3,"fix":"903"},{"ruleId":"843","severity":1,"message":"895","line":3397,"column":9,"nodeType":null,"endLine":3397,"endColumn":11,"fix":"904"},{"ruleId":"843","severity":1,"message":"895","line":3398,"column":1,"nodeType":null,"endLine":3398,"endColumn":3,"fix":"905"},{"ruleId":"843","severity":1,"message":"868","line":3630,"column":11,"nodeType":null,"endLine":3630,"endColumn":11,"fix":"906"},{"ruleId":"843","severity":1,"message":"868","line":3631,"column":1,"nodeType":null,"endLine":3631,"endColumn":1,"fix":"907"},{"ruleId":"843","severity":1,"message":"908","line":3632,"column":1,"nodeType":null,"endLine":3632,"endColumn":13,"fix":"909"},{"ruleId":"843","severity":1,"message":"868","line":3633,"column":1,"nodeType":null,"endLine":3633,"endColumn":1,"fix":"910"},{"ruleId":"843","severity":1,"message":"868","line":3634,"column":1,"nodeType":null,"endLine":3634,"endColumn":1,"fix":"911"},{"ruleId":"843","severity":1,"message":"868","line":3636,"column":11,"nodeType":null,"endLine":3636,"endColumn":11,"fix":"912"},{"ruleId":"843","severity":1,"message":"868","line":3637,"column":1,"nodeType":null,"endLine":3637,"endColumn":1,"fix":"913"},{"ruleId":"843","severity":1,"message":"908","line":3638,"column":1,"nodeType":null,"endLine":3638,"endColumn":13,"fix":"914"},{"ruleId":"843","severity":1,"message":"868","line":3639,"column":1,"nodeType":null,"endLine":3639,"endColumn":1,"fix":"915"},{"ruleId":"843","severity":1,"message":"868","line":3640,"column":1,"nodeType":null,"endLine":3640,"endColumn":1,"fix":"916"},{"ruleId":"857","severity":1,"message":"917","line":1,"column":8,"nodeType":"855","messageId":"856","endLine":1,"endColumn":10},{"ruleId":"853","severity":1,"message":"917","line":1,"column":8,"nodeType":"855","messageId":"856","endLine":1,"endColumn":10},{"ruleId":"843","severity":1,"message":"918","line":6,"column":57,"nodeType":null,"endLine":9,"endColumn":4,"fix":"919"},{"ruleId":"843","severity":1,"message":"920","line":4,"column":9,"nodeType":null,"endLine":4,"endColumn":34,"fix":"921"},{"ruleId":"843","severity":1,"message":"922","line":5,"column":9,"nodeType":null,"endLine":5,"endColumn":34,"fix":"923"},{"ruleId":"843","severity":1,"message":"924","line":6,"column":32,"nodeType":null,"endLine":6,"endColumn":49,"fix":"925"},{"ruleId":"843","severity":1,"message":"926","line":16,"column":3,"nodeType":null,"endLine":16,"endColumn":29,"fix":"927"},{"ruleId":"843","severity":1,"message":"928","line":17,"column":7,"nodeType":null,"endLine":17,"endColumn":15,"fix":"929"},{"ruleId":"843","severity":1,"message":"930","line":18,"column":1,"nodeType":null,"endLine":18,"endColumn":32,"fix":"931"},{"ruleId":"843","severity":1,"message":"932","line":19,"column":6,"nodeType":null,"endLine":19,"endColumn":7,"fix":"933"},{"ruleId":"843","severity":1,"message":"934","line":20,"column":3,"nodeType":null,"endLine":20,"endColumn":3,"fix":"935"},{"ruleId":"843","severity":1,"message":"936","line":21,"column":1,"nodeType":null,"endLine":21,"endColumn":15,"fix":"937"},{"ruleId":"843","severity":1,"message":"938","line":22,"column":5,"nodeType":null,"endLine":22,"endColumn":27,"fix":"939"},{"ruleId":"843","severity":1,"message":"895","line":23,"column":1,"nodeType":null,"endLine":23,"endColumn":3,"fix":"940"},{"ruleId":"843","severity":1,"message":"895","line":24,"column":1,"nodeType":null,"endLine":24,"endColumn":3,"fix":"941"},{"ruleId":"843","severity":1,"message":"936","line":25,"column":1,"nodeType":null,"endLine":25,"endColumn":15,"fix":"942"},{"ruleId":"843","severity":1,"message":"943","line":26,"column":1,"nodeType":null,"endLine":26,"endColumn":30,"fix":"944"},{"ruleId":"843","severity":1,"message":"945","line":27,"column":1,"nodeType":null,"endLine":27,"endColumn":7,"fix":"946"},{"ruleId":"843","severity":1,"message":"859","line":28,"column":3,"nodeType":null,"endLine":28,"endColumn":3,"fix":"947"},{"ruleId":"843","severity":1,"message":"948","line":32,"column":17,"nodeType":null,"endLine":32,"endColumn":103,"fix":"949"},{"ruleId":"843","severity":1,"message":"950","line":33,"column":1,"nodeType":null,"endLine":33,"endColumn":36,"fix":"951"},{"ruleId":"825","replacedBy":"952"},{"ruleId":"827","replacedBy":"953"},{"ruleId":"853","severity":1,"message":"954","line":30,"column":28,"nodeType":"855","messageId":"856","endLine":30,"endColumn":34},{"ruleId":"857","severity":1,"message":"954","line":30,"column":28,"nodeType":"855","messageId":"856","endLine":30,"endColumn":34},{"ruleId":"843","severity":1,"message":"895","line":275,"column":9,"nodeType":null,"endLine":275,"endColumn":11,"fix":"955"},{"ruleId":"843","severity":1,"message":"895","line":276,"column":1,"nodeType":null,"endLine":276,"endColumn":3,"fix":"956"},{"ruleId":"843","severity":1,"message":"895","line":277,"column":11,"nodeType":null,"endLine":277,"endColumn":13,"fix":"957"},{"ruleId":"843","severity":1,"message":"895","line":278,"column":1,"nodeType":null,"endLine":278,"endColumn":3,"fix":"958"},{"ruleId":"843","severity":1,"message":"895","line":279,"column":11,"nodeType":null,"endLine":279,"endColumn":13,"fix":"959"},{"ruleId":"843","severity":1,"message":"895","line":280,"column":1,"nodeType":null,"endLine":280,"endColumn":3,"fix":"960"},{"ruleId":"843","severity":1,"message":"895","line":281,"column":11,"nodeType":null,"endLine":281,"endColumn":13,"fix":"961"},{"ruleId":"843","severity":1,"message":"895","line":282,"column":1,"nodeType":null,"endLine":282,"endColumn":3,"fix":"962"},{"ruleId":"843","severity":1,"message":"895","line":283,"column":7,"nodeType":null,"endLine":283,"endColumn":9,"fix":"963"},{"ruleId":"843","severity":1,"message":"868","line":352,"column":15,"nodeType":null,"endLine":352,"endColumn":15,"fix":"964"},{"ruleId":"843","severity":1,"message":"868","line":353,"column":1,"nodeType":null,"endLine":353,"endColumn":1,"fix":"965"},{"ruleId":"843","severity":1,"message":"868","line":354,"column":1,"nodeType":null,"endLine":354,"endColumn":1,"fix":"966"},{"ruleId":"843","severity":1,"message":"844","line":485,"column":1,"nodeType":null,"endLine":486,"endColumn":1,"fix":"967"},{"ruleId":"843","severity":1,"message":"895","line":613,"column":5,"nodeType":null,"endLine":613,"endColumn":7,"fix":"968"},{"ruleId":"843","severity":1,"message":"895","line":614,"column":1,"nodeType":null,"endLine":614,"endColumn":3,"fix":"969"},{"ruleId":"843","severity":1,"message":"895","line":615,"column":7,"nodeType":null,"endLine":615,"endColumn":9,"fix":"970"},{"ruleId":"843","severity":1,"message":"971","line":616,"column":1,"nodeType":null,"endLine":616,"endColumn":9,"fix":"972"},{"ruleId":"843","severity":1,"message":"895","line":617,"column":7,"nodeType":null,"endLine":617,"endColumn":9,"fix":"973"},{"ruleId":"843","severity":1,"message":"974","line":618,"column":1,"nodeType":null,"endLine":618,"endColumn":11,"fix":"975"},{"ruleId":"843","severity":1,"message":"895","line":619,"column":1,"nodeType":null,"endLine":619,"endColumn":3,"fix":"976"},{"ruleId":"843","severity":1,"message":"977","line":620,"column":1,"nodeType":null,"endLine":620,"endColumn":15,"fix":"978"},{"ruleId":"843","severity":1,"message":"895","line":621,"column":13,"nodeType":null,"endLine":621,"endColumn":15,"fix":"979"},{"ruleId":"843","severity":1,"message":"980","line":622,"column":1,"nodeType":null,"endLine":622,"endColumn":17,"fix":"981"},{"ruleId":"843","severity":1,"message":"895","line":623,"column":13,"nodeType":null,"endLine":623,"endColumn":15,"fix":"982"},{"ruleId":"843","severity":1,"message":"900","line":624,"column":1,"nodeType":null,"endLine":624,"endColumn":13,"fix":"983"},{"ruleId":"843","severity":1,"message":"895","line":625,"column":9,"nodeType":null,"endLine":625,"endColumn":11,"fix":"984"},{"ruleId":"843","severity":1,"message":"895","line":626,"column":1,"nodeType":null,"endLine":626,"endColumn":3,"fix":"985"},{"ruleId":"843","severity":1,"message":"895","line":627,"column":9,"nodeType":null,"endLine":627,"endColumn":11,"fix":"986"},{"ruleId":"843","severity":1,"message":"971","line":628,"column":1,"nodeType":null,"endLine":628,"endColumn":9,"fix":"987"},{"ruleId":"843","severity":1,"message":"895","line":629,"column":1,"nodeType":null,"endLine":629,"endColumn":3,"fix":"988"},{"ruleId":"843","severity":1,"message":"895","line":630,"column":5,"nodeType":null,"endLine":630,"endColumn":7,"fix":"989"},{"ruleId":"843","severity":1,"message":"895","line":631,"column":1,"nodeType":null,"endLine":631,"endColumn":3,"fix":"990"},{"ruleId":"825","replacedBy":"991"},{"ruleId":"827","replacedBy":"992"},{"ruleId":"843","severity":1,"message":"993","line":8,"column":22,"nodeType":null,"endLine":11,"endColumn":2,"fix":"994"},{"ruleId":"857","severity":1,"message":"854","line":18,"column":10,"nodeType":"855","messageId":"856","endLine":18,"endColumn":22},{"ruleId":"853","severity":1,"message":"854","line":18,"column":10,"nodeType":"855","messageId":"856","endLine":18,"endColumn":22},{"ruleId":"857","severity":1,"message":"858","line":18,"column":24,"nodeType":"855","messageId":"856","endLine":18,"endColumn":39},{"ruleId":"853","severity":1,"message":"858","line":18,"column":24,"nodeType":"855","messageId":"856","endLine":18,"endColumn":39},{"ruleId":"843","severity":1,"message":"859","line":18,"column":63,"nodeType":null,"endLine":18,"endColumn":63,"fix":"995"},{"ruleId":"843","severity":1,"message":"996","line":254,"column":9,"nodeType":null,"endLine":254,"endColumn":20,"fix":"997"},{"ruleId":"843","severity":1,"message":"998","line":272,"column":1,"nodeType":null,"endLine":273,"endColumn":3,"fix":"999"},{"ruleId":"853","severity":1,"message":"1000","line":2,"column":27,"nodeType":"855","messageId":"856","endLine":2,"endColumn":33},{"ruleId":"857","severity":1,"message":"1000","line":2,"column":27,"nodeType":"855","messageId":"856","endLine":2,"endColumn":33},{"ruleId":"843","severity":1,"message":"1001","line":7,"column":9,"nodeType":null,"endLine":7,"endColumn":21,"fix":"1002"},{"ruleId":"843","severity":1,"message":"1003","line":9,"column":15,"nodeType":null,"endLine":9,"endColumn":17,"fix":"1004"},{"ruleId":"843","severity":1,"message":"1005","line":10,"column":15,"nodeType":null,"endLine":10,"endColumn":17,"fix":"1006"},{"ruleId":"843","severity":1,"message":"1003","line":13,"column":38,"nodeType":null,"endLine":13,"endColumn":40,"fix":"1007"},{"ruleId":"843","severity":1,"message":"1008","line":16,"column":7,"nodeType":null,"endLine":16,"endColumn":41,"fix":"1009"},{"ruleId":"1010","severity":1,"message":"1011","line":16,"column":17,"nodeType":"1012","messageId":"1013","endLine":16,"endColumn":19},{"ruleId":"1010","severity":1,"message":"1011","line":16,"column":35,"nodeType":"1012","messageId":"1013","endLine":16,"endColumn":37},{"ruleId":"843","severity":1,"message":"1014","line":17,"column":16,"nodeType":null,"endLine":17,"endColumn":52,"fix":"1015"},{"ruleId":"843","severity":1,"message":"1016","line":21,"column":12,"nodeType":null,"endLine":21,"endColumn":25,"fix":"1017"},{"ruleId":"843","severity":1,"message":"1018","line":22,"column":16,"nodeType":null,"endLine":22,"endColumn":17,"fix":"1019"},{"ruleId":"843","severity":1,"message":"861","line":23,"column":15,"nodeType":null,"endLine":23,"endColumn":15,"fix":"1020"},{"ruleId":"843","severity":1,"message":"1021","line":26,"column":7,"nodeType":null,"endLine":26,"endColumn":14,"fix":"1022"},{"ruleId":"843","severity":1,"message":"1023","line":29,"column":6,"nodeType":null,"endLine":29,"endColumn":10,"fix":"1024"},{"ruleId":"1025","severity":1,"message":"1026","line":29,"column":10,"nodeType":"1027","messageId":"1013","endLine":32,"endColumn":6,"fix":"1028"},{"ruleId":"843","severity":1,"message":"1029","line":30,"column":36,"nodeType":null,"endLine":30,"endColumn":36,"fix":"1030"},{"ruleId":"843","severity":1,"message":"859","line":33,"column":4,"nodeType":null,"endLine":33,"endColumn":4,"fix":"1031"},{"ruleId":"1032","severity":1,"message":"1033","line":37,"column":33,"nodeType":"1034","messageId":"1035","endLine":37,"endColumn":41},{"ruleId":"843","severity":1,"message":"1036","line":38,"column":13,"nodeType":null,"endLine":38,"endColumn":71,"fix":"1037"},{"ruleId":"843","severity":1,"message":"1038","line":39,"column":1,"nodeType":null,"endLine":39,"endColumn":1,"fix":"1039"},{"ruleId":"843","severity":1,"message":"1040","line":40,"column":1,"nodeType":null,"endLine":40,"endColumn":17,"fix":"1041"},{"ruleId":"843","severity":1,"message":"1042","line":41,"column":1,"nodeType":null,"endLine":41,"endColumn":11,"fix":"1043"},{"ruleId":"1032","severity":1,"message":"1033","line":42,"column":33,"nodeType":"1034","messageId":"1035","endLine":42,"endColumn":41},{"ruleId":"843","severity":1,"message":"1044","line":43,"column":13,"nodeType":null,"endLine":43,"endColumn":86,"fix":"1045"},{"ruleId":"843","severity":1,"message":"1038","line":44,"column":9,"nodeType":null,"endLine":44,"endColumn":9,"fix":"1046"},{"ruleId":"843","severity":1,"message":"1047","line":45,"column":1,"nodeType":null,"endLine":45,"endColumn":33,"fix":"1048"},{"ruleId":"843","severity":1,"message":"1042","line":46,"column":1,"nodeType":null,"endLine":46,"endColumn":11,"fix":"1049"},{"ruleId":"1032","severity":1,"message":"1033","line":47,"column":29,"nodeType":"1034","messageId":"1035","endLine":47,"endColumn":34},{"ruleId":"843","severity":1,"message":"1018","line":48,"column":8,"nodeType":null,"endLine":48,"endColumn":9,"fix":"1050"},{"ruleId":"843","severity":1,"message":"859","line":50,"column":4,"nodeType":null,"endLine":50,"endColumn":4,"fix":"1051"},{"ruleId":"843","severity":1,"message":"859","line":51,"column":2,"nodeType":null,"endLine":51,"endColumn":2,"fix":"1052"},{"ruleId":"843","severity":1,"message":"1053","line":52,"column":26,"nodeType":null,"endLine":52,"endColumn":26,"fix":"1054"},{"ruleId":"853","severity":1,"message":"1000","line":1,"column":27,"nodeType":"855","messageId":"856","endLine":1,"endColumn":33},{"ruleId":"857","severity":1,"message":"1000","line":1,"column":27,"nodeType":"855","messageId":"856","endLine":1,"endColumn":33},{"ruleId":"843","severity":1,"message":"1003","line":6,"column":15,"nodeType":null,"endLine":6,"endColumn":17,"fix":"1055"},{"ruleId":"843","severity":1,"message":"1005","line":7,"column":15,"nodeType":null,"endLine":7,"endColumn":17,"fix":"1056"},{"ruleId":"1032","severity":1,"message":"1033","line":12,"column":33,"nodeType":"1034","messageId":"1035","endLine":12,"endColumn":41},{"ruleId":"843","severity":1,"message":"1036","line":13,"column":13,"nodeType":null,"endLine":13,"endColumn":71,"fix":"1057"},{"ruleId":"843","severity":1,"message":"1058","line":14,"column":1,"nodeType":null,"endLine":14,"endColumn":9,"fix":"1059"},{"ruleId":"843","severity":1,"message":"1060","line":15,"column":9,"nodeType":null,"endLine":15,"endColumn":17,"fix":"1061"},{"ruleId":"843","severity":1,"message":"1042","line":16,"column":1,"nodeType":null,"endLine":16,"endColumn":11,"fix":"1062"},{"ruleId":"1032","severity":1,"message":"1033","line":17,"column":33,"nodeType":"1034","messageId":"1035","endLine":17,"endColumn":41},{"ruleId":"843","severity":1,"message":"1044","line":18,"column":13,"nodeType":null,"endLine":18,"endColumn":86,"fix":"1063"},{"ruleId":"843","severity":1,"message":"1038","line":19,"column":9,"nodeType":null,"endLine":19,"endColumn":9,"fix":"1064"},{"ruleId":"843","severity":1,"message":"1047","line":20,"column":1,"nodeType":null,"endLine":20,"endColumn":33,"fix":"1065"},{"ruleId":"843","severity":1,"message":"1042","line":21,"column":1,"nodeType":null,"endLine":21,"endColumn":11,"fix":"1066"},{"ruleId":"1032","severity":1,"message":"1033","line":22,"column":29,"nodeType":"1034","messageId":"1035","endLine":22,"endColumn":34},{"ruleId":"843","severity":1,"message":"859","line":24,"column":4,"nodeType":null,"endLine":24,"endColumn":4,"fix":"1067"},{"ruleId":"843","severity":1,"message":"859","line":25,"column":2,"nodeType":null,"endLine":25,"endColumn":2,"fix":"1068"},{"ruleId":"843","severity":1,"message":"1053","line":26,"column":29,"nodeType":null,"endLine":26,"endColumn":29,"fix":"1069"},{"ruleId":"843","severity":1,"message":"1070","line":1,"column":9,"nodeType":null,"endLine":1,"endColumn":44,"fix":"1071"},{"ruleId":"843","severity":1,"message":"1072","line":4,"column":1,"nodeType":null,"endLine":4,"endColumn":18,"fix":"1073"},{"ruleId":"843","severity":1,"message":"1029","line":7,"column":66,"nodeType":null,"endLine":7,"endColumn":66,"fix":"1074"},{"ruleId":"843","severity":1,"message":"1075","line":8,"column":1,"nodeType":null,"endLine":8,"endColumn":86,"fix":"1076"},{"ruleId":"843","severity":1,"message":"1053","line":9,"column":2,"nodeType":null,"endLine":9,"endColumn":2,"fix":"1077"},{"ruleId":"843","severity":1,"message":"1078","line":1,"column":43,"nodeType":null,"endLine":1,"endColumn":50,"fix":"1079"},{"ruleId":"843","severity":1,"message":"1080","line":4,"column":3,"nodeType":null,"endLine":4,"endColumn":22,"fix":"1081"},{"ruleId":"843","severity":1,"message":"1082","line":5,"column":1,"nodeType":null,"endLine":5,"endColumn":21,"fix":"1083"},{"ruleId":"857","severity":1,"message":"1084","line":8,"column":11,"nodeType":"855","messageId":"856","endLine":8,"endColumn":27},{"ruleId":"853","severity":1,"message":"1084","line":8,"column":11,"nodeType":"855","messageId":"856","endLine":8,"endColumn":27},{"ruleId":"843","severity":1,"message":"1085","line":9,"column":1,"nodeType":null,"endLine":9,"endColumn":21,"fix":"1086"},{"ruleId":"843","severity":1,"message":"1087","line":10,"column":1,"nodeType":null,"endLine":10,"endColumn":16,"fix":"1088"},{"ruleId":"843","severity":1,"message":"1089","line":11,"column":1,"nodeType":null,"endLine":11,"endColumn":19,"fix":"1090"},{"ruleId":"843","severity":1,"message":"1091","line":12,"column":1,"nodeType":null,"endLine":12,"endColumn":21,"fix":"1092"},{"ruleId":"843","severity":1,"message":"895","line":16,"column":3,"nodeType":null,"endLine":16,"endColumn":5,"fix":"1093"},{"ruleId":"843","severity":1,"message":"1094","line":17,"column":1,"nodeType":null,"endLine":17,"endColumn":23,"fix":"1095"},{"ruleId":"843","severity":1,"message":"1096","line":18,"column":1,"nodeType":null,"endLine":18,"endColumn":63,"fix":"1097"},{"ruleId":"1098","severity":1,"message":"1099","line":18,"column":14,"nodeType":"1012","messageId":"1100","endLine":18,"endColumn":63,"fix":"1101"},{"ruleId":"843","severity":1,"message":"1102","line":19,"column":1,"nodeType":null,"endLine":19,"endColumn":15,"fix":"1103"},{"ruleId":"843","severity":1,"message":"1104","line":20,"column":3,"nodeType":null,"endLine":20,"endColumn":6,"fix":"1105"},{"ruleId":"843","severity":1,"message":"1106","line":21,"column":1,"nodeType":null,"endLine":21,"endColumn":8,"fix":"1107"},{"ruleId":"843","severity":1,"message":"1108","line":22,"column":1,"nodeType":null,"endLine":22,"endColumn":29,"fix":"1109"},{"ruleId":"843","severity":1,"message":"1110","line":23,"column":1,"nodeType":null,"endLine":23,"endColumn":5,"fix":"1111"},{"ruleId":"843","severity":1,"message":"1110","line":24,"column":5,"nodeType":null,"endLine":24,"endColumn":9,"fix":"1112"},{"ruleId":"843","severity":1,"message":"1110","line":25,"column":1,"nodeType":null,"endLine":25,"endColumn":5,"fix":"1113"},{"ruleId":"843","severity":1,"message":"1114","line":26,"column":7,"nodeType":null,"endLine":26,"endColumn":18,"fix":"1115"},{"ruleId":"843","severity":1,"message":"1116","line":27,"column":1,"nodeType":null,"endLine":27,"endColumn":10,"fix":"1117"},{"ruleId":"843","severity":1,"message":"1118","line":28,"column":3,"nodeType":null,"endLine":28,"endColumn":14,"fix":"1119"},{"ruleId":"843","severity":1,"message":"1110","line":29,"column":1,"nodeType":null,"endLine":29,"endColumn":5,"fix":"1120"},{"ruleId":"843","severity":1,"message":"1121","line":30,"column":1,"nodeType":null,"endLine":30,"endColumn":48,"fix":"1122"},{"ruleId":"843","severity":1,"message":"895","line":31,"column":3,"nodeType":null,"endLine":31,"endColumn":5,"fix":"1123"},{"ruleId":"843","severity":1,"message":"859","line":32,"column":2,"nodeType":null,"endLine":32,"endColumn":2,"fix":"1124"},{"ruleId":"843","severity":1,"message":"1125","line":34,"column":36,"nodeType":null,"endLine":34,"endColumn":57,"fix":"1126"},{"ruleId":"843","severity":1,"message":"895","line":37,"column":3,"nodeType":null,"endLine":37,"endColumn":5,"fix":"1127"},{"ruleId":"843","severity":1,"message":"1128","line":38,"column":2,"nodeType":null,"endLine":38,"endColumn":2,"fix":"1129"},{"ruleId":"843","severity":1,"message":"1130","line":1,"column":20,"nodeType":null,"endLine":1,"endColumn":39,"fix":"1131"},{"ruleId":"843","severity":1,"message":"1018","line":3,"column":36,"nodeType":null,"endLine":3,"endColumn":37,"fix":"1132"},{"ruleId":"843","severity":1,"message":"859","line":9,"column":2,"nodeType":null,"endLine":9,"endColumn":2,"fix":"1133"},{"ruleId":"843","severity":1,"message":"1134","line":11,"column":1,"nodeType":null,"endLine":11,"endColumn":9,"fix":"1135"},{"ruleId":"843","severity":1,"message":"1053","line":12,"column":3,"nodeType":null,"endLine":12,"endColumn":3,"fix":"1136"},"no-native-reassign",["1137"],"no-negated-in-lhs",["1138"],["1137"],["1138"],["1137"],["1138"],["1137"],["1138"],["1137"],["1138"],["1137"],["1138"],["1137"],["1138"],["1137"],["1138"],"prettier/prettier","Delete ``",{"range":"1139","text":"1140"},{"range":"1141","text":"1140"},{"range":"1142","text":"1140"},{"range":"1143","text":"1140"},["1137"],["1138"],["1137"],["1138"],"@typescript-eslint/no-unused-vars","'AiFillWechat' is defined but never used.","Identifier","unusedVar","no-unused-vars","'AiOutlineWechat' is defined but never used.","Insert `;`",{"range":"1144","text":"1145"},"Insert `,`",{"range":"1146","text":"1147"},{"range":"1148","text":"1145"},{"range":"1149","text":"1147"},{"range":"1150","text":"1145"},{"range":"1151","text":"1147"},{"range":"1152","text":"1145"},"Insert ``",{"range":"1153","text":"1154"},{"range":"1155","text":"1154"},{"range":"1156","text":"1154"},{"range":"1157","text":"1154"},{"range":"1158","text":"1154"},{"range":"1159","text":"1154"},{"range":"1160","text":"1154"},{"range":"1161","text":"1154"},{"range":"1162","text":"1154"},{"range":"1163","text":"1154"},{"range":"1164","text":"1154"},{"range":"1165","text":"1154"},{"range":"1166","text":"1154"},{"range":"1167","text":"1154"},{"range":"1168","text":"1154"},{"range":"1169","text":"1154"},{"range":"1170","text":"1154"},{"range":"1171","text":"1154"},{"range":"1172","text":"1154"},{"range":"1173","text":"1154"},{"range":"1174","text":"1154"},{"range":"1175","text":"1154"},{"range":"1176","text":"1154"},{"range":"1177","text":"1154"},{"range":"1178","text":"1154"},{"range":"1179","text":"1154"},"Delete ``",{"range":"1180","text":"1140"},{"range":"1181","text":"1140"},{"range":"1182","text":"1140"},{"range":"1183","text":"1140"},"Replace `` with ``",{"range":"1184","text":"1185"},{"range":"1186","text":"1140"},{"range":"1187","text":"1140"},{"range":"1188","text":"1140"},{"range":"1189","text":"1140"},{"range":"1190","text":"1154"},{"range":"1191","text":"1154"},"Replace `` with ``",{"range":"1192","text":"1193"},{"range":"1194","text":"1154"},{"range":"1195","text":"1154"},{"range":"1196","text":"1154"},{"range":"1197","text":"1154"},{"range":"1198","text":"1193"},{"range":"1199","text":"1154"},{"range":"1200","text":"1154"},"'oc' is defined but never used.","Replace `(<span></span>)` with `<span></span>`",{"range":"1201","text":"1202"},"Replace `mount,route}from'navi'` with `mount,route}from\"navi\"`",{"range":"1203","text":"1204"},"Replace `Router}from'react-navi'` with `Router}from\"react-navi\"`",{"range":"1205","text":"1206"},"Replace `'./serviceWorker'` with `\"./serviceWorker\"`",{"range":"1207","text":"1208"},"Replace `\"/\":withAuthentication(` with `\"/\":withAuthentication(`",{"range":"1209","text":"1210"},"Replace `title:` with `title:`",{"range":"1211","text":"1212"},"Replace `view:<ExcalidrawApp/>` with `view:<ExcalidrawApp/>,`",{"range":"1213","text":"1214"},"Delete `)`",{"range":"1215","text":"1140"},"Insert `),`",{"range":"1216","text":"1217"},"Replace `title:` with `title:`",{"range":"1218","text":"1219"},"Replace `view:<LoginPage/>` with `view:<LoginPage/>,`",{"range":"1220","text":"1221"},{"range":"1222","text":"1140"},{"range":"1223","text":"1140"},{"range":"1224","text":"1219"},"Replace `view:<RegisterPage/>` with `view:<RegisterPage/>,`",{"range":"1225","text":"1226"},"Replace `})` with `}),`",{"range":"1227","text":"1228"},{"range":"1229","text":"1145"},"Replace `<Routerroutes={routes}context={{token:localStorage.getItem(BOUNCE_IT_TOKEN_KEY)}}` with `<Routerroutes={routes}context={{token:localStorage.getItem(BOUNCE_IT_TOKEN_KEY)}}`",{"range":"1230","text":"1231"},"Replace `document.getElementById(\"root\")` with `document.getElementById(\"root\"),`",{"range":"1232","text":"1233"},["1137"],["1138"],"'logout' is defined but never used.",{"range":"1234","text":"1140"},{"range":"1235","text":"1140"},{"range":"1236","text":"1140"},{"range":"1237","text":"1140"},{"range":"1238","text":"1140"},{"range":"1239","text":"1140"},{"range":"1240","text":"1140"},{"range":"1241","text":"1140"},{"range":"1242","text":"1140"},{"range":"1243","text":"1154"},{"range":"1244","text":"1154"},{"range":"1245","text":"1154"},{"range":"1246","text":"1140"},{"range":"1247","text":"1140"},{"range":"1248","text":"1140"},{"range":"1249","text":"1140"},"Replace `` with ``",{"range":"1250","text":"1251"},{"range":"1252","text":"1140"},"Replace `` with ``",{"range":"1253","text":"1254"},{"range":"1255","text":"1140"},"Replace `` with ``",{"range":"1256","text":"1257"},{"range":"1258","text":"1140"},"Replace `` with ``",{"range":"1259","text":"1193"},{"range":"1260","text":"1140"},{"range":"1261","text":"1185"},{"range":"1262","text":"1140"},{"range":"1263","text":"1140"},{"range":"1264","text":"1140"},{"range":"1265","text":"1251"},{"range":"1266","text":"1140"},{"range":"1267","text":"1140"},{"range":"1268","text":"1140"},["1137"],["1138"],"Replace `(<divclassName=\"HelpDialog--header\"></div>)` with `<divclassName=\"HelpDialog--header\"></div>`",{"range":"1269","text":"1270"},{"range":"1271","text":"1145"},"Replace `'Startchat'` with `\"Startchat\"`",{"range":"1272","text":"1273"},"Replace `})` with `});`",{"range":"1274","text":"1275"},"'useRef' is defined but never used.","Replace `navigation` with `navigation`",{"range":"1276","text":"1277"},"Replace `''` with `\"\"`",{"range":"1278","text":"1279"},"Replace `''` with `\"\",`",{"range":"1280","text":"1281"},{"range":"1282","text":"1279"},"Replace `(username==''||password=='')` with `(username==\"\"||password==\"\")`",{"range":"1283","text":"1284"},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Replace `'UsernameandPasswordarerequired'` with `\"UsernameandPasswordarerequired\"`",{"range":"1285","text":"1286"},"Replace `error,token}` with `error,token}`",{"range":"1287","text":"1288"},"Delete ``",{"range":"1289","text":"1140"},{"range":"1290","text":"1147"},"Replace `(error)` with `(error)`",{"range":"1291","text":"1292"},"Replace `else` with `else`",{"range":"1293","text":"1294"},"no-else-return","Unnecessary 'else' after 'return'.","BlockStatement",{"range":"1295","text":"1296"},"Insert ``",{"range":"1297","text":"1298"},{"range":"1299","text":"1145"},"no-restricted-syntax","Use 't(...)' instead of literal text in JSX","JSXText","restrictedSyntax","Replace `placeholder=\"username\"value={username}onChange={(e)=>{` with `placeholder=\"username\"value={username}onChange={(e)=>{`",{"range":"1300","text":"1301"},"Insert ``",{"range":"1302","text":"1303"},"Replace `password` with `password,`",{"range":"1304","text":"1305"},"Replace `})}}` with `});}}`",{"range":"1306","text":"1307"},"Replace `placeholder=\"password\"type=\"password\"value={password}onChange={(e)=>{` with `placeholder=\"password\"type=\"password\"value={password}onChange={(e)=>{`",{"range":"1308","text":"1309"},{"range":"1310","text":"1303"},"Replace `password:e.target.value` with `password:e.target.value,`",{"range":"1311","text":"1312"},{"range":"1313","text":"1307"},{"range":"1314","text":"1140"},{"range":"1315","text":"1145"},{"range":"1316","text":"1145"},"Insert ``",{"range":"1317","text":"1318"},{"range":"1319","text":"1279"},{"range":"1320","text":"1281"},{"range":"1321","text":"1301"},"Replace `` with ``",{"range":"1322","text":"1257"},"Replace `password` with `password,`",{"range":"1323","text":"1324"},{"range":"1325","text":"1307"},{"range":"1326","text":"1309"},{"range":"1327","text":"1303"},{"range":"1328","text":"1312"},{"range":"1329","text":"1307"},{"range":"1330","text":"1145"},{"range":"1331","text":"1145"},{"range":"1332","text":"1318"},"Replace `map,Matcher,redirect}from'navi'` with `map,Matcher,redirect}from\"navi\"`",{"range":"1333","text":"1334"},"Replace `token:string` with `token:string;`",{"range":"1335","text":"1336"},{"range":"1337","text":"1298"},"Replace `returnmap((_,context:Context)=>context.token?matcher:redirect('/login'))` with `returnmap((_,context:Context)=>context.token?matcher:redirect(\"/login\"),)`",{"range":"1338","text":"1339"},{"range":"1340","text":"1318"},"Replace `'axios'` with `\"axios\"`",{"range":"1341","text":"1342"},"Replace `username:string,` with `username:string;`",{"range":"1343","text":"1344"},"Replace `password:string` with `password:string;`",{"range":"1345","text":"1346"},"'LoginApiResponse' is defined but never used.","Replace `created:string,` with `created:string;`",{"range":"1347","text":"1348"},"Replace `id:string,` with `id:string;`",{"range":"1349","text":"1350"},"Replace `token:string,` with `token:string;`",{"range":"1351","text":"1336"},"Replace `username:string` with `username:string;`",{"range":"1352","text":"1353"},{"range":"1354","text":"1140"},"Replace `method:'post'` with `method:\"post\"`",{"range":"1355","text":"1356"},"Replace `url:process.env.REACT_APP_BACKEND_V2_POST_URL+'login'` with `url:process.env.REACT_APP_BACKEND_V2_POST_URL+\"login\"`",{"range":"1357","text":"1358"},"prefer-template","Unexpected string concatenation.","unexpectedStringConcatenation",{"range":"1359","text":"1360"},"Replace `data` with `data,`",{"range":"1361","text":"1362"},"Replace `}` with `};`",{"range":"1363","text":"1364"},"Replace `try` with `try`",{"range":"1365","text":"1366"},"Replace `const{data:{token}` with `const{data:{token},`",{"range":"1367","text":"1368"},"Delete ``",{"range":"1369","text":"1140"},{"range":"1370","text":"1140"},{"range":"1371","text":"1140"},"Replace `token` with `token,`",{"range":"1372","text":"1373"},"Replace `}` with `};`",{"range":"1374","text":"1375"},"Replace `}catch(e)` with `}catch(e)`",{"range":"1376","text":"1377"},{"range":"1378","text":"1140"},"Replace `return{error:e.response.data.message}` with `return{error:e.response.data.message};`",{"range":"1379","text":"1380"},{"range":"1381","text":"1140"},{"range":"1382","text":"1145"},"Replace `'bounce_it_token_key'` with `\"bounce_it_token_key\";`",{"range":"1383","text":"1384"},{"range":"1385","text":"1140"},"Insert `;`",{"range":"1386","text":"1387"},"Replace `'styled-components'` with `\"styled-components\"`",{"range":"1388","text":"1389"},{"range":"1390","text":"1140"},{"range":"1391","text":"1145"},"Replace `display:` with `display:`",{"range":"1392","text":"1393"},{"range":"1394","text":"1318"},"no-global-assign","no-unsafe-negation",[618,619],"",[630,631],[636,637],[640,641],[438,438],";",[5788,5788],",",[5790,5790],[6340,6340],[6342,6342],[7135,7135],[7137,7137],[35958,35958],"  ",[35969,35969],[46810,46810],[46834,46834],[46882,46882],[46910,46910],[46934,46934],[46982,46982],[47010,47010],[47058,47058],[47122,47122],[47182,47182],[47230,47230],[47286,47286],[47346,47346],[47386,47386],[47450,47450],[47476,47476],[47518,47518],[47572,47572],[47622,47622],[47633,47633],[47678,47678],[47732,47732],[47743,47743],[47779,47779],[101168,101170],[101229,101231],[102865,102867],[102916,102918],[102933,102945],"          ",[102988,102990],[103014,103016],[103653,103655],[103677,103679],[110715,110715],[110740,110740],[110779,110791],"              ",[110821,110821],[110868,110868],[110939,110939],[110964,110964],[111003,111015],[111045,111045],[111092,111092],[198,226],"<span></span>",[115,140]," mount, route } from \"navi\"",[150,175]," Router } from \"react-navi\"",[208,225],"\"./serviceWorker\"",[529,555],"\"/\": withAuthentication(\n    ",[569,577],"title: ",[591,622],"      view: <ExcalidrawApp />,",[628,629],[634,634],"),\n",[654,668],"    title: ",[694,716],"view: <LoginPage />,",[717,719],[725,727],[750,764],[786,815],"    view: <RegisterPage />,",[816,822],"  }),",[825,825],[903,989],"\n  <Router\n    routes={routes}\n    context={{ token: localStorage.getItem(BOUNCE_IT_TOKEN_KEY) }}\n  ",[993,1028],"  document.getElementById(\"root\"),",[8392,8394],[8412,8414],[8457,8459],[8499,8501],[8551,8553],[8583,8585],[8639,8641],[8667,8669],[8686,8688],[10482,10482],[10503,10503],[10566,10566],[14702,14703],[18298,18300],[18336,18338],[18360,18362],[18391,18399],"      ",[18429,18431],[18433,18443],"        ",[18450,18452],[18479,18493],"            ",[18561,18563],[18565,18581],[18629,18631],[18634,18646],[18657,18659],[18661,18663],[18731,18733],[18742,18750],[18752,18754],[18781,18783],[18790,18792],[220,271],"<div className=\"HelpDialog--header\"></div>",[921,921],[7416,7427],"\"Startchat\"",[7824,7827],"});",[211,223],"navigation",[319,321],"\"\"",[337,339],"\"\",",[384,386],[475,509]," (username == \"\" || password == \"\") ",[526,562],"\"Username and Password are required\"",[603,616]," error, token } ",[649,650],[665,665],[681,688]," (error) ",[738,742]," else ",[405,836],"async (event: React.FormEvent) => {\n    event.preventDefault();\n    if(username == '' || password == ''){\n      setError('Username and Password are required');\n      return false;\n    }\n\n    const {error, token}= await onLogin({\n      username, \n      password\n    });\n\n    if(error){\n      setError(error);\n      return false;\n    }\n      navigation.setContext(token);//refresh token\n      navigation.navigate(\"/\");\n    \n  }",[779,779]," ",[836,836],[942,1000],"\n        placeholder=\"username\"\n        value={username}\n        onChange={(e) => {\n          ",[1017,1017],"    ",[1051,1067],"            password,",[1068,1078],"          });\n        }}\n      ",[1142,1215],"\n        placeholder=\"password\"\n        type=\"password\"\n        value={password}\n        onChange={(e) => {\n          ",[1240,1240],[1250,1282],"            password: e.target.value,",[1283,1293],[1346,1347],[1402,1402],[1404,1404],[1430,1430],"\n",[200,202],[218,220],[315,373],[390,398],[432,440],"    password,",[441,451],[515,588],[613,613],[623,655],[656,666],[731,731],[733,733],[762,762],[8,43]," map, Matcher, redirect } from \"navi\"",[66,83],"  token: string;",[152,152],[154,239],"  return map((_, context: Context) =>\n    context.token ? matcher : redirect(\"/login\"),\n  )",[242,242],[42,49],"\"axios\"",[85,104],"username: string;",[105,125],"  password: string;",[158,178],"  created: string;",[179,194],"  id: string;",[195,213],[214,234],"  username: string;",[294,296],[340,362],"    method: \"post\"",[364,426],"    url: process.env.REACT_APP_BACKEND_V2_POST_URL + \"login\"",[377,426],"`${process.env.REACT_APP_BACKEND_V2_POST_URL}login`",[428,442],"    data,",[445,448],"};",[449,456],"  try ",[458,486],"    const {\n      data: { token },\n    ",[526,530],[552,556],[575,579],[598,609],"token,",[610,619],"    };",[622,633],"} catch (e) ",[635,639],[661,708],"    return { error: e.response.data.message };",[711,713],[716,716],[753,774],"\"bounce_it_token_key\";",[818,820],[871,871],";\n",[19,38],"\"styled-components\"",[76,77],[164,164],[205,213],"  display: ",[221,221]]