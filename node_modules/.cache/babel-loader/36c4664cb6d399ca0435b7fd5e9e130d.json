{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/actions/actionDuplicateSelection.tsx\";\nimport React from \"react\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { clone } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { selectGroupsForSelectedElements, getSelectedGroupForElement, getElementsInGroup } from \"../groups\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { GRID_SIZE } from \"../constants\";\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  perform: (elements, appState) => {\n    // duplicate point if selected while editing multi-point element\n    if (appState.editingLinearElement) {\n      const {\n        activePointIndex,\n        elementId\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (!element || activePointIndex === null) {\n        return false;\n      }\n\n      const {\n        points\n      } = element;\n      const selectedPoint = points[activePointIndex];\n      const nextPoint = points[activePointIndex + 1];\n      mutateElement(element, {\n        points: [...points.slice(0, activePointIndex + 1), nextPoint ? [(selectedPoint[0] + nextPoint[0]) / 2, (selectedPoint[1] + nextPoint[1]) / 2] : [selectedPoint[0] + 30, selectedPoint[1] + 30], ...points.slice(activePointIndex + 1)]\n      });\n      return {\n        appState: { ...appState,\n          editingLinearElement: { ...appState.editingLinearElement,\n            activePointIndex: activePointIndex + 1\n          }\n        },\n        elements,\n        commitToHistory: true\n      };\n    }\n\n    return { ...duplicateElements(elements, appState),\n      commitToHistory: true\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: event => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({\n    elements,\n    appState,\n    updateData\n  }) => /*#__PURE__*/_jsxDEV(ToolButton, {\n    type: \"button\",\n    icon: clone,\n    title: `${t(\"labels.duplicateSelection\")} â€” ${getShortcutKey(\"CtrlOrCmd+D\")}`,\n    \"aria-label\": t(\"labels.duplicateSelection\"),\n    onClick: () => updateData(null),\n    visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 5\n  }, this)\n});\n\nconst duplicateElements = (elements, appState) => {\n  const groupIdMap = new Map();\n  const newElements = [];\n  const oldElements = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = element => {\n    const newElement = duplicateElement(appState.editingGroupId, groupIdMap, element, {\n      x: element.x + GRID_SIZE / 2,\n      y: element.y + GRID_SIZE / 2\n    });\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const finalElements = [];\n  let index = 0;\n\n  while (index < elements.length) {\n    const element = elements[index];\n\n    if (appState.selectedElementIds[element.id]) {\n      if (element.groupIds.length) {\n        const groupId = getSelectedGroupForElement(appState, element); // if group selected, duplicate it atomically\n\n        if (groupId) {\n          const groupElements = getElementsInGroup(elements, groupId);\n          finalElements.push(...groupElements, ...groupElements.map(element => duplicateAndOffsetElement(element)));\n          index = index + groupElements.length;\n          continue;\n        }\n      }\n\n      finalElements.push(element, duplicateAndOffsetElement(element));\n    } else {\n      finalElements.push(element);\n    }\n\n    index++;\n  }\n\n  fixBindingsAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements({ ...appState,\n      selectedGroupIds: {},\n      selectedElementIds: newElements.reduce((acc, element) => {\n        acc[element.id] = true;\n        return acc;\n      }, {})\n    }, getNonDeletedElements(finalElements))\n  };\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/actions/actionDuplicateSelection.tsx"],"names":["React","KEYS","register","duplicateElement","getNonDeletedElements","isSomeElementSelected","ToolButton","clone","t","getShortcutKey","LinearElementEditor","mutateElement","selectGroupsForSelectedElements","getSelectedGroupForElement","getElementsInGroup","fixBindingsAfterDuplication","GRID_SIZE","actionDuplicateSelection","name","perform","elements","appState","editingLinearElement","activePointIndex","elementId","element","getElement","points","selectedPoint","nextPoint","slice","commitToHistory","duplicateElements","contextItemLabel","keyTest","event","CTRL_OR_CMD","key","D","PanelComponent","updateData","groupIdMap","Map","newElements","oldElements","oldIdToDuplicatedId","duplicateAndOffsetElement","newElement","editingGroupId","x","y","set","id","push","finalElements","index","length","selectedElementIds","groupIds","groupId","groupElements","map","selectedGroupIds","reduce","acc"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { clone } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  perform: (elements, appState) => {\n    // duplicate point if selected while editing multi-point element\n    if (appState.editingLinearElement) {\n      const { activePointIndex, elementId } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element || activePointIndex === null) {\n        return false;\n      }\n      const { points } = element;\n      const selectedPoint = points[activePointIndex];\n      const nextPoint = points[activePointIndex + 1];\n      mutateElement(element, {\n        points: [\n          ...points.slice(0, activePointIndex + 1),\n          nextPoint\n            ? [\n                (selectedPoint[0] + nextPoint[0]) / 2,\n                (selectedPoint[1] + nextPoint[1]) / 2,\n              ]\n            : [selectedPoint[0] + 30, selectedPoint[1] + 30],\n          ...points.slice(activePointIndex + 1),\n        ],\n      });\n      return {\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            activePointIndex: activePointIndex + 1,\n          },\n        },\n        elements,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={clone}\n      title={`${t(\"labels.duplicateSelection\")} â€” ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const finalElements: ExcalidrawElement[] = [];\n\n  let index = 0;\n  while (index < elements.length) {\n    const element = elements[index];\n    if (appState.selectedElementIds[element.id]) {\n      if (element.groupIds.length) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        // if group selected, duplicate it atomically\n        if (groupId) {\n          const groupElements = getElementsInGroup(elements, groupId);\n          finalElements.push(\n            ...groupElements,\n            ...groupElements.map((element) =>\n              duplicateAndOffsetElement(element),\n            ),\n          );\n          index = index + groupElements.length;\n          continue;\n        }\n      }\n      finalElements.push(element, duplicateAndOffsetElement(element));\n    } else {\n      finalElements.push(element);\n    }\n    index++;\n  }\n\n  fixBindingsAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: newElements.reduce((acc, element) => {\n          acc[element.id] = true;\n          return acc;\n        }, {} as any),\n      },\n      getNonDeletedElements(finalElements),\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}