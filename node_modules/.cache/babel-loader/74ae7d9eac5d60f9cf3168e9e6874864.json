{"ast":null,"code":"import rough from \"roughjs/bin/rough\";\nimport oc from \"open-color\";\nimport { newTextElement } from \"../element\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { normalizeScroll } from \"./scroll\";\nimport { t } from \"../i18n\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_VERTICAL_ALIGN } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\nconst WATERMARK_HEIGHT = 16;\nexport const exportToCanvas = (elements, appState, {\n  exportBackground,\n  exportPadding = 10,\n  viewBackgroundColor,\n  scale = 1,\n  shouldAddWatermark\n}, createCanvas = (width, height) => {\n  const tempCanvas = document.createElement(\"canvas\");\n  tempCanvas.width = width * scale;\n  tempCanvas.height = height * scale;\n  return tempCanvas;\n}) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n  const [minX, minY, width, height] = getCanvasSize(sceneElements, exportPadding, shouldAddWatermark);\n  const tempCanvas = createCanvas(width, height);\n  renderScene(sceneElements, appState, null, scale, rough.canvas(tempCanvas), tempCanvas, {\n    viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n    scrollX: normalizeScroll(-minX + exportPadding),\n    scrollY: normalizeScroll(-minY + exportPadding),\n    zoom: getDefaultAppState().zoom,\n    remotePointerViewportCoords: {},\n    remoteSelectedElementIds: {},\n    shouldCacheIgnoreZoom: false,\n    remotePointerUsernames: {}\n  }, {\n    renderScrollbars: false,\n    renderSelection: false,\n    renderOptimizations: false,\n    renderGrid: false\n  });\n  return tempCanvas;\n};\nexport const exportToSvg = (elements, {\n  exportBackground,\n  exportPadding = 10,\n  viewBackgroundColor,\n  scale = 1,\n  shouldAddWatermark,\n  metadata = \"\"\n}) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n  const [minX, minY, width, height] = getCanvasSize(sceneElements, exportPadding, shouldAddWatermark); // initialze SVG root\n\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * scale}`);\n  svgRoot.setAttribute(\"height\", `${height * scale}`);\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/FG_Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `; // render background rect\n\n  if (exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(sceneElements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding\n  });\n  return svgRoot;\n};\n\nconst getElementsAndWatermark = (elements, shouldAddWatermark) => {\n  let _elements = [...elements];\n\n  if (shouldAddWatermark) {\n    const [,, maxX, maxY] = getCommonBounds(elements);\n    _elements = [..._elements, getWatermarkElement(maxX, maxY)];\n  }\n\n  return _elements;\n};\n\nconst getWatermarkElement = (maxX, maxY) => {\n  return newTextElement({\n    text: t(\"labels.madeWithExcalidraw\"),\n    fontSize: WATERMARK_HEIGHT,\n    fontFamily: DEFAULT_FONT_FAMILY,\n    textAlign: \"right\",\n    verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    x: maxX,\n    y: maxY + WATERMARK_HEIGHT,\n    strokeColor: oc.gray[5],\n    backgroundColor: \"transparent\",\n    fillStyle: \"hachure\",\n    strokeWidth: 1,\n    strokeStyle: \"solid\",\n    roughness: 1,\n    opacity: 100,\n    strokeSharpness: \"sharp\"\n  });\n}; // calculate smallest area to fit the contents in\n\n\nconst getCanvasSize = (elements, exportPadding, shouldAddWatermark) => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height = distance(minY, maxY) + exportPadding + (shouldAddWatermark ? 0 : exportPadding);\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (elements, exportPadding, shouldAddWatermark, scale) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n  const [,, width, height] = getCanvasSize(sceneElements, exportPadding, shouldAddWatermark).map(dimension => Math.trunc(dimension * scale));\n  return [width, height];\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/scene/export.ts"],"names":["rough","oc","newTextElement","getCommonBounds","renderScene","renderSceneToSvg","distance","SVG_NS","normalizeScroll","t","DEFAULT_FONT_FAMILY","DEFAULT_VERTICAL_ALIGN","getDefaultAppState","SVG_EXPORT_TAG","WATERMARK_HEIGHT","exportToCanvas","elements","appState","exportBackground","exportPadding","viewBackgroundColor","scale","shouldAddWatermark","createCanvas","width","height","tempCanvas","document","createElement","sceneElements","getElementsAndWatermark","minX","minY","getCanvasSize","canvas","scrollX","scrollY","zoom","remotePointerViewportCoords","remoteSelectedElementIds","shouldCacheIgnoreZoom","remotePointerUsernames","renderScrollbars","renderSelection","renderOptimizations","renderGrid","exportToSvg","metadata","svgRoot","createElementNS","setAttribute","innerHTML","rect","ownerDocument","appendChild","rsvg","svg","offsetX","offsetY","_elements","maxX","maxY","getWatermarkElement","text","fontSize","fontFamily","textAlign","verticalAlign","x","y","strokeColor","gray","backgroundColor","fillStyle","strokeWidth","strokeStyle","roughness","opacity","strokeSharpness","getExportSize","map","dimension","Math","trunc"],"mappings":"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","sourcesContent":["import rough from \"roughjs/bin/rough\";\nimport oc from \"open-color\";\nimport { newTextElement } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { normalizeScroll } from \"./scroll\";\nimport { AppState } from \"../types\";\nimport { t } from \"../i18n\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_VERTICAL_ALIGN } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\nconst WATERMARK_HEIGHT = 16;\n\nexport const exportToCanvas = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n  },\n  createCanvas: (width: number, height: number) => HTMLCanvasElement = (\n    width,\n    height,\n  ) => {\n    const tempCanvas = document.createElement(\"canvas\");\n    tempCanvas.width = width * scale;\n    tempCanvas.height = height * scale;\n    return tempCanvas;\n  },\n) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  const tempCanvas = createCanvas(width, height);\n\n  renderScene(\n    sceneElements,\n    appState,\n    null,\n    scale,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: normalizeScroll(-minX + exportPadding),\n      scrollY: normalizeScroll(-minY + exportPadding),\n      zoom: getDefaultAppState().zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: false,\n      renderGrid: false,\n    },\n  );\n\n  return tempCanvas;\n};\n\nexport const exportToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n    metadata = \"\",\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n    metadata?: string;\n  },\n): SVGSVGElement => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * scale}`);\n  svgRoot.setAttribute(\"height\", `${height * scale}`);\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/FG_Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render background rect\n  if (exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(sceneElements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\nconst getElementsAndWatermark = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  shouldAddWatermark: boolean,\n): readonly NonDeletedExcalidrawElement[] => {\n  let _elements = [...elements];\n\n  if (shouldAddWatermark) {\n    const [, , maxX, maxY] = getCommonBounds(elements);\n    _elements = [..._elements, getWatermarkElement(maxX, maxY)];\n  }\n\n  return _elements;\n};\n\nconst getWatermarkElement = (maxX: number, maxY: number) => {\n  return newTextElement({\n    text: t(\"labels.madeWithExcalidraw\"),\n    fontSize: WATERMARK_HEIGHT,\n    fontFamily: DEFAULT_FONT_FAMILY,\n    textAlign: \"right\",\n    verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    x: maxX,\n    y: maxY + WATERMARK_HEIGHT,\n    strokeColor: oc.gray[5],\n    backgroundColor: \"transparent\",\n    fillStyle: \"hachure\",\n    strokeWidth: 1,\n    strokeStyle: \"solid\",\n    roughness: 1,\n    opacity: 100,\n    strokeSharpness: \"sharp\",\n  });\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height =\n    distance(minY, maxY) +\n    exportPadding +\n    (shouldAddWatermark ? 0 : exportPadding);\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n  scale: number,\n): [number, number] => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [, , width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  ).map((dimension) => Math.trunc(dimension * scale));\n\n  return [width, height];\n};\n"]},"metadata":{},"sourceType":"module"}