{"ast":null,"code":"import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\nimport { isPathALoop, isPointInPolygon, rotate } from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\nimport { getElementAbsoluteCoords, getCurvePathOps } from \"./bounds\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nconst isElementDraggableFromInside = element => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n\n  if (element.type === \"line\" || element.type === \"draw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside;\n};\n\nexport const hitTest = (element, appState, x, y) => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\nexport const isHittingElementBoundingBoxWithoutHittingElement = (element, appState, x, y) => {\n  const threshold = 10 / appState.zoom.value;\n  return !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) && isPointHittingElementBoundingBox(element, [x, y], threshold);\n};\n\nconst isHittingElementNotConsideringBoundingBox = (element, appState, point) => {\n  const threshold = 10 / appState.zoom.value;\n  const check = element.type === \"text\" ? isStrictlyInside : isElementDraggableFromInside(element) ? isInsideCheck : isNearCheck;\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check\n  });\n};\n\nconst isElementSelected = (appState, element) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (element, [x, y], threshold) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2; // reverse rotate to take element's angle into account.\n\n  const [rotatedX, rotatedY] = rotate(x, y, elementCenterX, elementCenterY, -element.angle);\n  return rotatedX > x1 - threshold && rotatedX < x2 + threshold && rotatedY > y1 - threshold && rotatedY < y2 + threshold;\n};\n\nexport const bindingBorderTest = (element, {\n  x,\n  y\n}) => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point = [x, y];\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check\n  });\n};\nexport const maxBindingGap = (element, elementWidth, elementHeight) => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight); // We make the bindable boundary bigger for bigger elements\n\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\nconst hitTestPointAgainstElement = args => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n\n    case \"arrow\":\n    case \"line\":\n    case \"draw\":\n      return hitTestLinear(args);\n\n    case \"selection\":\n      console.warn(\"This should not happen, we need to investigate why it does.\");\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (element, point) => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance, threshold) => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance, threshold) => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance, threshold) => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance, threshold) => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)), GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)));\n};\n\nconst distanceToDiamond = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (element, point) => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel); // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n\n  let tx = 0.707;\n  let ty = 0.707;\n  const a = hwidth;\n  const b = hheight; // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n\n  [0, 1, 2, 3].forEach(_ => {\n    const xx = a * tx;\n    const yy = b * ty;\n    const ex = (a * a - b * b) * tx ** 3 / a;\n    const ey = (b * b - a * a) * ty ** 3 / b;\n    const rx = xx - ex;\n    const ry = yy - ey;\n    const qx = px - ex;\n    const qy = py - ey;\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n    tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));\n    ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n  const closestPoint = GA.point(a * tx, b * ty);\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestLinear = args => {\n  const {\n    element,\n    threshold\n  } = args;\n\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(args.element, args.point);\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n\n  if (!isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) || !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)) {\n    return false;\n  }\n\n  const [relX, relY] = GAPoint.toTuple(point);\n  const shape = getShapeForElement(element);\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some(subshape => hitTestCurveInside(subshape, relX, relY, element.strokeSharpness));\n\n    if (hit) {\n      return true;\n    }\n  } // hit test all \"subshapes\" of the linear element\n\n\n  return shape.some(subshape => hitTestRoughShape(subshape, relX, relY, threshold));\n}; // Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\n\n\nconst pointRelativeToElement = (element, pointTuple) => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords); // GA has angle orientation opposite to `rotate`\n\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n}; // Returns point in absolute coordinates\n\n\nexport const pointInAbsoluteCoords = (element, point) => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = element => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords); // GA has angle orientation opposite to `rotate`\n\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(GATransform.translation(GADirection.from(center)));\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]) => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n}; // The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\n\n\nexport const determineFocusDistance = (element, a, b) => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\nexport const determineFocusPoint = (element, focus, adjecentPoint) => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(relateToCenter, GAPoint.from(adjecentPoint));\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n}; // Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\n\nexport const intersectElementWithLine = (element, a, b, // If given, the element is inflated by this value\ngap = 0) => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(element, line, aRel, gap);\n  return intersections.map(point => GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)));\n};\n\nconst getSortedElementLineIntersections = (element, line, nearPoint, gap = 0) => {\n  let intersections;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners.flatMap((point, i) => {\n        const edge = [point, corners[(i + 1) % 4]];\n        return intersectSegment(line, offsetSegment(edge, gap));\n      }).concat(corners.flatMap(point => getCircleIntersections(point, gap, line)));\n      break;\n\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n\n  const sortedIntersections = intersections.sort((i1, i2) => GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint));\n  return [sortedIntersections[0], sortedIntersections[sortedIntersections.length - 1]];\n};\n\nconst getCorners = (element, scale = 1) => {\n  const hx = scale * element.width / 2;\n  const hy = scale * element.height / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return [GA.point(hx, hy), GA.point(hx, -hy), GA.point(-hx, -hy), GA.point(-hx, hy)];\n\n    case \"diamond\":\n      return [GA.point(0, hy), GA.point(hx, 0), GA.point(0, -hy), GA.point(-hx, 0)];\n  }\n}; // Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\n\n\nconst intersectSegment = (line, segment) => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (segment, distance) => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(GADirection.fromTo(a, b), distance);\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (element, gap, line) => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [GA.point((xn + a * b * n * discrRoot) / squares, (yn - a * b * m * discrRoot) / squares), GA.point((xn - a * b * n * discrRoot) / squares, (yn + a * b * m * discrRoot) / squares)];\n};\n\nexport const getCircleIntersections = (center, radius, line) => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n  return [GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares), GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares)];\n}; // The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\n\nexport const findFocusPointForEllipse = (ellipse, relativeDistance, point) => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = ellipse.width * relativeDistanceAbs / 2;\n  const b = ellipse.height * relativeDistanceAbs / 2;\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point); // The calculation below can't handle py = 0\n\n  const py = pyo === 0 ? 0.0001 : pyo;\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2; // Tangent mx + ny + 1 = 0\n\n  const m = (-px * b ** 2 + orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) / squares;\n  const n = (-m * px - 1) / py;\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\nexport const findFocusPointForRectangulars = (element, relativeDistance, point) => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n  let maxDistance = 0;\n  let tangentPoint = null;\n  corners.forEach(corner => {\n    const distance = orientation * GALine.through(point, corner)[1];\n\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint;\n};\n\nconst pointInBezierEquation = (p0, p1, p2, p3, [mx, my], lineThreshold) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3); // go through t in increments of 0.01\n\n\n  let t = 0;\n\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (drawable, x, y, sharpness) => {\n  const ops = getCurvePathOps(drawable);\n  const points = [];\n  let odd = false; // select one line out of double lines\n\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n\n    const polygonPoints = pointsOnBezierCurves(points, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n\n  return false;\n};\n\nconst hitTestRoughShape = (drawable, x, y, lineThreshold) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable); // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n\n  let currentP = [0, 0];\n  return ops.some(({\n    op,\n    data\n  }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3; // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n\n      const retVal = pointInBezierEquation(p0, p1, p2, p3, [x, y], lineThreshold); // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n\n      return retVal;\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return false;\n  });\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/collision.ts"],"names":["GA","GAPoint","GADirection","GALine","GATransform","isPathALoop","isPointInPolygon","rotate","pointsOnBezierCurves","getElementAbsoluteCoords","getCurvePathOps","getShapeForElement","isElementDraggableFromInside","element","type","isDraggableFromInside","backgroundColor","points","hitTest","appState","x","y","threshold","zoom","value","point","isElementSelected","isPointHittingElementBoundingBox","isHittingElementNotConsideringBoundingBox","isHittingElementBoundingBoxWithoutHittingElement","check","isStrictlyInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","selectedElementIds","id","x1","y1","x2","y2","elementCenterX","elementCenterY","rotatedX","rotatedY","angle","bindingBorderTest","maxBindingGap","width","height","isOutsideCheck","elementWidth","elementHeight","shapeRatio","Math","sqrt","smallerDimension","min","max","args","distance","distanceToBindableElement","hitTestLinear","console","warn","distanceToRectangle","distanceToDiamond","distanceToEllipse","abs","pointRel","hwidth","hheight","pointRelativeToElement","distanceToLine","equation","side","tangent","ellipseParamsForTest","sign","px","py","toTuple","tx","ty","a","b","forEach","_","xx","yy","ex","ey","rx","ry","qx","qy","r","hypot","q","t","closestPoint","orthogonalThrough","pointAbs","side1","side2","relX","relY","shape","hit","some","subshape","hitTestCurveInside","strokeSharpness","hitTestRoughShape","pointTuple","from","elementCoords","center","coordsCenter","rotation","pointRotated","apply","pointRelToCenter","sub","pointRelToCenterAbs","elementPos","offset","pointRelToPos","ax","ay","bx","by","halfWidth","halfHeight","pointInAbsoluteCoords","cx","cy","relativizationToElementCenter","translate","reverse","translation","compose","determineFocusDistance","relateToCenter","aRel","bRel","line","through","n","m","c","mabs","nabs","determineFocusPoint","focus","adjecentPoint","adjecentPointRel","reverseRelateToCenter","findFocusPointForRectangulars","findFocusPointForEllipse","intersectElementWithLine","gap","intersections","getSortedElementLineIntersections","map","nearPoint","corners","getCorners","flatMap","i","edge","intersectSegment","offsetSegment","concat","getCircleIntersections","getEllipseIntersections","length","sortedIntersections","sort","i1","i2","scale","hx","hy","segment","aDist","bDist","intersect","translationOrthogonal","fromTo","squares","discr","discrRoot","xn","yn","radius","ellipse","relativeDistance","relativeDistanceAbs","orientation","pyo","maxDistance","tangentPoint","corner","pointInBezierEquation","p0","p1","p2","p3","mx","my","lineThreshold","idx","pow","diff","drawable","sharpness","ops","odd","operation","op","push","data","polygonPoints","currentP","retVal"],"mappings":"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","sourcesContent":["import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport { isPathALoop, isPointInPolygon, rotate } from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords, getCurvePathOps, Bounds } from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n  if (element.type === \"line\" || element.type === \"draw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside;\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) &&\n    isPointHittingElementBoundingBox(element, [x, y], threshold)\n  );\n};\n\nconst isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  const check =\n    element.type === \"text\"\n      ? isStrictlyInside\n      : isElementDraggableFromInside(element)\n      ? isInsideCheck\n      : isNearCheck;\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"arrow\":\n    case \"line\":\n    case \"draw\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element: ExcalidrawRectangleElement | ExcalidrawTextElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(subshape, relX, relY, element.strokeSharpness),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]: Bounds): GA.Point => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  const n = (-m * px - 1) / py;\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}