{"ast":null,"code":"import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n  const segments = parsePath(path);\n  const normalized = normalize(absolutize(segments));\n  const sets = [];\n  let currentPoints = [];\n  let start = [0, 0];\n  let pendingCurve = [];\n\n  const appendPendingCurve = () => {\n    if (pendingCurve.length >= 4) {\n      currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n    }\n\n    pendingCurve = [];\n  };\n\n  const appendPendingPoints = () => {\n    appendPendingCurve();\n\n    if (currentPoints.length) {\n      sets.push(currentPoints);\n      currentPoints = [];\n    }\n  };\n\n  for (const {\n    key,\n    data\n  } of normalized) {\n    switch (key) {\n      case 'M':\n        appendPendingPoints();\n        start = [data[0], data[1]];\n        currentPoints.push(start);\n        break;\n\n      case 'L':\n        appendPendingCurve();\n        currentPoints.push([data[0], data[1]]);\n        break;\n\n      case 'C':\n        if (!pendingCurve.length) {\n          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n          pendingCurve.push([lastPoint[0], lastPoint[1]]);\n        }\n\n        pendingCurve.push([data[0], data[1]]);\n        pendingCurve.push([data[2], data[3]]);\n        pendingCurve.push([data[4], data[5]]);\n        break;\n\n      case 'Z':\n        appendPendingCurve();\n        currentPoints.push([start[0], start[1]]);\n        break;\n    }\n  }\n\n  appendPendingPoints();\n\n  if (!distance) {\n    return sets;\n  }\n\n  const out = [];\n\n  for (const set of sets) {\n    const simplifiedSet = simplify(set, distance);\n\n    if (simplifiedSet.length) {\n      out.push(simplifiedSet);\n    }\n  }\n\n  return out;\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/points-on-path/lib/index.js"],"names":["pointsOnBezierCurves","simplify","parsePath","absolutize","normalize","pointsOnPath","path","tolerance","distance","segments","normalized","sets","currentPoints","start","pendingCurve","appendPendingCurve","length","push","appendPendingPoints","key","data","lastPoint","out","set","simplifiedSet"],"mappings":"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","sourcesContent":["import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n"]},"metadata":{},"sourceType":"module"}