{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/actions/actionDeleteSelected.tsx\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport React from \"react\";\nimport { trash } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst deleteSelectedElements = (elements, appState) => {\n  return {\n    elements: elements.map(el => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, {\n          isDeleted: true\n        });\n      }\n\n      return el;\n    }),\n    appState: { ...appState,\n      selectedElementIds: {}\n    }\n  };\n};\n\nconst handleGroupEditingState = (appState, elements) => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(getNonDeletedElements(elements), appState.editingGroupId);\n\n    if (siblingElements.length) {\n      return { ...appState,\n        selectedElementIds: {\n          [siblingElements[0].id]: true\n        }\n      };\n    }\n  }\n\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        activePointIndex,\n        startBindingElement,\n        endBindingElement\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (!element) {\n        return false;\n      }\n\n      if ( // case: no point selected → delete whole element\n      activePointIndex == null || activePointIndex === -1 || // case: deleting last remaining point\n      element.points.length < 2) {\n        const nextElements = elements.filter(el => el.id !== element.id);\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n        return {\n          elements: nextElements,\n          appState: { ...nextAppState,\n            editingLinearElement: null\n          },\n          commitToHistory: false\n        };\n      } // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n\n\n      const binding = {\n        startBindingElement: activePointIndex === 0 ? null : startBindingElement,\n        endBindingElement: activePointIndex === element.points.length - 1 ? null : endBindingElement\n      };\n      LinearElementEditor.movePoint(element, activePointIndex, \"delete\");\n      return {\n        elements,\n        appState: { ...appState,\n          editingLinearElement: { ...appState.editingLinearElement,\n            ...binding,\n            activePointIndex: activePointIndex > 0 ? activePointIndex - 1 : 0\n          }\n        },\n        commitToHistory: true\n      };\n    }\n\n    let {\n      elements: nextElements,\n      appState: nextAppState\n    } = deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(nextElements, elements.filter(({\n      id\n    }) => appState.selectedElementIds[id]));\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n    return {\n      elements: nextElements,\n      appState: { ...nextAppState,\n        elementType: \"selection\",\n        multiElement: null\n      },\n      commitToHistory: isSomeElementSelected(getNonDeletedElements(elements), appState)\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  contextMenuOrder: 999999,\n  keyTest: event => event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE,\n  PanelComponent: ({\n    elements,\n    appState,\n    updateData\n  }) => /*#__PURE__*/_jsxDEV(ToolButton, {\n    type: \"button\",\n    icon: trash,\n    title: t(\"labels.delete\"),\n    \"aria-label\": t(\"labels.delete\"),\n    onClick: () => updateData(null),\n    visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 142,\n    columnNumber: 5\n  }, this)\n});","map":{"version":3,"sources":["/var/www/html/excalidraw/src/actions/actionDeleteSelected.tsx"],"names":["isSomeElementSelected","KEYS","ToolButton","React","trash","t","register","getNonDeletedElements","newElementWith","getElementsInGroup","LinearElementEditor","fixBindingsAfterDeletion","deleteSelectedElements","elements","appState","map","el","selectedElementIds","id","isDeleted","handleGroupEditingState","editingGroupId","siblingElements","length","actionDeleteSelected","name","perform","editingLinearElement","elementId","activePointIndex","startBindingElement","endBindingElement","element","getElement","points","nextElements","filter","nextAppState","commitToHistory","binding","movePoint","elementType","multiElement","contextItemLabel","contextMenuOrder","keyTest","event","key","BACKSPACE","DELETE","PanelComponent","updateData"],"mappings":"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","sourcesContent":["import { isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport React from \"react\";\nimport { trash } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    elements: elements.map((el) => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, { isDeleted: true });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {},\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        activePointIndex,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      if (\n        // case: no point selected → delete whole element\n        activePointIndex == null ||\n        activePointIndex === -1 ||\n        // case: deleting last remaining point\n        element.points.length < 2\n      ) {\n        const nextElements = elements.filter((el) => el.id !== element.id);\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          commitToHistory: false,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement:\n          activePointIndex === 0 ? null : startBindingElement,\n        endBindingElement:\n          activePointIndex === element.points.length - 1\n            ? null\n            : endBindingElement,\n      };\n\n      LinearElementEditor.movePoint(element, activePointIndex, \"delete\");\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            activePointIndex: activePointIndex > 0 ? activePointIndex - 1 : 0,\n          },\n        },\n        commitToHistory: true,\n      };\n    }\n\n    let {\n      elements: nextElements,\n      appState: nextAppState,\n    } = deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(\n      nextElements,\n      elements.filter(({ id }) => appState.selectedElementIds[id]),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        elementType: \"selection\",\n        multiElement: null,\n      },\n      commitToHistory: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      ),\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  contextMenuOrder: 999999,\n  keyTest: (event) => event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n"]},"metadata":{},"sourceType":"module"}