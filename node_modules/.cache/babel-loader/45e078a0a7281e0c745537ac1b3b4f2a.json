{"ast":null,"code":"import { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nexport const dragSelectedElements = (pointerDownState, selectedElements, pointerX, pointerY, scene, lockDirection = false, distanceX = 0, distanceY = 0) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = {\n    x: pointerX - x1,\n    y: pointerY - y1\n  };\n  selectedElements.forEach(element => {\n    let x;\n    let y;\n\n    if (lockDirection) {\n      const lockX = lockDirection && distanceX < distanceY;\n      const lockY = lockDirection && distanceX > distanceY;\n      const original = pointerDownState.originalElements.get(element.id);\n      x = lockX && original ? original.x : element.x + offset.x;\n      y = lockY && original ? original.y : element.y + offset.y;\n    } else {\n      x = element.x + offset.x;\n      y = element.y + offset.y;\n    }\n\n    mutateElement(element, {\n      x,\n      y\n    });\n    updateBoundElements(element, {\n      simultaneouslyUpdated: selectedElements\n    });\n  });\n};\nexport const getDragOffsetXY = (selectedElements, x, y) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\nexport const dragNewElement = (draggingElement, elementType, originX, originY, x, y, width, height, isResizeWithSidesSameLength, isResizeCenterPoint) => {\n  if (isResizeWithSidesSameLength) {\n    ({\n      width,\n      height\n    } = getPerfectElementSize(elementType, width, y < originY ? -height : height));\n\n    if (height < 0) {\n      height = -height;\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (isResizeCenterPoint) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height\n    });\n  }\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/dragElements.ts"],"names":["updateBoundElements","getCommonBounds","mutateElement","getPerfectElementSize","dragSelectedElements","pointerDownState","selectedElements","pointerX","pointerY","scene","lockDirection","distanceX","distanceY","x1","y1","offset","x","y","forEach","element","lockX","lockY","original","originalElements","get","id","simultaneouslyUpdated","getDragOffsetXY","dragNewElement","draggingElement","elementType","originX","originY","width","height","isResizeWithSidesSameLength","isResizeCenterPoint","newX","newY"],"mappings":"AACA,SAASA,mBAAT,QAAoC,WAApC;AACA,SAASC,eAAT,QAAgC,UAAhC;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,qBAAT,QAAsC,eAAtC;AAKA,OAAO,MAAMC,oBAAoB,GAAG,CAClCC,gBADkC,EAElCC,gBAFkC,EAGlCC,QAHkC,EAIlCC,QAJkC,EAKlCC,KALkC,EAMlCC,aAAsB,GAAG,KANS,EAOlCC,SAAiB,GAAG,CAPc,EAQlCC,SAAiB,GAAG,CARc,KAS/B;AACH,QAAM,CAACC,EAAD,EAAKC,EAAL,IAAWb,eAAe,CAACK,gBAAD,CAAhC;AACA,QAAMS,MAAM,GAAG;AAAEC,IAAAA,CAAC,EAAET,QAAQ,GAAGM,EAAhB;AAAoBI,IAAAA,CAAC,EAAET,QAAQ,GAAGM;AAAlC,GAAf;AACAR,EAAAA,gBAAgB,CAACY,OAAjB,CAA0BC,OAAD,IAAa;AACpC,QAAIH,CAAJ;AACA,QAAIC,CAAJ;;AACA,QAAIP,aAAJ,EAAmB;AACjB,YAAMU,KAAK,GAAGV,aAAa,IAAIC,SAAS,GAAGC,SAA3C;AACA,YAAMS,KAAK,GAAGX,aAAa,IAAIC,SAAS,GAAGC,SAA3C;AACA,YAAMU,QAAQ,GAAGjB,gBAAgB,CAACkB,gBAAjB,CAAkCC,GAAlC,CAAsCL,OAAO,CAACM,EAA9C,CAAjB;AACAT,MAAAA,CAAC,GAAGI,KAAK,IAAIE,QAAT,GAAoBA,QAAQ,CAACN,CAA7B,GAAiCG,OAAO,CAACH,CAAR,GAAYD,MAAM,CAACC,CAAxD;AACAC,MAAAA,CAAC,GAAGI,KAAK,IAAIC,QAAT,GAAoBA,QAAQ,CAACL,CAA7B,GAAiCE,OAAO,CAACF,CAAR,GAAYF,MAAM,CAACE,CAAxD;AACD,KAND,MAMO;AACLD,MAAAA,CAAC,GAAGG,OAAO,CAACH,CAAR,GAAYD,MAAM,CAACC,CAAvB;AACAC,MAAAA,CAAC,GAAGE,OAAO,CAACF,CAAR,GAAYF,MAAM,CAACE,CAAvB;AACD;;AAEDf,IAAAA,aAAa,CAACiB,OAAD,EAAU;AACrBH,MAAAA,CADqB;AAErBC,MAAAA;AAFqB,KAAV,CAAb;AAKAjB,IAAAA,mBAAmB,CAACmB,OAAD,EAAU;AAC3BO,MAAAA,qBAAqB,EAAEpB;AADI,KAAV,CAAnB;AAGD,GAtBD;AAuBD,CAnCM;AAqCP,OAAO,MAAMqB,eAAe,GAAG,CAC7BrB,gBAD6B,EAE7BU,CAF6B,EAG7BC,CAH6B,KAIR;AACrB,QAAM,CAACJ,EAAD,EAAKC,EAAL,IAAWb,eAAe,CAACK,gBAAD,CAAhC;AACA,SAAO,CAACU,CAAC,GAAGH,EAAL,EAASI,CAAC,GAAGH,EAAb,CAAP;AACD,CAPM;AASP,OAAO,MAAMc,cAAc,GAAG,CAC5BC,eAD4B,EAE5BC,WAF4B,EAG5BC,OAH4B,EAI5BC,OAJ4B,EAK5BhB,CAL4B,EAM5BC,CAN4B,EAO5BgB,KAP4B,EAQ5BC,MAR4B,EAS5BC,2BAT4B,EAU5BC,mBAV4B,KAWzB;AACH,MAAID,2BAAJ,EAAiC;AAC/B,KAAC;AAAEF,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAoB/B,qBAAqB,CACxC2B,WADwC,EAExCG,KAFwC,EAGxChB,CAAC,GAAGe,OAAJ,GAAc,CAACE,MAAf,GAAwBA,MAHgB,CAA1C;;AAMA,QAAIA,MAAM,GAAG,CAAb,EAAgB;AACdA,MAAAA,MAAM,GAAG,CAACA,MAAV;AACD;AACF;;AAED,MAAIG,IAAI,GAAGrB,CAAC,GAAGe,OAAJ,GAAcA,OAAO,GAAGE,KAAxB,GAAgCF,OAA3C;AACA,MAAIO,IAAI,GAAGrB,CAAC,GAAGe,OAAJ,GAAcA,OAAO,GAAGE,MAAxB,GAAiCF,OAA5C;;AAEA,MAAII,mBAAJ,EAAyB;AACvBH,IAAAA,KAAK,IAAIA,KAAT;AACAC,IAAAA,MAAM,IAAIA,MAAV;AACAG,IAAAA,IAAI,GAAGN,OAAO,GAAGE,KAAK,GAAG,CAAzB;AACAK,IAAAA,IAAI,GAAGN,OAAO,GAAGE,MAAM,GAAG,CAA1B;AACD;;AAED,MAAID,KAAK,KAAK,CAAV,IAAeC,MAAM,KAAK,CAA9B,EAAiC;AAC/BhC,IAAAA,aAAa,CAAC2B,eAAD,EAAkB;AAC7Bb,MAAAA,CAAC,EAAEqB,IAD0B;AAE7BpB,MAAAA,CAAC,EAAEqB,IAF0B;AAG7BL,MAAAA,KAH6B;AAI7BC,MAAAA;AAJ6B,KAAlB,CAAb;AAMD;AACF,CA1CM","sourcesContent":["import { SHAPES } from \"../shapes\";\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport Scene from \"../scene/Scene\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { PointerDownState } from \"../components/App\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  scene: Scene,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n  selectedElements.forEach((element) => {\n    let x: number;\n    let y: number;\n    if (lockDirection) {\n      const lockX = lockDirection && distanceX < distanceY;\n      const lockY = lockDirection && distanceX > distanceY;\n      const original = pointerDownState.originalElements.get(element.id);\n      x = lockX && original ? original.x : element.x + offset.x;\n      y = lockY && original ? original.y : element.y + offset.y;\n    } else {\n      x = element.x + offset.x;\n      y = element.y + offset.y;\n    }\n\n    mutateElement(element, {\n      x,\n      y,\n    });\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: selectedElements,\n    });\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: typeof SHAPES[number][\"value\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  isResizeWithSidesSameLength: boolean,\n  isResizeCenterPoint: boolean,\n) => {\n  if (isResizeWithSidesSameLength) {\n    ({ width, height } = getPerfectElementSize(\n      elementType,\n      width,\n      y < originY ? -height : height,\n    ));\n\n    if (height < 0) {\n      height = -height;\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (isResizeCenterPoint) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}