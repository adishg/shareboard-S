{"ast":null,"code":"import { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n  constructor(config) {\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      combineNestedSvgPaths: false,\n      disableMultiStroke: false,\n      disableMultiStrokeFill: false\n    };\n    this.config = config || {};\n\n    if (this.config.options) {\n      this.defaultOptions = this._o(this.config.options);\n    }\n  }\n\n  static newSeed() {\n    return randomSeed();\n  }\n\n  _o(options) {\n    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n  }\n\n  _d(shape, sets, options) {\n    return {\n      shape,\n      sets: sets || [],\n      options: options || this.defaultOptions\n    };\n  }\n\n  line(x1, y1, x2, y2, options) {\n    const o = this._o(options);\n\n    return this._d('line', [line(x1, y1, x2, y2, o)], o);\n  }\n\n  rectangle(x, y, width, height, options) {\n    const o = this._o(options);\n\n    const paths = [];\n    const outline = rectangle(x, y, width, height, o);\n\n    if (o.fill) {\n      const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(points, o));\n      } else {\n        paths.push(patternFillPolygon(points, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._d('rectangle', paths, o);\n  }\n\n  ellipse(x, y, width, height, options) {\n    const o = this._o(options);\n\n    const paths = [];\n    const ellipseParams = generateEllipseParams(width, height, o);\n    const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(ellipseResponse.opset);\n    }\n\n    return this._d('ellipse', paths, o);\n  }\n\n  circle(x, y, diameter, options) {\n    const ret = this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n\n  linearPath(points, options) {\n    const o = this._o(options);\n\n    return this._d('linearPath', [linearPath(points, false, o)], o);\n  }\n\n  arc(x, y, width, height, start, stop, closed = false, options) {\n    const o = this._o(options);\n\n    const paths = [];\n    const outline = arc(x, y, width, height, start, stop, closed, true, o);\n\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = arc(x, y, width, height, start, stop, true, false, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._d('arc', paths, o);\n  }\n\n  curve(points, options) {\n    const o = this._o(options);\n\n    const paths = [];\n    const outline = curve(points, o);\n\n    if (o.fill && o.fill !== NOS && points.length >= 3) {\n      const bcurve = curveToBezier(points);\n      const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(polyPoints, o));\n      } else {\n        paths.push(patternFillPolygon(polyPoints, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._d('curve', paths, o);\n  }\n\n  polygon(points, options) {\n    const o = this._o(options);\n\n    const paths = [];\n    const outline = linearPath(points, true, o);\n\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(points, o));\n      } else {\n        paths.push(patternFillPolygon(points, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._d('polygon', paths, o);\n  }\n\n  path(d, options) {\n    const o = this._o(options);\n\n    const paths = [];\n\n    if (!d) {\n      return this._d('path', paths, o);\n    }\n\n    d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n    const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n    const hasStroke = o.stroke !== NOS;\n    const simplified = !!(o.simplification && o.simplification < 1);\n    const distance = simplified ? 4 - 4 * o.simplification : (1 + o.roughness) / 2;\n    const sets = pointsOnPath(d, 1, distance);\n\n    if (hasFill) {\n      if (o.combineNestedSvgPaths) {\n        const combined = [];\n        sets.forEach(set => combined.push(...set));\n\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon(combined, o));\n        } else {\n          paths.push(patternFillPolygon(combined, o));\n        }\n      } else {\n        sets.forEach(polyPoints => {\n          if (o.fillStyle === 'solid') {\n            paths.push(solidFillPolygon(polyPoints, o));\n          } else {\n            paths.push(patternFillPolygon(polyPoints, o));\n          }\n        });\n      }\n    }\n\n    if (hasStroke) {\n      if (simplified) {\n        sets.forEach(set => {\n          paths.push(linearPath(set, false, o));\n        });\n      } else {\n        paths.push(svgPath(d, o));\n      }\n    }\n\n    return this._d('path', paths, o);\n  }\n\n  opsToPath(drawing) {\n    let path = '';\n\n    for (const item of drawing.ops) {\n      const data = item.data;\n\n      switch (item.op) {\n        case 'move':\n          path += `M${data[0]} ${data[1]} `;\n          break;\n\n        case 'bcurveTo':\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n\n        case 'lineTo':\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n\n    return path.trim();\n  }\n\n  toPaths(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.defaultOptions;\n    const paths = [];\n\n    for (const drawing of sets) {\n      let path = null;\n\n      switch (drawing.type) {\n        case 'path':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: o.stroke,\n            strokeWidth: o.strokeWidth,\n            fill: NOS\n          };\n          break;\n\n        case 'fillPath':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: NOS,\n            strokeWidth: 0,\n            fill: o.fill || NOS\n          };\n          break;\n\n        case 'fillSketch':\n          path = this.fillSketch(drawing, o);\n          break;\n      }\n\n      if (path) {\n        paths.push(path);\n      }\n    }\n\n    return paths;\n  }\n\n  fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n\n    return {\n      d: this.opsToPath(drawing),\n      stroke: o.fill || NOS,\n      strokeWidth: fweight,\n      fill: NOS\n    };\n  }\n\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/roughjs/bin/generator.js"],"names":["line","solidFillPolygon","patternFillPolygon","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","randomSeed","curveToBezier","pointsOnBezierCurves","pointsOnPath","NOS","RoughGenerator","constructor","config","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","combineNestedSvgPaths","disableMultiStroke","disableMultiStrokeFill","options","_o","newSeed","Object","assign","_d","shape","sets","x1","y1","x2","y2","o","x","y","width","height","paths","outline","fill","points","push","ellipse","ellipseParams","ellipseResponse","opset","type","estimatedPoints","circle","diameter","ret","start","stop","closed","length","bcurve","polyPoints","polygon","path","d","replace","hasFill","hasStroke","simplified","simplification","distance","combined","forEach","set","opsToPath","drawing","item","ops","data","op","trim","toPaths","drawable","fillSketch","fweight"],"mappings":"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","sourcesContent":["import { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            combineNestedSvgPaths: false,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            const bcurve = curveToBezier(points);\n            const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(polyPoints, o));\n            }\n            else {\n                paths.push(patternFillPolygon(polyPoints, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        if (hasFill) {\n            if (o.combineNestedSvgPaths) {\n                const combined = [];\n                sets.forEach((set) => combined.push(...set));\n                if (o.fillStyle === 'solid') {\n                    paths.push(solidFillPolygon(combined, o));\n                }\n                else {\n                    paths.push(patternFillPolygon(combined, o));\n                }\n            }\n            else {\n                sets.forEach((polyPoints) => {\n                    if (o.fillStyle === 'solid') {\n                        paths.push(solidFillPolygon(polyPoints, o));\n                    }\n                    else {\n                        paths.push(patternFillPolygon(polyPoints, o));\n                    }\n                });\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(svgPath(d, o));\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}