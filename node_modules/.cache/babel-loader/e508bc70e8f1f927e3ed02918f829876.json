{"ast":null,"code":"import { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { getShapeForElement, generateRoughOptions } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\"; // x and y position of top left corner, x and y position of bottom right corner\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = element => {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n\n  return [element.x, element.y, element.x + element.width, element.y + element.height];\n};\nexport const pointRelativeTo = (element, absoluteCoords) => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\nexport const getDiamondPoints = element => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\nexport const getCurvePathOps = shape => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (ops, transformXY) => {\n  let currentP = [0, 0];\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = ops.reduce((limits, {\n    op,\n    data\n  }) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3;\n\n      const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n\n      let t = 0;\n\n      while (t <= 1.0) {\n        let x = equation(t, 0);\n        let y = equation(t, 1);\n\n        if (transformXY) {\n          [x, y] = transformXY(x, y);\n        }\n\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        t += 0.1;\n      }\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return limits;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  });\n  return [minX, minY, maxX, maxY];\n};\n\nconst getLinearElementAbsoluteCoords = element => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = element.points.reduce((limits, [x, y]) => {\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    });\n    return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n  }\n\n  const shape = getShapeForElement(element); // first element is always the curve\n\n  const ops = getCurvePathOps(shape[0]);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n};\n\nexport const getArrowheadPoints = (element, shape, position, arrowhead) => {\n  const ops = getCurvePathOps(shape[0]);\n\n  if (ops.length < 1) {\n    return null;\n  } // The index of the bCurve operation to examine.\n\n\n  const index = position === \"start\" ? 1 : ops.length - 1;\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]];\n  const p2 = [data[2], data[3]];\n  const p1 = [data[0], data[1]]; // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n\n  const prevOp = ops[index - 1];\n  let p0 = [0, 0];\n\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  } // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n\n\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3); // Ee know the last point of the arrow (or the first, if start arrowhead).\n\n\n  const [x2, y2] = position === \"start\" ? p0 : p3; // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)]; // Find the normalized direction vector based on the\n  // previously calculated points.\n\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  const length = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0); // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the whole length of the\n  // arrowhead instead of last segment of the arrowhead.\n\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2);\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90\n  }[arrowhead]; // degrees\n  // Return points\n\n  const [x3, y3] = rotate(xs, ys, x2, y2, -angle * Math.PI / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, angle * Math.PI / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (element, cx, cy) => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = element.points.reduce((limits, [x, y]) => {\n      [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    });\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element); // first element is always the curve\n\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x, y) => rotate(element.x + x, element.y + y, cx, cy, element.angle);\n\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\nexport const getElementBounds = element => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\nexport const getCommonBounds = elements => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n  return [minX, minY, maxX, maxY];\n};\nexport const getResizedElementAbsoluteCoords = (element, nextWidth, nextHeight) => {\n  if (!isLinearElement(element)) {\n    return [element.x, element.y, element.x + nextWidth, element.y + nextHeight];\n  }\n\n  const points = rescalePoints(0, nextWidth, rescalePoints(1, nextHeight, element.points));\n  const gen = rough.generator();\n  const curve = element.strokeSharpness === \"sharp\" ? gen.linearPath(points, generateRoughOptions(element)) : gen.curve(points, generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n};\nexport const getElementPointsCoords = (element, points, sharpness) => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve = sharpness === \"sharp\" ? gen.linearPath(points, generateRoughOptions(element)) : gen.curve(points, generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n};\nexport const getClosestElementBounds = (elements, from) => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n  return getElementBounds(closestElement);\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/bounds.ts"],"names":["distance2d","rotate","rough","getShapeForElement","generateRoughOptions","isLinearElement","rescalePoints","getElementAbsoluteCoords","element","getLinearElementAbsoluteCoords","x","y","width","height","pointRelativeTo","absoluteCoords","getDiamondPoints","topX","Math","floor","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","getCurvePathOps","shape","set","sets","type","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","minX","minY","maxX","maxY","reduce","limits","op","data","p1","p2","p3","p0","equation","t","idx","pow","min","max","Infinity","points","length","getArrowheadPoints","position","arrowhead","index","prevOp","x2","y2","x1","y1","distance","hypot","nx","ny","size","arrow","bar","dot","total","cx","cy","px","py","minSize","xs","ys","r","angle","x3","y3","PI","x4","y4","getLinearElementRotatedBounds","getElementBounds","x11","y11","x12","y12","x22","y22","x21","y21","w","h","cos","sin","ww","hh","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","nextWidth","nextHeight","gen","generator","curve","strokeSharpness","linearPath","getElementPointsCoords","sharpness","getClosestElementBounds","from","minDistance","closestElement"],"mappings":"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","sourcesContent":["import { ExcalidrawElement, ExcalidrawLinearElement, Arrowhead } from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [number, number, number, number];\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): Bounds => {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  const length = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the whole length of the\n  // arrowhead instead of last segment of the arrowhead.\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2);\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!isLinearElement(element)) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  const gen = rough.generator();\n  const curve =\n    element.strokeSharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    sharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n"]},"metadata":{},"sourceType":"module"}