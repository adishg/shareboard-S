{"ast":null,"code":"import { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\nexport const distributeElements = (selectedElements, distribution) => {\n  const [start, mid, end, extent] = distribution.axis === \"x\" ? [\"minX\", \"midX\", \"maxX\", \"width\"] : [\"minY\", \"midY\", \"maxY\", \"height\"];\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements).map(group => [group, getCommonBoundingBox(group)]).sort((a, b) => a[1][mid] - b[1][mid]);\n  let span = 0;\n\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex(g => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex(g => g[1][end] === bounds[end]); // Get our step, based on the distance between the center points of our\n    // start and end boxes\n\n    const step = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n    let pos = groups[index0][1][mid];\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0\n      }; // Don't move our start and end boxes\n\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map(element => newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y\n      }));\n    });\n  } // Distribute from gaps\n\n\n  let pos = bounds[start];\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0\n    };\n    translation[distribution.axis] = pos - box[start];\n    pos += step;\n    pos += box[extent];\n    return group.map(element => newElementWith(element, {\n      x: element.x + translation.x,\n      y: element.y + translation.y\n    }));\n  });\n};\nexport const getMaximumGroups = elements => {\n  const groups = new Map();\n  elements.forEach(element => {\n    const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];\n    const currentGroupMembers = groups.get(groupId) || [];\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n  return Array.from(groups.values());\n};\n\nconst getCommonBoundingBox = elements => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2\n  };\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/disitrubte.ts"],"names":["newElementWith","getCommonBounds","distributeElements","selectedElements","distribution","start","mid","end","extent","axis","bounds","getCommonBoundingBox","groups","getMaximumGroups","map","group","sort","a","b","span","step","length","index0","findIndex","g","index1","pos","flatMap","box","index","translation","x","y","element","elements","Map","forEach","groupId","groupIds","id","currentGroupMembers","get","set","Array","from","values","minX","minY","maxX","maxY","width","height","midX","midY"],"mappings":"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","sourcesContent":["import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}