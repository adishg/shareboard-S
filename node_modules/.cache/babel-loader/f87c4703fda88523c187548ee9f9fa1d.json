{"ast":null,"code":"import { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { t } from \"../../i18n\";\n\nconst byteToHex = byte => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 128\n  }, true, // extractable\n  [\"encrypt\", \"decrypt\"]);\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\nexport const createIV = () => {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n};\nexport const encryptAESGEM = async (data, key) => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt({\n      name: \"AES-GCM\",\n      iv\n    }, importedKey, data),\n    iv\n  };\n};\nexport const decryptAESGEM = async (data, key, iv) => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv\n    }, importedKey, data);\n    const decodedData = new TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n\n  return {\n    type: \"INVALID_RESPONSE\"\n  };\n};\nexport const getCollaborationLinkData = link => {\n  if (link.length === 0) {\n    return;\n  }\n\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n};\nexport const generateCollaborationLink = async () => {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n};\nexport const getImportedKey = (key, usage) => window.crypto.subtle.importKey(\"jwk\", {\n  alg: \"A128GCM\",\n  ext: true,\n  k: key,\n  key_ops: [\"encrypt\", \"decrypt\"],\n  kty: \"oct\"\n}, {\n  name: \"AES-GCM\",\n  length: 128\n}, false, // extractable\n[usage]);\n\nconst importFromBackend = async (id, privateKey) => {\n  try {\n    const response = await fetch(privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`);\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n\n    let data;\n\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv\n      }, key, buffer); // We need to convert the decrypted array buffer to a string\n\n      const string = new window.TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (id, privateKey, initialData) => {\n  let data;\n\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(await importFromBackend(id, privateKey), initialData === null || initialData === void 0 ? void 0 : initialData.appState);\n  } else {\n    data = restore(initialData || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false\n  };\n};\nexport const exportToBackend = async (elements, appState) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n  const key = await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 128\n  }, true, // extractable\n  [\"encrypt\", \"decrypt\"]); // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n\n  const iv = new Uint8Array(12); // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n\n  const encrypted = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv\n  }, key, encoded); // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted\n    });\n    const json = await response.json();\n\n    if (json.id) {\n      const url = new URL(window.location.href); // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n\n      url.hash = `json=${json.id},${exportedKey.k}`;\n      const urlString = url.toString();\n      window.prompt(`ðŸ”’${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/excalidraw-app/data/index.ts"],"names":["serializeAsJSON","restore","t","byteToHex","byte","toString","slice","BACKEND_GET","process","env","REACT_APP_BACKEND_V1_GET_URL","BACKEND_V2_GET","REACT_APP_BACKEND_V2_GET_URL","BACKEND_V2_POST","REACT_APP_BACKEND_V2_POST_URL","generateRandomID","arr","Uint8Array","window","crypto","getRandomValues","Array","from","join","generateEncryptionKey","key","subtle","generateKey","name","length","exportKey","k","SOCKET_SERVER","REACT_APP_SOCKET_SERVER_URL","createIV","encryptAESGEM","data","importedKey","getImportedKey","iv","encrypt","decryptAESGEM","decrypted","decrypt","decodedData","TextDecoder","decode","JSON","parse","error","alert","console","type","getCollaborationLinkData","link","hash","URL","match","generateCollaborationLink","id","location","origin","pathname","usage","importKey","alg","ext","key_ops","kty","importFromBackend","privateKey","response","fetch","ok","buffer","arrayBuffer","string","json","elements","appState","loadScene","initialData","commitToHistory","exportToBackend","encoded","TextEncoder","encode","encrypted","exportedKey","method","body","url","href","urlString","prompt","error_class"],"mappings":"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","sourcesContent":["import { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport { AppState } from \"../../types\";\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData = SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n  _brand: \"socketUpdateData\";\n};\n\nexport const createIV = () => {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  if (link.length === 0) {\n    return;\n  }\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n};\n\nexport const generateCollaborationLink = async () => {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n};\n\nexport const getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv,\n        },\n        key,\n        buffer,\n      );\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply initialData even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  initialData: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      initialData?.appState,\n    );\n  } else {\n    data = restore(initialData || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n  const iv = new Uint8Array(12);\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encoded,\n  );\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n      window.prompt(`ðŸ”’${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n"]},"metadata":{},"sourceType":"module"}