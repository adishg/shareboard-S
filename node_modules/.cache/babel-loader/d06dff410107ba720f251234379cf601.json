{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/excalidraw-app/collab/CollabWrapper.tsx\";\nimport throttle from \"lodash.throttle\";\nimport React, { PureComponent } from \"react\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { getSceneVersion, getSyncableElements } from \"../../packages/excalidraw/index\";\nimport { resolvablePromise, withBatchedUpdates } from \"../../utils\";\nimport { INITIAL_SCENE_UPDATE_TIMEOUT, SCENE, SYNC_FULL_SCENE_INTERVAL_MS } from \"../app_constants\";\nimport { decryptAESGEM, generateCollaborationLink, getCollaborationLinkData, SOCKET_SERVER } from \"../data\";\nimport { isSavedToFirebase, saveToFirebase } from \"../data/firebase\";\nimport { importUsernameFromLocalStorage, saveUsernameToLocalStorage, STORAGE_KEYS } from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\n\nclass CollabWrapper extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.portal = void 0;\n    this.socketInitializationTimer = void 0;\n    this.excalidrawRef = void 0;\n    this.excalidrawAppState = void 0;\n    this.lastBroadcastedOrReceivedSceneVersion = -1;\n    this.collaborators = new Map();\n\n    this.onUnload = () => {\n      this.destroySocketClient();\n    };\n\n    this.beforeUnload = withBatchedUpdates(event => {\n      const syncableElements = getSyncableElements(this.getSceneElementsIncludingDeleted());\n\n      if (this.state.isCollaborating && !isSavedToFirebase(this.portal, syncableElements)) {\n        // this won't run in time if user decides to leave the site, but\n        //  the purpose is to run in immediately after user decides to stay\n        this.saveCollabRoomToFirebase(syncableElements);\n        event.preventDefault(); // NOTE: modern browsers no longer allow showing a custom message here\n\n        event.returnValue = \"\";\n      }\n\n      if (this.state.isCollaborating || this.portal.roomId) {\n        try {\n          var _localStorage;\n\n          (_localStorage = localStorage) === null || _localStorage === void 0 ? void 0 : _localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG, JSON.stringify({\n            timestamp: Date.now(),\n            room: this.portal.roomId\n          }));\n        } catch {}\n      }\n    });\n\n    this.saveCollabRoomToFirebase = async (syncableElements = getSyncableElements(this.excalidrawRef.current.getSceneElementsIncludingDeleted())) => {\n      try {\n        await saveToFirebase(this.portal, syncableElements);\n      } catch (error) {\n        console.error(error);\n      }\n    };\n\n    this.openPortal = async () => {\n      window.history.pushState({}, APP_NAME, await generateCollaborationLink());\n      const elements = this.excalidrawRef.current.getSceneElements(); // remove deleted elements from elements array & history to ensure we don't\n      // expose potentially sensitive user data in case user manually deletes\n      // existing elements (or clears scene), which would otherwise be persisted\n      // to database even if deleted before creating the room.\n\n      this.excalidrawRef.current.history.clear();\n      this.excalidrawRef.current.updateScene({\n        elements,\n        commitToHistory: true\n      });\n      return this.initializeSocketClient();\n    };\n\n    this.closePortal = () => {\n      this.saveCollabRoomToFirebase();\n      window.history.pushState({}, APP_NAME, window.location.origin);\n      this.destroySocketClient();\n    };\n\n    this.destroySocketClient = () => {\n      this.collaborators = new Map();\n      this.excalidrawRef.current.updateScene({\n        collaborators: this.collaborators\n      });\n      this.setState({\n        isCollaborating: false,\n        activeRoomLink: \"\"\n      });\n      this.portal.close();\n    };\n\n    this.initializeSocketClient = async () => {\n      if (this.portal.socket) {\n        return null;\n      }\n\n      const scenePromise = resolvablePromise();\n      const roomMatch = getCollaborationLinkData(window.location.href);\n\n      if (roomMatch) {\n        const roomId = roomMatch[1];\n        const roomKey = roomMatch[2]; // fallback in case you're not alone in the room but still don't receive\n        // initial SCENE_UPDATE message\n\n        this.socketInitializationTimer = setTimeout(() => {\n          this.initializeSocket();\n          scenePromise.resolve(null);\n        }, INITIAL_SCENE_UPDATE_TIMEOUT);\n        const {\n          default: socketIOClient\n        } = await import(\n        /* webpackChunkName: \"socketIoClient\" */\n        \"socket.io-client\");\n        this.portal.open(socketIOClient(SOCKET_SERVER), roomId, roomKey); // All socket listeners are moving to Portal\n\n        this.portal.socket.on(\"client-broadcast\", async (encryptedData, iv) => {\n          if (!this.portal.roomKey) {\n            return;\n          }\n\n          const decryptedData = await decryptAESGEM(encryptedData, this.portal.roomKey, iv);\n\n          switch (decryptedData.type) {\n            case \"INVALID_RESPONSE\":\n              return;\n\n            case SCENE.INIT:\n              {\n                if (!this.portal.socketInitialized) {\n                  const remoteElements = decryptedData.payload.elements;\n                  const reconciledElements = this.reconcileElements(remoteElements);\n                  this.handleRemoteSceneUpdate(reconciledElements, {\n                    init: true\n                  });\n                  this.initializeSocket();\n                  scenePromise.resolve({\n                    elements: reconciledElements\n                  });\n                }\n\n                break;\n              }\n\n            case SCENE.UPDATE:\n              this.handleRemoteSceneUpdate(this.reconcileElements(decryptedData.payload.elements));\n              break;\n\n            case \"MOUSE_LOCATION\":\n              {\n                const {\n                  pointer,\n                  button,\n                  username,\n                  selectedElementIds\n                } = decryptedData.payload;\n                const socketId = decryptedData.payload.socketId || // @ts-ignore legacy, see #2094 (#2097)\n                decryptedData.payload.socketID;\n                const collaborators = new Map(this.collaborators);\n                const user = collaborators.get(socketId) || {};\n                user.pointer = pointer;\n                user.button = button;\n                user.selectedElementIds = selectedElementIds;\n                user.username = username;\n                collaborators.set(socketId, user);\n                this.excalidrawRef.current.updateScene({\n                  collaborators\n                });\n                break;\n              }\n          }\n        });\n        this.portal.socket.on(\"first-in-room\", () => {\n          if (this.portal.socket) {\n            this.portal.socket.off(\"first-in-room\");\n          }\n\n          this.initializeSocket();\n          scenePromise.resolve(null);\n        });\n        this.setState({\n          isCollaborating: true,\n          activeRoomLink: window.location.href\n        });\n        return scenePromise;\n      }\n\n      return null;\n    };\n\n    this.initializeSocket = () => {\n      this.portal.socketInitialized = true;\n      clearTimeout(this.socketInitializationTimer);\n    };\n\n    this.reconcileElements = elements => {\n      const newElements = this.portal.reconcileElements(elements); // Avoid broadcasting to the rest of the collaborators the scene\n      // we just received!\n      // Note: this needs to be set before updating the scene as it\n      // syncronously calls render.\n\n      this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(newElements));\n      return newElements;\n    };\n\n    this.handleRemoteSceneUpdate = (elements, {\n      init = false,\n      initFromSnapshot = false\n    } = {}) => {\n      if (init || initFromSnapshot) {\n        this.excalidrawRef.current.setScrollToCenter(elements);\n      }\n\n      this.excalidrawRef.current.updateScene({\n        elements,\n        commitToHistory: !!init\n      }); // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n      // when we receive any messages from another peer. This UX can be pretty rough -- if you\n      // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n      // right now we think this is the right tradeoff.\n\n      this.excalidrawRef.current.history.clear();\n    };\n\n    this.setLastBroadcastedOrReceivedSceneVersion = version => {\n      this.lastBroadcastedOrReceivedSceneVersion = version;\n    };\n\n    this.getLastBroadcastedOrReceivedSceneVersion = () => {\n      return this.lastBroadcastedOrReceivedSceneVersion;\n    };\n\n    this.getSceneElementsIncludingDeleted = () => {\n      return this.excalidrawRef.current.getSceneElementsIncludingDeleted();\n    };\n\n    this.onPointerUpdate = payload => {\n      payload.pointersMap.size < 2 && this.portal.socket && this.portal.broadcastMouseLocation(payload);\n    };\n\n    this.broadcastElements = (elements, state) => {\n      this.excalidrawAppState = state;\n\n      if (getSceneVersion(elements) > this.getLastBroadcastedOrReceivedSceneVersion()) {\n        this.portal.broadcastScene(SCENE.UPDATE, getSyncableElements(elements), false);\n        this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n        this.queueBroadcastAllElements();\n      }\n    };\n\n    this.queueBroadcastAllElements = throttle(() => {\n      this.portal.broadcastScene(SCENE.UPDATE, getSyncableElements(this.excalidrawRef.current.getSceneElementsIncludingDeleted()), true);\n      const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n      const newVersion = Math.max(currentVersion, getSceneVersion(this.getSceneElementsIncludingDeleted()));\n      this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n    }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n    this.handleClose = () => {\n      this.setState({\n        modalIsShown: false\n      });\n      const collabIcon = document.querySelector(\".CollabButton\");\n      collabIcon.focus();\n    };\n\n    this.onUsernameChange = username => {\n      this.setState({\n        username\n      });\n      saveUsernameToLocalStorage(username);\n    };\n\n    this.onCollabButtonClick = () => {\n      this.setState({\n        modalIsShown: true\n      });\n    };\n\n    this.state = {\n      isCollaborating: false,\n      modalIsShown: false,\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      activeRoomLink: \"\"\n    };\n    this.portal = new Portal(this);\n    this.excalidrawRef = props.excalidrawRef;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    if (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n      window.h = window.h || {};\n      Object.defineProperties(window.h, {\n        collab: {\n          configurable: true,\n          value: this\n        }\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n  }\n\n  setCollaborators(sockets) {\n    this.setState(state => {\n      const collaborators = new Map();\n\n      for (const socketId of sockets) {\n        if (this.collaborators.has(socketId)) {\n          collaborators.set(socketId, this.collaborators.get(socketId));\n        } else {\n          collaborators.set(socketId, {});\n        }\n      }\n\n      this.collaborators = collaborators;\n      this.excalidrawRef.current.updateScene({\n        collaborators\n      });\n    });\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    const {\n      modalIsShown,\n      username,\n      errorMessage,\n      activeRoomLink\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [modalIsShown && /*#__PURE__*/_jsxDEV(RoomDialog, {\n        handleClose: this.handleClose,\n        activeRoomLink: activeRoomLink,\n        username: username,\n        onUsernameChange: this.onUsernameChange,\n        onRoomCreate: this.openPortal,\n        onRoomDestroy: this.closePortal,\n        setErrorMessage: errorMessage => {\n          this.setState({\n            errorMessage\n          });\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 435,\n        columnNumber: 11\n      }, this), errorMessage && /*#__PURE__*/_jsxDEV(ErrorDialog, {\n        message: errorMessage,\n        onClose: () => this.setState({\n          errorMessage: \"\"\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 448,\n        columnNumber: 11\n      }, this), children({\n        isCollaborating: this.state.isCollaborating,\n        username: this.state.username,\n        onPointerUpdate: this.onPointerUpdate,\n        initializeSocketClient: this.initializeSocketClient,\n        onCollabButtonClick: this.onCollabButtonClick,\n        broadcastElements: this.broadcastElements\n      })]\n    }, void 0, true);\n  }\n\n}\n\nexport default CollabWrapper;","map":{"version":3,"sources":["/var/www/html/excalidraw/src/excalidraw-app/collab/CollabWrapper.tsx"],"names":["throttle","React","PureComponent","ErrorDialog","APP_NAME","ENV","EVENT","getSceneVersion","getSyncableElements","resolvablePromise","withBatchedUpdates","INITIAL_SCENE_UPDATE_TIMEOUT","SCENE","SYNC_FULL_SCENE_INTERVAL_MS","decryptAESGEM","generateCollaborationLink","getCollaborationLinkData","SOCKET_SERVER","isSavedToFirebase","saveToFirebase","importUsernameFromLocalStorage","saveUsernameToLocalStorage","STORAGE_KEYS","Portal","RoomDialog","CollabWrapper","constructor","props","portal","socketInitializationTimer","excalidrawRef","excalidrawAppState","lastBroadcastedOrReceivedSceneVersion","collaborators","Map","onUnload","destroySocketClient","beforeUnload","event","syncableElements","getSceneElementsIncludingDeleted","state","isCollaborating","saveCollabRoomToFirebase","preventDefault","returnValue","roomId","localStorage","setItem","LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG","JSON","stringify","timestamp","Date","now","room","current","error","console","openPortal","window","history","pushState","elements","getSceneElements","clear","updateScene","commitToHistory","initializeSocketClient","closePortal","location","origin","setState","activeRoomLink","close","socket","scenePromise","roomMatch","href","roomKey","setTimeout","initializeSocket","resolve","default","socketIOClient","open","on","encryptedData","iv","decryptedData","type","INIT","socketInitialized","remoteElements","payload","reconciledElements","reconcileElements","handleRemoteSceneUpdate","init","UPDATE","pointer","button","username","selectedElementIds","socketId","socketID","user","get","set","off","clearTimeout","newElements","setLastBroadcastedOrReceivedSceneVersion","initFromSnapshot","setScrollToCenter","version","getLastBroadcastedOrReceivedSceneVersion","onPointerUpdate","pointersMap","size","broadcastMouseLocation","broadcastElements","broadcastScene","queueBroadcastAllElements","currentVersion","newVersion","Math","max","handleClose","modalIsShown","collabIcon","document","querySelector","focus","onUsernameChange","onCollabButtonClick","errorMessage","componentDidMount","addEventListener","BEFORE_UNLOAD","UNLOAD","process","env","NODE_ENV","TEST","DEVELOPMENT","h","Object","defineProperties","collab","configurable","value","componentWillUnmount","removeEventListener","setCollaborators","sockets","has","render","children"],"mappings":"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","sourcesContent":["import throttle from \"lodash.throttle\";\nimport React, { PureComponent } from \"react\";\nimport { ExcalidrawImperativeAPI } from \"../../components/App\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport {\n  getSceneVersion,\n  getSyncableElements,\n} from \"../../packages/excalidraw/index\";\nimport { AppState, Collaborator, Gesture } from \"../../types\";\nimport { resolvablePromise, withBatchedUpdates } from \"../../utils\";\nimport {\n  INITIAL_SCENE_UPDATE_TIMEOUT,\n  SCENE,\n  SYNC_FULL_SCENE_INTERVAL_MS,\n} from \"../app_constants\";\nimport {\n  decryptAESGEM,\n  generateCollaborationLink,\n  getCollaborationLinkData,\n  SocketUpdateDataSource,\n  SOCKET_SERVER,\n} from \"../data\";\nimport { isSavedToFirebase, saveToFirebase } from \"../data/firebase\";\nimport {\n  importUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n  STORAGE_KEYS,\n} from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\n\ninterface CollabState {\n  isCollaborating: boolean;\n  modalIsShown: boolean;\n  errorMessage: string;\n  username: string;\n  activeRoomLink: string;\n}\n\ntype CollabInstance = InstanceType<typeof CollabWrapper>;\n\nexport interface CollabAPI {\n  isCollaborating: CollabState[\"isCollaborating\"];\n  username: CollabState[\"username\"];\n  onPointerUpdate: CollabInstance[\"onPointerUpdate\"];\n  initializeSocketClient: CollabInstance[\"initializeSocketClient\"];\n  onCollabButtonClick: CollabInstance[\"onCollabButtonClick\"];\n  broadcastElements: CollabInstance[\"broadcastElements\"];\n}\n\ntype ReconciledElements = readonly ExcalidrawElement[] & {\n  _brand: \"reconciledElements\";\n};\n\ninterface Props {\n  children: (collab: CollabAPI) => React.ReactNode;\n  // NOTE not type-safe because the refObject may in fact not be initialized\n  // with ExcalidrawImperativeAPI yet\n  excalidrawRef: React.MutableRefObject<ExcalidrawImperativeAPI>;\n}\n\nclass CollabWrapper extends PureComponent<Props, CollabState> {\n  portal: Portal;\n  private socketInitializationTimer?: NodeJS.Timeout;\n  private excalidrawRef: Props[\"excalidrawRef\"];\n  excalidrawAppState?: AppState;\n  private lastBroadcastedOrReceivedSceneVersion: number = -1;\n  private collaborators = new Map<string, Collaborator>();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      isCollaborating: false,\n      modalIsShown: false,\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      activeRoomLink: \"\",\n    };\n    this.portal = new Portal(this);\n    this.excalidrawRef = props.excalidrawRef;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      window.h = window.h || ({} as Window[\"h\"]);\n      Object.defineProperties(window.h, {\n        collab: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n  }\n\n  private onUnload = () => {\n    this.destroySocketClient();\n  };\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    const syncableElements = getSyncableElements(\n      this.getSceneElementsIncludingDeleted(),\n    );\n    if (\n      this.state.isCollaborating &&\n      !isSavedToFirebase(this.portal, syncableElements)\n    ) {\n      // this won't run in time if user decides to leave the site, but\n      //  the purpose is to run in immediately after user decides to stay\n      this.saveCollabRoomToFirebase(syncableElements);\n\n      event.preventDefault();\n      // NOTE: modern browsers no longer allow showing a custom message here\n      event.returnValue = \"\";\n    }\n\n    if (this.state.isCollaborating || this.portal.roomId) {\n      try {\n        localStorage?.setItem(\n          STORAGE_KEYS.LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG,\n          JSON.stringify({\n            timestamp: Date.now(),\n            room: this.portal.roomId,\n          }),\n        );\n      } catch {}\n    }\n  });\n\n  saveCollabRoomToFirebase = async (\n    syncableElements: ExcalidrawElement[] = getSyncableElements(\n      this.excalidrawRef.current!.getSceneElementsIncludingDeleted(),\n    ),\n  ) => {\n    try {\n      await saveToFirebase(this.portal, syncableElements);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  openPortal = async () => {\n    window.history.pushState({}, APP_NAME, await generateCollaborationLink());\n    const elements = this.excalidrawRef.current!.getSceneElements();\n    // remove deleted elements from elements array & history to ensure we don't\n    // expose potentially sensitive user data in case user manually deletes\n    // existing elements (or clears scene), which would otherwise be persisted\n    // to database even if deleted before creating the room.\n    this.excalidrawRef.current!.history.clear();\n    this.excalidrawRef.current!.updateScene({\n      elements,\n      commitToHistory: true,\n    });\n    return this.initializeSocketClient();\n  };\n\n  closePortal = () => {\n    this.saveCollabRoomToFirebase();\n    window.history.pushState({}, APP_NAME, window.location.origin);\n    this.destroySocketClient();\n  };\n\n  private destroySocketClient = () => {\n    this.collaborators = new Map();\n    this.excalidrawRef.current!.updateScene({\n      collaborators: this.collaborators,\n    });\n    this.setState({\n      isCollaborating: false,\n      activeRoomLink: \"\",\n    });\n    this.portal.close();\n  };\n\n  private initializeSocketClient = async (): Promise<ImportedDataState | null> => {\n    if (this.portal.socket) {\n      return null;\n    }\n\n    const scenePromise = resolvablePromise<ImportedDataState | null>();\n\n    const roomMatch = getCollaborationLinkData(window.location.href);\n\n    if (roomMatch) {\n      const roomId = roomMatch[1];\n      const roomKey = roomMatch[2];\n\n      // fallback in case you're not alone in the room but still don't receive\n      // initial SCENE_UPDATE message\n      this.socketInitializationTimer = setTimeout(() => {\n        this.initializeSocket();\n        scenePromise.resolve(null);\n      }, INITIAL_SCENE_UPDATE_TIMEOUT);\n\n      const { default: socketIOClient }: any = await import(\n        /* webpackChunkName: \"socketIoClient\" */ \"socket.io-client\"\n      );\n\n      this.portal.open(socketIOClient(SOCKET_SERVER), roomId, roomKey);\n\n      // All socket listeners are moving to Portal\n      this.portal.socket!.on(\n        \"client-broadcast\",\n        async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n          if (!this.portal.roomKey) {\n            return;\n          }\n          const decryptedData = await decryptAESGEM(\n            encryptedData,\n            this.portal.roomKey,\n            iv,\n          );\n\n          switch (decryptedData.type) {\n            case \"INVALID_RESPONSE\":\n              return;\n            case SCENE.INIT: {\n              if (!this.portal.socketInitialized) {\n                const remoteElements = decryptedData.payload.elements;\n                const reconciledElements = this.reconcileElements(\n                  remoteElements,\n                );\n                this.handleRemoteSceneUpdate(reconciledElements, {\n                  init: true,\n                });\n                this.initializeSocket();\n                scenePromise.resolve({ elements: reconciledElements });\n              }\n              break;\n            }\n            case SCENE.UPDATE:\n              this.handleRemoteSceneUpdate(\n                this.reconcileElements(decryptedData.payload.elements),\n              );\n              break;\n            case \"MOUSE_LOCATION\": {\n              const {\n                pointer,\n                button,\n                username,\n                selectedElementIds,\n              } = decryptedData.payload;\n              const socketId: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"socketId\"] =\n                decryptedData.payload.socketId ||\n                // @ts-ignore legacy, see #2094 (#2097)\n                decryptedData.payload.socketID;\n\n              const collaborators = new Map(this.collaborators);\n              const user = collaborators.get(socketId) || {}!;\n              user.pointer = pointer;\n              user.button = button;\n              user.selectedElementIds = selectedElementIds;\n              user.username = username;\n              collaborators.set(socketId, user);\n              this.excalidrawRef.current!.updateScene({\n                collaborators,\n              });\n              break;\n            }\n          }\n        },\n      );\n      this.portal.socket!.on(\"first-in-room\", () => {\n        if (this.portal.socket) {\n          this.portal.socket.off(\"first-in-room\");\n        }\n        this.initializeSocket();\n        scenePromise.resolve(null);\n      });\n\n      this.setState({\n        isCollaborating: true,\n        activeRoomLink: window.location.href,\n      });\n\n      return scenePromise;\n    }\n\n    return null;\n  };\n\n  private initializeSocket = () => {\n    this.portal.socketInitialized = true;\n    clearTimeout(this.socketInitializationTimer!);\n  };\n\n  private reconcileElements = (\n    elements: readonly ExcalidrawElement[],\n  ): ReconciledElements => {\n    const newElements = this.portal.reconcileElements(elements);\n\n    // Avoid broadcasting to the rest of the collaborators the scene\n    // we just received!\n    // Note: this needs to be set before updating the scene as it\n    // syncronously calls render.\n    this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(newElements));\n\n    return newElements as ReconciledElements;\n  };\n\n  private handleRemoteSceneUpdate = (\n    elements: ReconciledElements,\n    {\n      init = false,\n      initFromSnapshot = false,\n    }: { init?: boolean; initFromSnapshot?: boolean } = {},\n  ) => {\n    if (init || initFromSnapshot) {\n      this.excalidrawRef.current!.setScrollToCenter(elements);\n    }\n\n    this.excalidrawRef.current!.updateScene({\n      elements,\n      commitToHistory: !!init,\n    });\n\n    // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n    // when we receive any messages from another peer. This UX can be pretty rough -- if you\n    // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n    // right now we think this is the right tradeoff.\n    this.excalidrawRef.current!.history.clear();\n  };\n\n  setCollaborators(sockets: string[]) {\n    this.setState((state) => {\n      const collaborators: InstanceType<\n        typeof CollabWrapper\n      >[\"collaborators\"] = new Map();\n      for (const socketId of sockets) {\n        if (this.collaborators.has(socketId)) {\n          collaborators.set(socketId, this.collaborators.get(socketId)!);\n        } else {\n          collaborators.set(socketId, {});\n        }\n      }\n      this.collaborators = collaborators;\n      this.excalidrawRef.current!.updateScene({ collaborators });\n    });\n  }\n\n  public setLastBroadcastedOrReceivedSceneVersion = (version: number) => {\n    this.lastBroadcastedOrReceivedSceneVersion = version;\n  };\n\n  public getLastBroadcastedOrReceivedSceneVersion = () => {\n    return this.lastBroadcastedOrReceivedSceneVersion;\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.excalidrawRef.current!.getSceneElementsIncludingDeleted();\n  };\n\n  onPointerUpdate = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n    pointersMap: Gesture[\"pointers\"];\n  }) => {\n    payload.pointersMap.size < 2 &&\n      this.portal.socket &&\n      this.portal.broadcastMouseLocation(payload);\n  };\n\n  broadcastElements = (\n    elements: readonly ExcalidrawElement[],\n    state: AppState,\n  ) => {\n    this.excalidrawAppState = state;\n    if (\n      getSceneVersion(elements) >\n      this.getLastBroadcastedOrReceivedSceneVersion()\n    ) {\n      this.portal.broadcastScene(\n        SCENE.UPDATE,\n        getSyncableElements(elements),\n        false,\n      );\n      this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n      this.queueBroadcastAllElements();\n    }\n  };\n\n  queueBroadcastAllElements = throttle(() => {\n    this.portal.broadcastScene(\n      SCENE.UPDATE,\n      getSyncableElements(\n        this.excalidrawRef.current!.getSceneElementsIncludingDeleted(),\n      ),\n      true,\n    );\n    const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n    const newVersion = Math.max(\n      currentVersion,\n      getSceneVersion(this.getSceneElementsIncludingDeleted()),\n    );\n    this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n  }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n  handleClose = () => {\n    this.setState({ modalIsShown: false });\n    const collabIcon = document.querySelector(\".CollabButton\") as HTMLElement;\n    collabIcon.focus();\n  };\n\n  onUsernameChange = (username: string) => {\n    this.setState({ username });\n    saveUsernameToLocalStorage(username);\n  };\n\n  onCollabButtonClick = () => {\n    this.setState({\n      modalIsShown: true,\n    });\n  };\n\n  render() {\n    const { children } = this.props;\n    const { modalIsShown, username, errorMessage, activeRoomLink } = this.state;\n\n    return (\n      <>\n        {modalIsShown && (\n          <RoomDialog\n            handleClose={this.handleClose}\n            activeRoomLink={activeRoomLink}\n            username={username}\n            onUsernameChange={this.onUsernameChange}\n            onRoomCreate={this.openPortal}\n            onRoomDestroy={this.closePortal}\n            setErrorMessage={(errorMessage) => {\n              this.setState({ errorMessage });\n            }}\n          />\n        )}\n        {errorMessage && (\n          <ErrorDialog\n            message={errorMessage}\n            onClose={() => this.setState({ errorMessage: \"\" })}\n          />\n        )}\n        {children({\n          isCollaborating: this.state.isCollaborating,\n          username: this.state.username,\n          onPointerUpdate: this.onPointerUpdate,\n          initializeSocketClient: this.initializeSocketClient,\n          onCollabButtonClick: this.onCollabButtonClick,\n          broadcastElements: this.broadcastElements,\n        })}\n      </>\n    );\n  }\n}\n\nexport default CollabWrapper;\n"]},"metadata":{},"sourceType":"module"}