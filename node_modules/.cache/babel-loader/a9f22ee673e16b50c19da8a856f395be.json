{"ast":null,"code":"import { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\nexport { newElement, newTextElement, updateTextElement, newLinearElement, duplicateElement } from \"./newElement\";\nexport { getElementAbsoluteCoords, getElementBounds, getCommonBounds, getDiamondPoints, getArrowheadPoints, getClosestElementBounds } from \"./bounds\";\nexport { OMIT_SIDES_FOR_MULTIPLE_ELEMENTS, getTransformHandlesFromCoords, getTransformHandles } from \"./transformHandles\";\nexport { hitTest, isHittingElementBoundingBoxWithoutHittingElement } from \"./collision\";\nexport { resizeTest, getCursorForResizingElement, getElementWithTransformHandleType, getTransformHandleTypeFromCoords } from \"./resizeTest\";\nexport { transformElements, getResizeOffsetXY, getResizeArrowDirection } from \"./resizeElements\";\nexport { dragSelectedElements, getDragOffsetXY, dragNewElement } from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport { getPerfectElementSize, isInvisiblySmallElement, resizePerfectLineForNWHandler, getNormalizedDimensions } from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\nexport const getSyncableElements = elements => // There are places in Excalidraw where synthetic invisibly small elements are added and removed.\n// It's probably best to keep those local otherwise there might be a race condition that\n// gets the app into an invalid state. I've never seen it happen but I'm worried about it :)\nelements.filter(el => el.isDeleted || !isInvisiblySmallElement(el));\nexport const getElementMap = elements => elements.reduce((acc, element) => {\n  acc[element.id] = element;\n  return acc;\n}, {});\nexport const getSceneVersion = elements => elements.reduce((acc, el) => acc + el.version, 0);\nexport const getNonDeletedElements = elements => elements.filter(element => !element.isDeleted);\nexport const isNonDeletedElement = element => !element.isDeleted;\n\nconst _clearElements = elements => getNonDeletedElements(elements).map(element => isLinearElementType(element.type) ? { ...element,\n  lastCommittedPoint: null\n} : element);\n\nexport const clearElementsForExport = elements => _clearElements(elements);\nexport const clearElementsForLocalStorage = elements => _clearElements(elements);","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/index.ts"],"names":["isInvisiblySmallElement","isLinearElementType","newElement","newTextElement","updateTextElement","newLinearElement","duplicateElement","getElementAbsoluteCoords","getElementBounds","getCommonBounds","getDiamondPoints","getArrowheadPoints","getClosestElementBounds","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","getTransformHandlesFromCoords","getTransformHandles","hitTest","isHittingElementBoundingBoxWithoutHittingElement","resizeTest","getCursorForResizingElement","getElementWithTransformHandleType","getTransformHandleTypeFromCoords","transformElements","getResizeOffsetXY","getResizeArrowDirection","dragSelectedElements","getDragOffsetXY","dragNewElement","isTextElement","isExcalidrawElement","textWysiwyg","redrawTextBoundingBox","getPerfectElementSize","resizePerfectLineForNWHandler","getNormalizedDimensions","showSelectedShapeActions","getSyncableElements","elements","filter","el","isDeleted","getElementMap","reduce","acc","element","id","getSceneVersion","version","getNonDeletedElements","isNonDeletedElement","_clearElements","map","type","lastCommittedPoint","clearElementsForExport","clearElementsForLocalStorage"],"mappings":"AAKA,SAASA,uBAAT,QAAwC,eAAxC;AACA,SAASC,mBAAT,QAAoC,cAApC;AAEA,SACEC,UADF,EAEEC,cAFF,EAGEC,iBAHF,EAIEC,gBAJF,EAKEC,gBALF,QAMO,cANP;AAOA,SACEC,wBADF,EAEEC,gBAFF,EAGEC,eAHF,EAIEC,gBAJF,EAKEC,kBALF,EAMEC,uBANF,QAOO,UAPP;AASA,SACEC,gCADF,EAEEC,6BAFF,EAGEC,mBAHF,QAIO,oBAJP;AAKA,SACEC,OADF,EAEEC,gDAFF,QAGO,aAHP;AAIA,SACEC,UADF,EAEEC,2BAFF,EAGEC,iCAHF,EAIEC,gCAJF,QAKO,cALP;AAMA,SACEC,iBADF,EAEEC,iBAFF,EAGEC,uBAHF,QAIO,kBAJP;AAKA,SACEC,oBADF,EAEEC,eAFF,EAGEC,cAHF,QAIO,gBAJP;AAKA,SAASC,aAAT,EAAwBC,mBAAxB,QAAmD,cAAnD;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,qBAAT,QAAsC,eAAtC;AACA,SACEC,qBADF,EAEEhC,uBAFF,EAGEiC,6BAHF,EAIEC,uBAJF,QAKO,eALP;AAMA,SAASC,wBAAT,QAAyC,4BAAzC;AAEA,OAAO,MAAMC,mBAAmB,GAC9BC,QADiC,IACO;AAExC;AACA;AACAA,QAAQ,CAACC,MAAT,CAAiBC,EAAD,IAAQA,EAAE,CAACC,SAAH,IAAgB,CAACxC,uBAAuB,CAACuC,EAAD,CAAhE,CALK;AAOP,OAAO,MAAME,aAAa,GAAIJ,QAAD,IAC3BA,QAAQ,CAACK,MAAT,CACE,CAACC,GAAD,EAA4CC,OAA5C,KAA2E;AACzED,EAAAA,GAAG,CAACC,OAAO,CAACC,EAAT,CAAH,GAAkBD,OAAlB;AACA,SAAOD,GAAP;AACD,CAJH,EAKE,EALF,CADK;AASP,OAAO,MAAMG,eAAe,GAAIT,QAAD,IAC7BA,QAAQ,CAACK,MAAT,CAAgB,CAACC,GAAD,EAAMJ,EAAN,KAAaI,GAAG,GAAGJ,EAAE,CAACQ,OAAtC,EAA+C,CAA/C,CADK;AAGP,OAAO,MAAMC,qBAAqB,GAAIX,QAAD,IACnCA,QAAQ,CAACC,MAAT,CACGM,OAAD,IAAa,CAACA,OAAO,CAACJ,SADxB,CADK;AAKP,OAAO,MAAMS,mBAAmB,GAC9BL,OADiC,IAEJ,CAACA,OAAO,CAACJ,SAFjC;;AAIP,MAAMU,cAAc,GAClBb,QADqB,IAGrBW,qBAAqB,CAACX,QAAD,CAArB,CAAgCc,GAAhC,CAAqCP,OAAD,IAClC3C,mBAAmB,CAAC2C,OAAO,CAACQ,IAAT,CAAnB,GACI,EAAE,GAAGR,OAAL;AAAcS,EAAAA,kBAAkB,EAAE;AAAlC,CADJ,GAEIT,OAHN,CAHF;;AASA,OAAO,MAAMU,sBAAsB,GACjCjB,QADoC,IAEjCa,cAAc,CAACb,QAAD,CAFZ;AAIP,OAAO,MAAMkB,4BAA4B,GACvClB,QAD0C,IAEvCa,cAAc,CAACb,QAAD,CAFZ","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowheadPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n} from \"./transformHandles\";\nexport {\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n} from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n} from \"./resizeTest\";\nexport {\n  transformElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getSyncableElements = (\n  elements: readonly ExcalidrawElement[], // There are places in Excalidraw where synthetic invisibly small elements are added and removed.\n) =>\n  // It's probably best to keep those local otherwise there might be a race condition that\n  // gets the app into an invalid state. I've never seen it happen but I'm worried about it :)\n  elements.filter((el) => el.isDeleted || !isInvisiblySmallElement(el));\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n"]},"metadata":{},"sourceType":"module"}