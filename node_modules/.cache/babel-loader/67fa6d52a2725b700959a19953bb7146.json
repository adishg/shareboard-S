{"ast":null,"code":"import oc from \"open-color\";\nimport { getElementAbsoluteCoords, OMIT_SIDES_FOR_MULTIPLE_ELEMENTS, getTransformHandlesFromCoords, getTransformHandles, getElementBounds, getCommonBounds } from \"../element\";\nimport { roundRect } from \"./roundRect\";\nimport { getScrollBars, SCROLLBAR_COLOR, SCROLLBAR_WIDTH } from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isSelectedViaGroup, getSelectedGroupIds, getElementsInGroup } from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport { isBindingEnabled } from \"../element/binding\";\nimport { viewportCoordsToSceneCoords } from \"../utils\";\n\nconst strokeRectWithRotation = (context, x, y, width, height, cx, cy, angle, fill = false) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (context, cx, cy, radius) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (context, gridSize, offsetX, offsetY, width, height) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (context, appState, sceneState, element) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom.value;\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach((point, idx) => {\n    var _appState$editingLine;\n\n    context.strokeStyle = \"red\";\n    context.setLineDash([]);\n    context.fillStyle = ((_appState$editingLine = appState.editingLinearElement) === null || _appState$editingLine === void 0 ? void 0 : _appState$editingLine.activePointIndex) === idx ? \"rgba(255, 127, 127, 0.9)\" : \"rgba(255, 255, 255, 0.9)\";\n    const {\n      POINT_HANDLE_SIZE\n    } = LinearElementEditor;\n    fillCircle(context, point[0], point[1], POINT_HANDLE_SIZE / 2 / sceneState.zoom.value);\n  });\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (elements, appState, selectionElement, scale, rc, canvas, sceneState, // extra options, currently passed by export helper\n{\n  renderScrollbars = true,\n  renderSelection = true,\n  // Whether to employ render optimizations to improve performance.\n  // Should not be turned on for export operations and similar, because it\n  // doesn't guarantee pixel-perfect output.\n  renderOptimizations = false,\n  renderGrid = true\n} = {}) => {\n  if (!canvas) {\n    return {\n      atLeastOneVisibleElement: false\n    };\n  }\n\n  const context = canvas.getContext(\"2d\");\n  context.scale(scale, scale); // When doing calculations based on canvas width we should used normalized one\n\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale; // Paint background\n\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence = sceneState.viewBackgroundColor === \"transparent\" || sceneState.viewBackgroundColor.length === 5 || // #RGBA\n    sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n    /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  } // Apply zoom\n\n\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value); // Grid\n\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(context, appState.gridSize, -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) * appState.gridSize + sceneState.scrollX % appState.gridSize, -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) * appState.gridSize + sceneState.scrollY % appState.gridSize, normalizedCanvasWidth / sceneState.zoom.value, normalizedCanvasHeight / sceneState.zoom.value);\n  } // Paint visible elements\n\n\n  const visibleElements = elements.filter(element => isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n    zoom: sceneState.zoom,\n    offsetLeft: appState.offsetLeft,\n    offsetTop: appState.offsetTop,\n    scrollX: sceneState.scrollX,\n    scrollY: sceneState.scrollY\n  }));\n  visibleElements.forEach(element => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(appState.editingLinearElement.elementId);\n\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  } // Paint selection element\n\n\n  if (selectionElement) {\n    renderElement(selectionElement, rc, context, renderOptimizations, sceneState);\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings.filter(binding => binding != null).forEach(suggestedBinding => {\n      renderBindingHighlight(context, sceneState, suggestedBinding);\n    });\n  } // Paint selected elements\n\n\n  if (renderSelection && !appState.multiElement && !appState.editingLinearElement) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = []; // local user\n\n      if (appState.selectedElementIds[element.id] && !isSelectedViaGroup(appState, element)) {\n        selectionColors.push(oc.black);\n      } // remote users\n\n\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(...sceneState.remoteSelectedElementIds[element.id].map(socketId => {\n          const {\n            background\n          } = getClientColors(socketId);\n          return background;\n        }));\n      }\n\n      if (selectionColors.length) {\n        const [elementX1, elementY1, elementX2, elementY2] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors\n        });\n      }\n\n      return acc;\n    }, []);\n\n    const addSelectionForGroupId = groupId => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black]\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach(selection => renderSelectionBorder(context, sceneState, selection));\n    const locallySelectedElements = getSelectedElements(elements, appState); // Paint resize transformHandles\n\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(locallySelectedElements[0], sceneState.zoom, \"mouse\" // when we render we don't know which pointer type so use mouse\n      );\n      renderTransformHandles(context, sceneState, transformHandles, locallySelectedElements[0].angle);\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(context, x1 - dashedLinePadding, y1 - dashedLinePadding, x2 - x1 + dashedLinePadding * 2, y2 - y1 + dashedLinePadding * 2, (x1 + x2) / 2, (y1 + y2) / 2, 0);\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords([x1, y1, x2, y2], 0, sceneState.zoom, \"mouse\", OMIT_SIDES_FOR_MULTIPLE_ELEMENTS);\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  } // Reset zoom\n\n\n  context.scale(1 / sceneState.zoom.value, 1 / sceneState.zoom.value);\n  context.translate(-zoomTranslationX, -zoomTranslationY); // Paint remote pointers\n\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let {\n      x,\n      y\n    } = sceneState.remotePointerViewportCoords[clientId];\n    const username = sceneState.remotePointerUsernames[clientId];\n    const width = 9;\n    const height = 14;\n    const isOutOfBounds = x < 0 || x > normalizedCanvasWidth - width || y < 0 || y > normalizedCanvasHeight - height;\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n    const {\n      background,\n      stroke\n    } = getClientColors(clientId);\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    if (isOutOfBounds) {\n      context.globalAlpha = 0.2;\n    }\n\n    if (sceneState.remotePointerButton && sceneState.remotePointerButton[clientId] === \"down\") {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    if (!isOutOfBounds && username) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(username);\n      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent; // Border\n\n      context.fillStyle = stroke;\n      context.globalAlpha = globalAlpha;\n      context.fillRect(offsetX - 1, offsetY - 1, measure.width + 2 * paddingHorizontal + 2, measureHeight + 2 * paddingVertical + 2); // Background\n\n      context.fillStyle = background;\n      context.fillRect(offsetX, offsetY, measure.width + 2 * paddingHorizontal, measureHeight + 2 * paddingVertical);\n      context.fillStyle = oc.white;\n      context.fillText(username, offsetX + paddingHorizontal, offsetY + paddingVertical + measure.actualBoundingBoxAscent);\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  } // Paint scrollbars\n\n\n  let scrollBars;\n\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(elements, normalizedCanvasWidth, normalizedCanvasHeight, sceneState);\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar) {\n        roundRect(context, scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, SCROLLBAR_WIDTH / 2);\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n  return {\n    atLeastOneVisibleElement: visibleElements.length > 0,\n    scrollBars\n  };\n};\n\nconst renderTransformHandles = (context, sceneState, transformHandles, angle) => {\n  Object.keys(transformHandles).forEach(key => {\n    const transformHandle = transformHandles[key];\n\n    if (transformHandle !== undefined) {\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n\n      if (key === \"rotation\") {\n        fillCircle(context, transformHandle[0] + transformHandle[2] / 2, transformHandle[1] + transformHandle[3] / 2, transformHandle[2] / 2);\n      } else {\n        strokeRectWithRotation(context, transformHandle[0], transformHandle[1], transformHandle[2], transformHandle[3], transformHandle[0] + transformHandle[2] / 2, transformHandle[1] + transformHandle[3] / 2, angle, true // fill before stroke\n        );\n      }\n\n      context.lineWidth = lineWidth;\n    }\n  });\n};\n\nconst renderSelectionBorder = (context, sceneState, elementProperties) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n  const initialLineDash = context.getLineDash();\n  const lineWidth = context.lineWidth;\n  const lineDashOffset = context.lineDashOffset;\n  const strokeStyle = context.strokeStyle;\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n  context.lineWidth = 1 / sceneState.zoom.value;\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const count = selectionColors.length;\n\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([dashWidth, spaceWidth + (dashWidth + spaceWidth) * (count - 1)]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(context, elementX1 - dashedLinePadding, elementY1 - dashedLinePadding, elementWidth + dashedLinePadding * 2, elementHeight + dashedLinePadding * 2, elementX1 + elementWidth / 2, elementY1 + elementHeight / 2, angle);\n  }\n\n  context.lineDashOffset = lineDashOffset;\n  context.strokeStyle = strokeStyle;\n  context.lineWidth = lineWidth;\n  context.setLineDash(initialLineDash);\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlight = (context, sceneState, suggestedBinding) => {\n  // preserve context settings to restore later\n  const originalStrokeStyle = context.strokeStyle;\n  const originalLineWidth = context.lineWidth;\n  const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding); // restore context settings\n\n  context.strokeStyle = originalStrokeStyle;\n  context.lineWidth = originalLineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlightForBindableElement = (context, element) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height); // So that we don't overlap the element itself\n\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(context, x1 - padding, y1 - padding, width + padding * 2, height + padding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = padding * side / height;\n      const hPadding = padding * side / width;\n      strokeDiamondWithRotation(context, width + wPadding * 2, height + hPadding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n\n    case \"ellipse\":\n      strokeEllipseWithRotation(context, width + padding * 2, height + padding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n  const threshold = maxBindingGap(bindableElement, bindableElement.width, bindableElement.height);\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n  const pointIndices = startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach(index => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(element, index);\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (element, canvasWidth, canvasHeight, viewTransformations) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n\n  const topLeftSceneCoords = viewportCoordsToSceneCoords({\n    clientX: viewTransformations.offsetLeft,\n    clientY: viewTransformations.offsetTop\n  }, viewTransformations);\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords({\n    clientX: viewTransformations.offsetLeft + canvasWidth,\n    clientY: viewTransformations.offsetTop + canvasHeight\n  }, viewTransformations);\n  return topLeftSceneCoords.x <= x2 && topLeftSceneCoords.y <= y2 && bottomRightSceneCoords.x >= x1 && bottomRightSceneCoords.y >= y1;\n}; // This should be only called for exporting purposes\n\n\nexport const renderSceneToSvg = (elements, rsvg, svgRoot, {\n  offsetX = 0,\n  offsetY = 0\n} = {}) => {\n  if (!svgRoot) {\n    return;\n  } // render elements\n\n\n  elements.forEach(element => {\n    if (!element.isDeleted) {\n      renderElementToSvg(element, rsvg, svgRoot, element.x + offsetX, element.y + offsetY);\n    }\n  });\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/renderer/renderScene.ts"],"names":["oc","getElementAbsoluteCoords","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","getTransformHandlesFromCoords","getTransformHandles","getElementBounds","getCommonBounds","roundRect","getScrollBars","SCROLLBAR_COLOR","SCROLLBAR_WIDTH","getSelectedElements","renderElement","renderElementToSvg","getClientColors","LinearElementEditor","isSelectedViaGroup","getSelectedGroupIds","getElementsInGroup","maxBindingGap","isBindingEnabled","viewportCoordsToSceneCoords","strokeRectWithRotation","context","x","y","width","height","cx","cy","angle","fill","translate","rotate","fillRect","strokeRect","strokeDiamondWithRotation","beginPath","moveTo","lineTo","closePath","stroke","strokeEllipseWithRotation","ellipse","Math","PI","fillCircle","radius","arc","strokeGrid","gridSize","offsetX","offsetY","origStrokeStyle","strokeStyle","renderLinearPointHandles","appState","sceneState","element","scrollX","scrollY","lineWidth","zoom","value","getPointsGlobalCoordinates","forEach","point","idx","setLineDash","fillStyle","editingLinearElement","activePointIndex","POINT_HANDLE_SIZE","renderScene","elements","selectionElement","scale","rc","canvas","renderScrollbars","renderSelection","renderOptimizations","renderGrid","atLeastOneVisibleElement","getContext","normalizedCanvasWidth","normalizedCanvasHeight","viewBackgroundColor","hasTransparence","length","test","clearRect","zoomTranslationX","translation","zoomTranslationY","ceil","visibleElements","filter","isVisibleElement","offsetLeft","offsetTop","getElement","elementId","suggestedBindings","binding","suggestedBinding","renderBindingHighlight","multiElement","selections","reduce","acc","selectionColors","selectedElementIds","id","push","black","remoteSelectedElementIds","map","socketId","background","elementX1","elementY1","elementX2","elementY2","addSelectionForGroupId","groupId","groupElements","editingGroupId","selection","renderSelectionBorder","locallySelectedElements","white","transformHandles","renderTransformHandles","isRotating","dashedLinePadding","x1","y1","x2","y2","initialLineDash","getLineDash","clientId","remotePointerViewportCoords","username","remotePointerUsernames","isOutOfBounds","max","min","globalAlpha","remotePointerButton","paddingHorizontal","paddingVertical","measure","measureText","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","fillText","scrollBars","horizontal","vertical","scrollBar","Object","keys","key","transformHandle","undefined","elementProperties","elementWidth","elementHeight","lineDashOffset","dashWidth","spaceWidth","count","index","originalStrokeStyle","originalLineWidth","renderHighlight","Array","isArray","renderBindingHighlightForSuggestedPointBinding","renderBindingHighlightForBindableElement","threshold","strokeOffset","padding","type","side","hypot","wPadding","hPadding","startOrEnd","bindableElement","pointIndices","getPointAtIndexGlobalCoordinates","canvasWidth","canvasHeight","viewTransformations","topLeftSceneCoords","clientX","clientY","bottomRightSceneCoords","renderSceneToSvg","rsvg","svgRoot","isDeleted"],"mappings":"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","sourcesContent":["import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords } from \"../utils\";\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      fillCircle(\n        context,\n        point[0],\n        point[1],\n        POINT_HANDLE_SIZE / 2 / sceneState.zoom.value,\n      );\n    },\n  );\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    // doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n  } = {},\n) => {\n  if (!canvas) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom.value,\n      normalizedCanvasHeight / sceneState.zoom.value,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n      zoom: sceneState.zoom,\n      offsetLeft: appState.offsetLeft,\n      offsetTop: appState.offsetTop,\n      scrollX: sceneState.scrollX,\n      scrollY: sceneState.scrollY,\n    }),\n  );\n\n  visibleElements.forEach((element) => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    renderElement(\n      selectionElement,\n      rc,\n      context,\n      renderOptimizations,\n      sceneState,\n    );\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(context, sceneState, suggestedBinding!);\n      });\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n        ] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    const addSelectionForGroupId = (groupId: GroupId) => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(\n        groupElements,\n      );\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach((selection) =>\n      renderSelectionBorder(context, sceneState, selection),\n    );\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize transformHandles\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n        \"mouse\", // when we render we don't know which pointer type so use mouse\n      );\n      renderTransformHandles(\n        context,\n        sceneState,\n        transformHandles,\n        locallySelectedElements[0].angle,\n      );\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        \"mouse\",\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom.value, 1 / sceneState.zoom.value);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n    if (isOutOfBounds) {\n      context.globalAlpha = 0.2;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    if (!isOutOfBounds && username) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(username);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.globalAlpha = globalAlpha;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n      context.fillText(\n        username,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      if (key === \"rotation\") {\n        fillCircle(\n          context,\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          transformHandle[2] / 2,\n        );\n      } else {\n        strokeRectWithRotation(\n          context,\n          transformHandle[0],\n          transformHandle[1],\n          transformHandle[2],\n          transformHandle[3],\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.lineWidth = lineWidth;\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n  },\n) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const initialLineDash = context.getLineDash();\n  const lineWidth = context.lineWidth;\n  const lineDashOffset = context.lineDashOffset;\n  const strokeStyle = context.strokeStyle;\n\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([\n      dashWidth,\n      spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n    ]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - dashedLinePadding,\n      elementY1 - dashedLinePadding,\n      elementWidth + dashedLinePadding * 2,\n      elementHeight + dashedLinePadding * 2,\n      elementX1 + elementWidth / 2,\n      elementY1 + elementHeight / 2,\n      angle,\n    );\n  }\n  context.lineDashOffset = lineDashOffset;\n  context.strokeStyle = strokeStyle;\n  context.lineWidth = lineWidth;\n  context.setLineDash(initialLineDash);\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  suggestedBinding: SuggestedBinding,\n) => {\n  // preserve context settings to restore later\n  const originalStrokeStyle = context.strokeStyle;\n  const originalLineWidth = context.lineWidth;\n\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  // restore context settings\n  context.strokeStyle = originalStrokeStyle;\n  context.lineWidth = originalLineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      renderElementToSvg(\n        element,\n        rsvg,\n        svgRoot,\n        element.x + offsetX,\n        element.y + offsetY,\n      );\n    }\n  });\n};\n"]},"metadata":{},"sourceType":"module"}