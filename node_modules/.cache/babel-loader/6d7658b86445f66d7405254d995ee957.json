{"ast":null,"code":"export const getSizeFromPoints = points => {\n  const xs = points.map(point => point[0]);\n  const ys = points.map(point => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys)\n  };\n};\nexport const rescalePoints = (dimension, nextDimensionSize, prevPoints) => {\n  const prevDimValues = prevPoints.map(point => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n  const dimensionScaleFactor = prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n  let nextMinDimension = Infinity;\n  const scaledPoints = prevPoints.map(prevPoint => prevPoint.map((value, currentDimension) => {\n    if (currentDimension !== dimension) {\n      return value;\n    }\n\n    const scaledValue = value * dimensionScaleFactor;\n    nextMinDimension = Math.min(scaledValue, nextMinDimension);\n    return scaledValue;\n  }));\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n  const nextPoints = scaledPoints.map(scaledPoint => scaledPoint.map((value, currentDimension) => {\n    return currentDimension === dimension ? value + translation : value;\n  }));\n  return nextPoints;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/points.ts"],"names":["getSizeFromPoints","points","xs","map","point","ys","width","Math","max","min","height","rescalePoints","dimension","nextDimensionSize","prevPoints","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","Infinity","scaledPoints","prevPoint","value","currentDimension","scaledValue","length","translation","nextPoints","scaledPoint"],"mappings":"AAEA,OAAO,MAAMA,iBAAiB,GAAIC,MAAD,IAA8B;AAC7D,QAAMC,EAAE,GAAGD,MAAM,CAACE,GAAP,CAAYC,KAAD,IAAWA,KAAK,CAAC,CAAD,CAA3B,CAAX;AACA,QAAMC,EAAE,GAAGJ,MAAM,CAACE,GAAP,CAAYC,KAAD,IAAWA,KAAK,CAAC,CAAD,CAA3B,CAAX;AACA,SAAO;AACLE,IAAAA,KAAK,EAAEC,IAAI,CAACC,GAAL,CAAS,GAAGN,EAAZ,IAAkBK,IAAI,CAACE,GAAL,CAAS,GAAGP,EAAZ,CADpB;AAELQ,IAAAA,MAAM,EAAEH,IAAI,CAACC,GAAL,CAAS,GAAGH,EAAZ,IAAkBE,IAAI,CAACE,GAAL,CAAS,GAAGJ,EAAZ;AAFrB,GAAP;AAID,CAPM;AAQP,OAAO,MAAMM,aAAa,GAAG,CAC3BC,SAD2B,EAE3BC,iBAF2B,EAG3BC,UAH2B,KAIf;AACZ,QAAMC,aAAa,GAAGD,UAAU,CAACX,GAAX,CAAgBC,KAAD,IAAWA,KAAK,CAACQ,SAAD,CAA/B,CAAtB;AACA,QAAMI,gBAAgB,GAAGT,IAAI,CAACC,GAAL,CAAS,GAAGO,aAAZ,CAAzB;AACA,QAAME,gBAAgB,GAAGV,IAAI,CAACE,GAAL,CAAS,GAAGM,aAAZ,CAAzB;AACA,QAAMG,iBAAiB,GAAGF,gBAAgB,GAAGC,gBAA7C;AAEA,QAAME,oBAAoB,GACxBD,iBAAiB,KAAK,CAAtB,GAA0B,CAA1B,GAA8BL,iBAAiB,GAAGK,iBADpD;AAGA,MAAIE,gBAAgB,GAAGC,QAAvB;AAEA,QAAMC,YAAY,GAAGR,UAAU,CAACX,GAAX,CAClBoB,SAAD,IACEA,SAAS,CAACpB,GAAV,CAAc,CAACqB,KAAD,EAAQC,gBAAR,KAA6B;AACzC,QAAIA,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC,aAAOY,KAAP;AACD;;AACD,UAAME,WAAW,GAAGF,KAAK,GAAGL,oBAA5B;AACAC,IAAAA,gBAAgB,GAAGb,IAAI,CAACE,GAAL,CAASiB,WAAT,EAAsBN,gBAAtB,CAAnB;AACA,WAAOM,WAAP;AACD,GAPD,CAFiB,CAArB;;AAYA,MAAIJ,YAAY,CAACK,MAAb,KAAwB,CAA5B,EAA+B;AAC7B;AACA,WAAOL,YAAP;AACD;;AAED,QAAMM,WAAW,GAAGX,gBAAgB,GAAGG,gBAAvC;AAEA,QAAMS,UAAU,GAAGP,YAAY,CAACnB,GAAb,CAChB2B,WAAD,IACEA,WAAW,CAAC3B,GAAZ,CAAgB,CAACqB,KAAD,EAAQC,gBAAR,KAA6B;AAC3C,WAAOA,gBAAgB,KAAKb,SAArB,GAAiCY,KAAK,GAAGI,WAAzC,GAAuDJ,KAA9D;AACD,GAFD,CAFe,CAAnB;AAOA,SAAOK,UAAP;AACD,CA1CM","sourcesContent":["import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n"]},"metadata":{},"sourceType":"module"}