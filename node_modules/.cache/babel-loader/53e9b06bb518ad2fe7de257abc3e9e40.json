{"ast":null,"code":"import { KEYS } from \"../keys\";\nimport { isWritableElement, getFontString } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \"./typeChecks\";\nimport { CLASSES } from \"../constants\";\n\nconst normalizeText = text => {\n  return text // replace tabs with spaces so they render and measure correctly\n  .replace(/\\t/g, \"        \") // normalize newlines\n  .replace(/\\r?\\n|\\r/g, \"\\n\");\n};\n\nconst getTransform = (width, height, angle, appState) => {\n  const {\n    zoom,\n    offsetTop,\n    offsetLeft\n  } = appState;\n  const degree = 180 * angle / Math.PI; // offsets must be multiplied by 2 to account for the division by 2 of\n  // the whole expression afterwards\n\n  return `translate(${(width - offsetLeft * 2) * (zoom.value - 1) / 2}px, ${(height - offsetTop * 2) * (zoom.value - 1) / 2}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nexport const textWysiwyg = ({\n  id,\n  appState,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element\n}) => {\n  const updateWysiwygStyle = () => {\n    var _Scene$getScene;\n\n    const updatedElement = (_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getElement(id);\n\n    if (updatedElement && isTextElement(updatedElement)) {\n      const [viewportX, viewportY] = getViewportCoords(updatedElement.x, updatedElement.y);\n      const {\n        textAlign,\n        angle\n      } = updatedElement;\n      editable.value = updatedElement.text;\n      const lines = updatedElement.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n      const lineHeight = updatedElement.height / lines.length;\n      Object.assign(editable.style, {\n        font: getFontString(updatedElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight: `${lineHeight}px`,\n        width: `${updatedElement.width}px`,\n        height: `${updatedElement.height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(updatedElement.width, updatedElement.height, angle, appState),\n        textAlign,\n        color: updatedElement.strokeColor,\n        opacity: updatedElement.opacity / 100,\n        filter: \"var(--appearance-filter)\"\n      });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\"; // prevent line wrapping on Safari\n\n  editable.wrap = \"off\";\n  editable.className = `excalidraw ${appState.appearance === \"dark\" ? \"Appearance_dark\" : \"\"}`;\n  Object.assign(editable.style, {\n    position: \"fixed\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace: \"pre\"\n  });\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = event => {\n    if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && !event.altKey) {\n      event.stopPropagation();\n    }\n  };\n\n  const stopEvent = event => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleSubmit = () => {\n    onSubmit(normalizeText(editable.value));\n    cleanup();\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n\n    isDestroyed = true; // remove events to ensure they don't late-fire\n\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", rebindBlur);\n    window.removeEventListener(\"blur\", handleSubmit);\n    unbindUpdate();\n    document.body.removeChild(editable);\n  };\n\n  const rebindBlur = () => {\n    window.removeEventListener(\"pointerup\", rebindBlur); // deferred to guard against focus traps on various UIs that steal focus\n    // upon pointerUp\n\n    setTimeout(() => {\n      editable.onblur = handleSubmit; // case: clicking on the same property → no change → no update → no focus\n\n      editable.focus();\n    });\n  }; // prevent blur when changing properties from the menu\n\n\n  const onPointerDown = event => {\n    if (event.target instanceof HTMLElement && event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) && !isWritableElement(event.target)) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", rebindBlur); // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  }; // handle updates of textElement properties of editing element\n\n\n  const unbindUpdate = Scene.getScene(element).addCallback(() => {\n    updateWysiwygStyle();\n    editable.focus();\n  });\n  let isDestroyed = false;\n  editable.onblur = handleSubmit; // reposition wysiwyg in case of window resize. Happens on mobile when\n  // device keyboard is opened.\n\n  window.addEventListener(\"resize\", updateWysiwygStyle);\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true\n  });\n  document.body.appendChild(editable);\n  editable.focus();\n  editable.select();\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/textWysiwyg.tsx"],"names":["KEYS","isWritableElement","getFontString","Scene","isTextElement","CLASSES","normalizeText","text","replace","getTransform","width","height","angle","appState","zoom","offsetTop","offsetLeft","degree","Math","PI","value","textWysiwyg","id","onChange","onSubmit","getViewportCoords","element","updateWysiwygStyle","updatedElement","getScene","getElement","viewportX","viewportY","x","y","textAlign","editable","lines","split","lineHeight","length","Object","assign","style","font","left","top","transform","color","strokeColor","opacity","filter","document","createElement","dir","tabIndex","dataset","type","wrap","className","appearance","position","display","minHeight","backfaceVisibility","margin","padding","border","outline","resize","background","overflow","whiteSpace","oninput","onkeydown","event","key","ESCAPE","preventDefault","handleSubmit","ENTER","CTRL_OR_CMD","isComposing","keyCode","altKey","stopPropagation","stopEvent","cleanup","isDestroyed","onblur","window","removeEventListener","onPointerDown","rebindBlur","unbindUpdate","body","removeChild","setTimeout","focus","target","HTMLElement","closest","SHAPE_ACTIONS_MENU","addEventListener","addCallback","passive","capture","appendChild","select"],"mappings":"AAAA,SAASA,IAAT,QAAqB,SAArB;AACA,SAASC,iBAAT,EAA4BC,aAA5B,QAAiD,UAAjD;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,SAASC,OAAT,QAAwB,cAAxB;;AAIA,MAAMC,aAAa,GAAIC,IAAD,IAAkB;AACtC,SACEA,IAAI,CACF;AADE,GAEDC,OAFH,CAEW,KAFX,EAEkB,UAFlB,EAGE;AAHF,GAIGA,OAJH,CAIW,WAJX,EAIwB,IAJxB,CADF;AAOD,CARD;;AAUA,MAAMC,YAAY,GAAG,CACnBC,KADmB,EAEnBC,MAFmB,EAGnBC,KAHmB,EAInBC,QAJmB,KAKhB;AACH,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,SAAR;AAAmBC,IAAAA;AAAnB,MAAkCH,QAAxC;AACA,QAAMI,MAAM,GAAI,MAAML,KAAP,GAAgBM,IAAI,CAACC,EAApC,CAFG,CAGH;AACA;;AACA,SAAQ,aAAa,CAACT,KAAK,GAAGM,UAAU,GAAG,CAAtB,KAA4BF,IAAI,CAACM,KAAL,GAAa,CAAzC,CAAD,GAAgD,CAAE,OACnE,CAACT,MAAM,GAAGI,SAAS,GAAG,CAAtB,KAA4BD,IAAI,CAACM,KAAL,GAAa,CAAzC,CAAD,GAAgD,CACjD,aAAYN,IAAI,CAACM,KAAM,YAAWH,MAAO,MAF1C;AAGD,CAbD;;AAeA,OAAO,MAAMI,WAAW,GAAG,CAAC;AAC1BC,EAAAA,EAD0B;AAE1BT,EAAAA,QAF0B;AAG1BU,EAAAA,QAH0B;AAI1BC,EAAAA,QAJ0B;AAK1BC,EAAAA,iBAL0B;AAM1BC,EAAAA;AAN0B,CAAD,KAcrB;AACJ,QAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAC/B,UAAMC,cAAc,sBAAGzB,KAAK,CAAC0B,QAAN,CAAeH,OAAf,CAAH,oDAAG,gBAAyBI,UAAzB,CAAoCR,EAApC,CAAvB;;AACA,QAAIM,cAAc,IAAIxB,aAAa,CAACwB,cAAD,CAAnC,EAAqD;AACnD,YAAM,CAACG,SAAD,EAAYC,SAAZ,IAAyBP,iBAAiB,CAC9CG,cAAc,CAACK,CAD+B,EAE9CL,cAAc,CAACM,CAF+B,CAAhD;AAIA,YAAM;AAAEC,QAAAA,SAAF;AAAavB,QAAAA;AAAb,UAAuBgB,cAA7B;AAEAQ,MAAAA,QAAQ,CAAChB,KAAT,GAAiBQ,cAAc,CAACrB,IAAhC;AAEA,YAAM8B,KAAK,GAAGT,cAAc,CAACrB,IAAf,CAAoBC,OAApB,CAA4B,QAA5B,EAAsC,IAAtC,EAA4C8B,KAA5C,CAAkD,IAAlD,CAAd;AACA,YAAMC,UAAU,GAAGX,cAAc,CAACjB,MAAf,GAAwB0B,KAAK,CAACG,MAAjD;AAEAC,MAAAA,MAAM,CAACC,MAAP,CAAcN,QAAQ,CAACO,KAAvB,EAA8B;AAC5BC,QAAAA,IAAI,EAAE1C,aAAa,CAAC0B,cAAD,CADS;AAE5B;AACAW,QAAAA,UAAU,EAAG,GAAEA,UAAW,IAHE;AAI5B7B,QAAAA,KAAK,EAAG,GAAEkB,cAAc,CAAClB,KAAM,IAJH;AAK5BC,QAAAA,MAAM,EAAG,GAAEiB,cAAc,CAACjB,MAAO,IALL;AAM5BkC,QAAAA,IAAI,EAAG,GAAEd,SAAU,IANS;AAO5Be,QAAAA,GAAG,EAAG,GAAEd,SAAU,IAPU;AAQ5Be,QAAAA,SAAS,EAAEtC,YAAY,CACrBmB,cAAc,CAAClB,KADM,EAErBkB,cAAc,CAACjB,MAFM,EAGrBC,KAHqB,EAIrBC,QAJqB,CARK;AAc5BsB,QAAAA,SAd4B;AAe5Ba,QAAAA,KAAK,EAAEpB,cAAc,CAACqB,WAfM;AAgB5BC,QAAAA,OAAO,EAAEtB,cAAc,CAACsB,OAAf,GAAyB,GAhBN;AAiB5BC,QAAAA,MAAM,EAAE;AAjBoB,OAA9B;AAmBD;AACF,GAlCD;;AAoCA,QAAMf,QAAQ,GAAGgB,QAAQ,CAACC,aAAT,CAAuB,UAAvB,CAAjB;AAEAjB,EAAAA,QAAQ,CAACkB,GAAT,GAAe,MAAf;AACAlB,EAAAA,QAAQ,CAACmB,QAAT,GAAoB,CAApB;AACAnB,EAAAA,QAAQ,CAACoB,OAAT,CAAiBC,IAAjB,GAAwB,SAAxB,CAzCI,CA0CJ;;AACArB,EAAAA,QAAQ,CAACsB,IAAT,GAAgB,KAAhB;AACAtB,EAAAA,QAAQ,CAACuB,SAAT,GAAsB,cACpB9C,QAAQ,CAAC+C,UAAT,KAAwB,MAAxB,GAAiC,iBAAjC,GAAqD,EACtD,EAFD;AAIAnB,EAAAA,MAAM,CAACC,MAAP,CAAcN,QAAQ,CAACO,KAAvB,EAA8B;AAC5BkB,IAAAA,QAAQ,EAAE,OADkB;AAE5BC,IAAAA,OAAO,EAAE,cAFmB;AAG5BC,IAAAA,SAAS,EAAE,KAHiB;AAI5BC,IAAAA,kBAAkB,EAAE,QAJQ;AAK5BC,IAAAA,MAAM,EAAE,CALoB;AAM5BC,IAAAA,OAAO,EAAE,CANmB;AAO5BC,IAAAA,MAAM,EAAE,CAPoB;AAQ5BC,IAAAA,OAAO,EAAE,CARmB;AAS5BC,IAAAA,MAAM,EAAE,MAToB;AAU5BC,IAAAA,UAAU,EAAE,aAVgB;AAW5BC,IAAAA,QAAQ,EAAE,QAXkB;AAY5B;AACAC,IAAAA,UAAU,EAAE;AAbgB,GAA9B;AAgBA7C,EAAAA,kBAAkB;;AAElB,MAAIJ,QAAJ,EAAc;AACZa,IAAAA,QAAQ,CAACqC,OAAT,GAAmB,MAAM;AACvBlD,MAAAA,QAAQ,CAACjB,aAAa,CAAC8B,QAAQ,CAAChB,KAAV,CAAd,CAAR;AACD,KAFD;AAGD;;AAEDgB,EAAAA,QAAQ,CAACsC,SAAT,GAAsBC,KAAD,IAAW;AAC9B,QAAIA,KAAK,CAACC,GAAN,KAAc5E,IAAI,CAAC6E,MAAvB,EAA+B;AAC7BF,MAAAA,KAAK,CAACG,cAAN;AACAC,MAAAA,YAAY;AACb,KAHD,MAGO,IAAIJ,KAAK,CAACC,GAAN,KAAc5E,IAAI,CAACgF,KAAnB,IAA4BL,KAAK,CAAC3E,IAAI,CAACiF,WAAN,CAArC,EAAyD;AAC9DN,MAAAA,KAAK,CAACG,cAAN;;AACA,UAAIH,KAAK,CAACO,WAAN,IAAqBP,KAAK,CAACQ,OAAN,KAAkB,GAA3C,EAAgD;AAC9C;AACD;;AACDJ,MAAAA,YAAY;AACb,KANM,MAMA,IAAIJ,KAAK,CAACC,GAAN,KAAc5E,IAAI,CAACgF,KAAnB,IAA4B,CAACL,KAAK,CAACS,MAAvC,EAA+C;AACpDT,MAAAA,KAAK,CAACU,eAAN;AACD;AACF,GAbD;;AAeA,QAAMC,SAAS,GAAIX,KAAD,IAAkB;AAClCA,IAAAA,KAAK,CAACG,cAAN;AACAH,IAAAA,KAAK,CAACU,eAAN;AACD,GAHD;;AAKA,QAAMN,YAAY,GAAG,MAAM;AACzBvD,IAAAA,QAAQ,CAAClB,aAAa,CAAC8B,QAAQ,CAAChB,KAAV,CAAd,CAAR;AACAmE,IAAAA,OAAO;AACR,GAHD;;AAKA,QAAMA,OAAO,GAAG,MAAM;AACpB,QAAIC,WAAJ,EAAiB;AACf;AACD;;AACDA,IAAAA,WAAW,GAAG,IAAd,CAJoB,CAKpB;;AACApD,IAAAA,QAAQ,CAACqD,MAAT,GAAkB,IAAlB;AACArD,IAAAA,QAAQ,CAACqC,OAAT,GAAmB,IAAnB;AACArC,IAAAA,QAAQ,CAACsC,SAAT,GAAqB,IAArB;AAEAgB,IAAAA,MAAM,CAACC,mBAAP,CAA2B,QAA3B,EAAqChE,kBAArC;AACA+D,IAAAA,MAAM,CAACC,mBAAP,CAA2B,OAA3B,EAAoCL,SAApC,EAA+C,IAA/C;AACAI,IAAAA,MAAM,CAACC,mBAAP,CAA2B,aAA3B,EAA0CC,aAA1C;AACAF,IAAAA,MAAM,CAACC,mBAAP,CAA2B,WAA3B,EAAwCE,UAAxC;AACAH,IAAAA,MAAM,CAACC,mBAAP,CAA2B,MAA3B,EAAmCZ,YAAnC;AAEAe,IAAAA,YAAY;AAEZ1C,IAAAA,QAAQ,CAAC2C,IAAT,CAAcC,WAAd,CAA0B5D,QAA1B;AACD,GAnBD;;AAqBA,QAAMyD,UAAU,GAAG,MAAM;AACvBH,IAAAA,MAAM,CAACC,mBAAP,CAA2B,WAA3B,EAAwCE,UAAxC,EADuB,CAEvB;AACA;;AACAI,IAAAA,UAAU,CAAC,MAAM;AACf7D,MAAAA,QAAQ,CAACqD,MAAT,GAAkBV,YAAlB,CADe,CAEf;;AACA3C,MAAAA,QAAQ,CAAC8D,KAAT;AACD,KAJS,CAAV;AAKD,GATD,CAtHI,CAiIJ;;;AACA,QAAMN,aAAa,GAAIjB,KAAD,IAAuB;AAC3C,QACEA,KAAK,CAACwB,MAAN,YAAwBC,WAAxB,IACAzB,KAAK,CAACwB,MAAN,CAAaE,OAAb,CAAsB,IAAGhG,OAAO,CAACiG,kBAAmB,EAApD,CADA,IAEA,CAACrG,iBAAiB,CAAC0E,KAAK,CAACwB,MAAP,CAHpB,EAIE;AACA/D,MAAAA,QAAQ,CAACqD,MAAT,GAAkB,IAAlB;AACAC,MAAAA,MAAM,CAACa,gBAAP,CAAwB,WAAxB,EAAqCV,UAArC,EAFA,CAGA;AACA;;AACAH,MAAAA,MAAM,CAACa,gBAAP,CAAwB,MAAxB,EAAgCxB,YAAhC;AACD;AACF,GAZD,CAlII,CAgJJ;;;AACA,QAAMe,YAAY,GAAG3F,KAAK,CAAC0B,QAAN,CAAeH,OAAf,EAAyB8E,WAAzB,CAAqC,MAAM;AAC9D7E,IAAAA,kBAAkB;AAClBS,IAAAA,QAAQ,CAAC8D,KAAT;AACD,GAHoB,CAArB;AAKA,MAAIV,WAAW,GAAG,KAAlB;AAEApD,EAAAA,QAAQ,CAACqD,MAAT,GAAkBV,YAAlB,CAxJI,CAyJJ;AACA;;AACAW,EAAAA,MAAM,CAACa,gBAAP,CAAwB,QAAxB,EAAkC5E,kBAAlC;AACA+D,EAAAA,MAAM,CAACa,gBAAP,CAAwB,aAAxB,EAAuCX,aAAvC;AACAF,EAAAA,MAAM,CAACa,gBAAP,CAAwB,OAAxB,EAAiCjB,SAAjC,EAA4C;AAC1CmB,IAAAA,OAAO,EAAE,KADiC;AAE1CC,IAAAA,OAAO,EAAE;AAFiC,GAA5C;AAIAtD,EAAAA,QAAQ,CAAC2C,IAAT,CAAcY,WAAd,CAA0BvE,QAA1B;AACAA,EAAAA,QAAQ,CAAC8D,KAAT;AACA9D,EAAAA,QAAQ,CAACwE,MAAT;AACD,CAlLM","sourcesContent":["import { KEYS } from \"../keys\";\nimport { isWritableElement, getFontString } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \"./typeChecks\";\nimport { CLASSES } from \"../constants\";\nimport { ExcalidrawElement } from \"./types\";\nimport { AppState } from \"../types\";\n\nconst normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n) => {\n  const { zoom, offsetTop, offsetLeft } = appState;\n  const degree = (180 * angle) / Math.PI;\n  // offsets must be multiplied by 2 to account for the division by 2 of\n  // the whole expression afterwards\n  return `translate(${((width - offsetLeft * 2) * (zoom.value - 1)) / 2}px, ${\n    ((height - offsetTop * 2) * (zoom.value - 1)) / 2\n  }px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nexport const textWysiwyg = ({\n  id,\n  appState,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  appState: AppState;\n  onChange?: (text: string) => void;\n  onSubmit: (text: string) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawElement;\n}) => {\n  const updateWysiwygStyle = () => {\n    const updatedElement = Scene.getScene(element)?.getElement(id);\n    if (updatedElement && isTextElement(updatedElement)) {\n      const [viewportX, viewportY] = getViewportCoords(\n        updatedElement.x,\n        updatedElement.y,\n      );\n      const { textAlign, angle } = updatedElement;\n\n      editable.value = updatedElement.text;\n\n      const lines = updatedElement.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n      const lineHeight = updatedElement.height / lines.length;\n\n      Object.assign(editable.style, {\n        font: getFontString(updatedElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight: `${lineHeight}px`,\n        width: `${updatedElement.width}px`,\n        height: `${updatedElement.height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          updatedElement.width,\n          updatedElement.height,\n          angle,\n          appState,\n        ),\n        textAlign,\n        color: updatedElement.strokeColor,\n        opacity: updatedElement.opacity / 100,\n        filter: \"var(--appearance-filter)\",\n      });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n  editable.className = `excalidraw ${\n    appState.appearance === \"dark\" ? \"Appearance_dark\" : \"\"\n  }`;\n\n  Object.assign(editable.style, {\n    position: \"fixed\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace: \"pre\",\n  });\n\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && !event.altKey) {\n      event.stopPropagation();\n    }\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleSubmit = () => {\n    onSubmit(normalizeText(editable.value));\n    cleanup();\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", rebindBlur);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    document.body.removeChild(editable);\n  };\n\n  const rebindBlur = () => {\n    window.removeEventListener(\"pointerup\", rebindBlur);\n    // deferred to guard against focus traps on various UIs that steal focus\n    // upon pointerUp\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n      // case: clicking on the same property → no change → no update → no focus\n      editable.focus();\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    if (\n      event.target instanceof HTMLElement &&\n      event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n      !isWritableElement(event.target)\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", rebindBlur);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    editable.focus();\n  });\n\n  let isDestroyed = false;\n\n  editable.onblur = handleSubmit;\n  // reposition wysiwyg in case of window resize. Happens on mobile when\n  // device keyboard is opened.\n  window.addEventListener(\"resize\", updateWysiwygStyle);\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  document.body.appendChild(editable);\n  editable.focus();\n  editable.select();\n};\n"]},"metadata":{},"sourceType":"module"}