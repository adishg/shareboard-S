{"ast":null,"code":"import * as GA from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n// Returns line with direction (x, y) through origin\nexport const vector = (x, y) => GA.normalized([0, 0, -y, x, 0, 0, 0, 0]); // For equation ax + by + c = 0.\n\nexport const equation = (a, b, c) => GA.normalized([0, c, a, b, 0, 0, 0, 0]);\nexport const through = (from, to) => GA.normalized(GA.join(to, from));\nexport const orthogonal = (line, point) => GA.dot(line, point); // Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\n\nexport const orthogonalThrough = (against, intersection) => orthogonal(through(against, intersection), intersection);\nexport const parallel = (line, distance) => {\n  const result = line.slice();\n  result[1] -= distance;\n  return result;\n};\nexport const parallelThrough = (line, point) => orthogonal(orthogonal(point, line), point);\nexport const distance = (line1, line2) => GA.inorm(GA.meet(line1, line2));\nexport const angle = (line1, line2) => Math.acos(GA.dot(line1, line2)[0]); // The orientation of the line\n\nexport const sign = line => Math.sign(line[1]);","map":{"version":3,"sources":["/var/www/html/excalidraw/src/galines.ts"],"names":["GA","vector","x","y","normalized","equation","a","b","c","through","from","to","join","orthogonal","line","point","dot","orthogonalThrough","against","intersection","parallel","distance","result","slice","parallelThrough","line1","line2","inorm","meet","angle","Math","acos","sign"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,MAApB;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,OAAO,MAAMC,MAAM,GAAG,CAACC,CAAD,EAAYC,CAAZ,KACpBH,EAAE,CAACI,UAAH,CAAc,CAAC,CAAD,EAAI,CAAJ,EAAO,CAACD,CAAR,EAAWD,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAAd,CADK,C,CAGP;;AACA,OAAO,MAAMG,QAAQ,GAAG,CAACC,CAAD,EAAYC,CAAZ,EAAuBC,CAAvB,KACtBR,EAAE,CAACI,UAAH,CAAc,CAAC,CAAD,EAAII,CAAJ,EAAOF,CAAP,EAAUC,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAd,CADK;AAGP,OAAO,MAAME,OAAO,GAAG,CAACC,IAAD,EAAcC,EAAd,KACrBX,EAAE,CAACI,UAAH,CAAcJ,EAAE,CAACY,IAAH,CAAQD,EAAR,EAAYD,IAAZ,CAAd,CADK;AAGP,OAAO,MAAMG,UAAU,GAAG,CAACC,IAAD,EAAaC,KAAb,KACxBf,EAAE,CAACgB,GAAH,CAAOF,IAAP,EAAaC,KAAb,CADK,C,CAGP;AACA;;AACA,OAAO,MAAME,iBAAiB,GAAG,CAACC,OAAD,EAAiBC,YAAjB,KAC/BN,UAAU,CAACJ,OAAO,CAACS,OAAD,EAAUC,YAAV,CAAR,EAAiCA,YAAjC,CADL;AAGP,OAAO,MAAMC,QAAQ,GAAG,CAACN,IAAD,EAAaO,QAAb,KAAwC;AAC9D,QAAMC,MAAM,GAAGR,IAAI,CAACS,KAAL,EAAf;AACAD,EAAAA,MAAM,CAAC,CAAD,CAAN,IAAaD,QAAb;AACA,SAAQC,MAAR;AACD,CAJM;AAMP,OAAO,MAAME,eAAe,GAAG,CAACV,IAAD,EAAaC,KAAb,KAC7BF,UAAU,CAACA,UAAU,CAACE,KAAD,EAAQD,IAAR,CAAX,EAA0BC,KAA1B,CADL;AAGP,OAAO,MAAMM,QAAQ,GAAG,CAACI,KAAD,EAAcC,KAAd,KACtB1B,EAAE,CAAC2B,KAAH,CAAS3B,EAAE,CAAC4B,IAAH,CAAQH,KAAR,EAAeC,KAAf,CAAT,CADK;AAGP,OAAO,MAAMG,KAAK,GAAG,CAACJ,KAAD,EAAcC,KAAd,KACnBI,IAAI,CAACC,IAAL,CAAU/B,EAAE,CAACgB,GAAH,CAAOS,KAAP,EAAcC,KAAd,EAAqB,CAArB,CAAV,CADK,C,CAGP;;AACA,OAAO,MAAMM,IAAI,GAAIlB,IAAD,IAAwBgB,IAAI,CAACE,IAAL,CAAUlB,IAAI,CAAC,CAAD,CAAd,CAArC","sourcesContent":["import * as GA from \"./ga\";\nimport { Line, Point } from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n\n// Returns line with direction (x, y) through origin\nexport const vector = (x: number, y: number): Line =>\n  GA.normalized([0, 0, -y, x, 0, 0, 0, 0]);\n\n// For equation ax + by + c = 0.\nexport const equation = (a: number, b: number, c: number): Line =>\n  GA.normalized([0, c, a, b, 0, 0, 0, 0]);\n\nexport const through = (from: Point, to: Point): Line =>\n  GA.normalized(GA.join(to, from));\n\nexport const orthogonal = (line: Line, point: Point): Line =>\n  GA.dot(line, point);\n\n// Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\nexport const orthogonalThrough = (against: Point, intersection: Point): Line =>\n  orthogonal(through(against, intersection), intersection);\n\nexport const parallel = (line: Line, distance: number): Line => {\n  const result = line.slice();\n  result[1] -= distance;\n  return (result as unknown) as Line;\n};\n\nexport const parallelThrough = (line: Line, point: Point): Line =>\n  orthogonal(orthogonal(point, line), point);\n\nexport const distance = (line1: Line, line2: Line): number =>\n  GA.inorm(GA.meet(line1, line2));\n\nexport const angle = (line1: Line, line2: Line): number =>\n  Math.acos(GA.dot(line1, line2)[0]);\n\n// The orientation of the line\nexport const sign = (line: Line): number => Math.sign(line[1]);\n"]},"metadata":{},"sourceType":"module"}