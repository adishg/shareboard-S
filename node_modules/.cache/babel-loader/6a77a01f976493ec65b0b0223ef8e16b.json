{"ast":null,"code":"import { lineLength, lineIntersection, doIntersect, isPointInPolygon } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n  constructor(helper) {\n    this.helper = helper;\n  }\n\n  fillPolygon(points, o) {\n    return this._fillPolygon(points, o);\n  }\n\n  _fillPolygon(points, o, connectEnds = false) {\n    let lines = polygonHachureLines(points, o);\n\n    if (connectEnds) {\n      const connectingLines = this.connectingLines(points, lines);\n      lines = lines.concat(connectingLines);\n    }\n\n    const ops = this.renderLines(lines, o);\n    return {\n      type: 'fillSketch',\n      ops\n    };\n  }\n\n  renderLines(lines, o) {\n    const ops = [];\n\n    for (const line of lines) {\n      ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n    }\n\n    return ops;\n  }\n\n  connectingLines(polygon, lines) {\n    const result = [];\n\n    if (lines.length > 1) {\n      for (let i = 1; i < lines.length; i++) {\n        const prev = lines[i - 1];\n\n        if (lineLength(prev) < 3) {\n          continue;\n        }\n\n        const current = lines[i];\n        const segment = [current[0], prev[1]];\n\n        if (lineLength(segment) > 3) {\n          const segSplits = this.splitOnIntersections(polygon, segment);\n          result.push(...segSplits);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  midPointInPolygon(polygon, segment) {\n    return isPointInPolygon(polygon, (segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2);\n  }\n\n  splitOnIntersections(polygon, segment) {\n    const error = Math.max(5, lineLength(segment) * 0.1);\n    const intersections = [];\n\n    for (let i = 0; i < polygon.length; i++) {\n      const p1 = polygon[i];\n      const p2 = polygon[(i + 1) % polygon.length];\n\n      if (doIntersect(p1, p2, ...segment)) {\n        const ip = lineIntersection(p1, p2, segment[0], segment[1]);\n\n        if (ip) {\n          const d0 = lineLength([ip, segment[0]]);\n          const d1 = lineLength([ip, segment[1]]);\n\n          if (d0 > error && d1 > error) {\n            intersections.push({\n              point: ip,\n              distance: d0\n            });\n          }\n        }\n      }\n    }\n\n    if (intersections.length > 1) {\n      const ips = intersections.sort((a, b) => a.distance - b.distance).map(d => d.point);\n\n      if (!isPointInPolygon(polygon, ...segment[0])) {\n        ips.shift();\n      }\n\n      if (!isPointInPolygon(polygon, ...segment[1])) {\n        ips.pop();\n      }\n\n      if (ips.length <= 1) {\n        if (this.midPointInPolygon(polygon, segment)) {\n          return [segment];\n        } else {\n          return [];\n        }\n      }\n\n      const spoints = [segment[0], ...ips, segment[1]];\n      const slines = [];\n\n      for (let i = 0; i < spoints.length - 1; i += 2) {\n        const subSegment = [spoints[i], spoints[i + 1]];\n\n        if (this.midPointInPolygon(polygon, subSegment)) {\n          slines.push(subSegment);\n        }\n      }\n\n      return slines;\n    } else if (this.midPointInPolygon(polygon, segment)) {\n      return [segment];\n    } else {\n      return [];\n    }\n  }\n\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/roughjs/bin/fillers/hachure-filler.js"],"names":["lineLength","lineIntersection","doIntersect","isPointInPolygon","polygonHachureLines","HachureFiller","constructor","helper","fillPolygon","points","o","_fillPolygon","connectEnds","lines","connectingLines","concat","ops","renderLines","type","line","push","doubleLineOps","polygon","result","length","i","prev","current","segment","segSplits","splitOnIntersections","midPointInPolygon","error","Math","max","intersections","p1","p2","ip","d0","d1","point","distance","ips","sort","a","b","map","d","shift","pop","spoints","slines","subSegment"],"mappings":"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","sourcesContent":["import { lineLength, lineIntersection, doIntersect, isPointInPolygon } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o);\n    }\n    _fillPolygon(points, o, connectEnds = false) {\n        let lines = polygonHachureLines(points, o);\n        if (connectEnds) {\n            const connectingLines = this.connectingLines(points, lines);\n            lines = lines.concat(connectingLines);\n        }\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n    connectingLines(polygon, lines) {\n        const result = [];\n        if (lines.length > 1) {\n            for (let i = 1; i < lines.length; i++) {\n                const prev = lines[i - 1];\n                if (lineLength(prev) < 3) {\n                    continue;\n                }\n                const current = lines[i];\n                const segment = [current[0], prev[1]];\n                if (lineLength(segment) > 3) {\n                    const segSplits = this.splitOnIntersections(polygon, segment);\n                    result.push(...segSplits);\n                }\n            }\n        }\n        return result;\n    }\n    midPointInPolygon(polygon, segment) {\n        return isPointInPolygon(polygon, (segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2);\n    }\n    splitOnIntersections(polygon, segment) {\n        const error = Math.max(5, lineLength(segment) * 0.1);\n        const intersections = [];\n        for (let i = 0; i < polygon.length; i++) {\n            const p1 = polygon[i];\n            const p2 = polygon[(i + 1) % polygon.length];\n            if (doIntersect(p1, p2, ...segment)) {\n                const ip = lineIntersection(p1, p2, segment[0], segment[1]);\n                if (ip) {\n                    const d0 = lineLength([ip, segment[0]]);\n                    const d1 = lineLength([ip, segment[1]]);\n                    if (d0 > error && d1 > error) {\n                        intersections.push({\n                            point: ip,\n                            distance: d0\n                        });\n                    }\n                }\n            }\n        }\n        if (intersections.length > 1) {\n            const ips = intersections.sort((a, b) => a.distance - b.distance).map((d) => d.point);\n            if (!isPointInPolygon(polygon, ...segment[0])) {\n                ips.shift();\n            }\n            if (!isPointInPolygon(polygon, ...segment[1])) {\n                ips.pop();\n            }\n            if (ips.length <= 1) {\n                if (this.midPointInPolygon(polygon, segment)) {\n                    return [segment];\n                }\n                else {\n                    return [];\n                }\n            }\n            const spoints = [segment[0], ...ips, segment[1]];\n            const slines = [];\n            for (let i = 0; i < (spoints.length - 1); i += 2) {\n                const subSegment = [spoints[i], spoints[i + 1]];\n                if (this.midPointInPolygon(polygon, subSegment)) {\n                    slines.push(subSegment);\n                }\n            }\n            return slines;\n        }\n        else if (this.midPointInPolygon(polygon, segment)) {\n            return [segment];\n        }\n        else {\n            return [];\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}