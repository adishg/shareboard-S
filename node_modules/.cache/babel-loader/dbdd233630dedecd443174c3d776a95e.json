{"ast":null,"code":"import { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\nconst transformHandleSizes = {\n  mouse: 8,\n  pen: 16,\n  touch: 28\n};\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true\n};\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true\n};\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true\n};\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true\n};\n\nconst generateTransformHandle = (x, y, width, height, cx, cy, angle) => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = ([x1, y1, x2, y2], angle, zoom, pointerType, omitSides = {}) => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const dashedLineMargin = 4 / zoom.value;\n  const centeringOffset = (size - 8) / (2 * zoom.value);\n  const transformHandles = {\n    nw: omitSides.nw ? undefined : generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    ne: omitSides.ne ? undefined : generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    sw: omitSides.sw ? undefined : generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    se: omitSides.se ? undefined : generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    rotation: omitSides.rotation ? undefined : generateTransformHandle(x1 + width / 2 - handleWidth / 2, y1 - dashedLineMargin - handleMarginY + centeringOffset - ROTATION_RESIZE_HANDLE_GAP / zoom.value, handleWidth, handleHeight, cx, cy, angle)\n  }; // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n\n  const minimumSizeForEightHandles = 5 * transformHandleSizes.mouse / zoom.value;\n\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(x1 + width / 2 - handleWidth / 2, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle);\n    }\n\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(x1 + width / 2 - handleWidth / 2, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle);\n    }\n  }\n\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y1 + height / 2 - handleHeight / 2, handleWidth, handleHeight, cx, cy, angle);\n    }\n\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y1 + height / 2 - handleHeight / 2, handleWidth, handleHeight, cx, cy, angle);\n    }\n  }\n\n  return transformHandles;\n};\nexport const getTransformHandles = (element, zoom, pointerType = \"mouse\") => {\n  let omitSides = {};\n\n  if (element.type === \"arrow\" || element.type === \"line\" || element.type === \"draw\") {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return getTransformHandlesFromCoords(getElementAbsoluteCoords(element), element.angle, zoom, pointerType, omitSides);\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/transformHandles.ts"],"names":["getElementAbsoluteCoords","rotate","transformHandleSizes","mouse","pen","touch","ROTATION_RESIZE_HANDLE_GAP","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","e","s","n","w","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","ne","sw","generateTransformHandle","x","y","width","height","cx","cy","angle","xx","yy","getTransformHandlesFromCoords","x1","y1","x2","y2","zoom","pointerType","omitSides","size","handleWidth","value","handleHeight","handleMarginX","handleMarginY","dashedLineMargin","centeringOffset","transformHandles","undefined","rotation","minimumSizeForEightHandles","Math","abs","getTransformHandles","element","type","points","length","p1"],"mappings":"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","sourcesContent":["import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords, Bounds } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { Zoom } from \"../types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = [number, number, number, number];\nexport type TransformHandles = Partial<\n  { [T in TransformHandleType]: TransformHandle }\n>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): TransformHandle => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2]: Bounds,\n  angle: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom.value;\n\n  const centeringOffset = (size - 8) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  pointerType: PointerType = \"mouse\",\n): TransformHandles => {\n  let omitSides: { [T in TransformHandleType]?: boolean } = {};\n  if (\n    element.type === \"arrow\" ||\n    element.type === \"line\" ||\n    element.type === \"draw\"\n  ) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n  );\n};\n"]},"metadata":{},"sourceType":"module"}