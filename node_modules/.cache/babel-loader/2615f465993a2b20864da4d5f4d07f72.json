{"ast":null,"code":"import { getSelectedElements } from \"./scene\";\nexport const selectGroup = (groupId, appState, elements) => {\n  const elementsInGroup = elements.filter(element => element.groupIds.includes(groupId));\n\n  if (elementsInGroup.length < 2) {\n    if (appState.selectedGroupIds[groupId] || appState.editingGroupId === groupId) {\n      return { ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds,\n          [groupId]: false\n        },\n        editingGroupId: null\n      };\n    }\n\n    return appState;\n  }\n\n  return { ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds,\n      [groupId]: true\n    },\n    selectedElementIds: { ...appState.selectedElementIds,\n      ...Object.fromEntries(elementsInGroup.map(element => [element.id, true]))\n    }\n  };\n};\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\n\nexport const isSelectedViaGroup = (appState, element) => getSelectedGroupForElement(appState, element) != null;\nexport const getSelectedGroupForElement = (appState, element) => element.groupIds.filter(groupId => groupId !== appState.editingGroupId).find(groupId => appState.selectedGroupIds[groupId]);\nexport const getSelectedGroupIds = appState => Object.entries(appState.selectedGroupIds).filter(([groupId, isSelected]) => isSelected).map(([groupId, isSelected]) => groupId);\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\n\nexport const selectGroupsForSelectedElements = (appState, elements) => {\n  let nextAppState = { ...appState\n  };\n  const selectedElements = getSelectedElements(elements, appState);\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n};\nexport const editGroupForSelectedElement = (appState, element) => {\n  return { ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true\n    }\n  };\n};\nexport const isElementInGroup = (element, groupId) => element.groupIds.includes(groupId);\nexport const getElementsInGroup = (elements, groupId) => elements.filter(element => isElementInGroup(element, groupId));\nexport const getSelectedGroupIdForElement = (element, selectedGroupIds) => element.groupIds.find(groupId => selectedGroupIds[groupId]);\nexport const getNewGroupIdsForDuplication = (groupIds, editingGroupId, mapper) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;\n  const endIndex = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\nexport const addToGroup = (prevGroupIds, newGroupId, editingGroupId) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;\n  const positionToInsert = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\nexport const removeFromSelectedGroups = (groupIds, selectedGroupIds) => groupIds.filter(groupId => !selectedGroupIds[groupId]);","map":{"version":3,"sources":["/var/www/html/excalidraw/src/groups.ts"],"names":["getSelectedElements","selectGroup","groupId","appState","elements","elementsInGroup","filter","element","groupIds","includes","length","selectedGroupIds","editingGroupId","selectedElementIds","Object","fromEntries","map","id","isSelectedViaGroup","getSelectedGroupForElement","find","getSelectedGroupIds","entries","isSelected","selectGroupsForSelectedElements","nextAppState","selectedElements","selectedElement","indexOfEditingGroup","indexOf","slice","editGroupForSelectedElement","isElementInGroup","getElementsInGroup","getSelectedGroupIdForElement","getNewGroupIdsForDuplication","mapper","copy","positionOfEditingGroupId","endIndex","index","addToGroup","prevGroupIds","newGroupId","positionToInsert","splice","removeFromSelectedGroups"],"mappings":"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","sourcesContent":["import { GroupId, ExcalidrawElement, NonDeleted } from \"./element/types\";\nimport { AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (appState: AppState): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  let nextAppState = { ...appState };\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) => elements.filter((element) => isElementInGroup(element, groupId));\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n"]},"metadata":{},"sourceType":"module"}