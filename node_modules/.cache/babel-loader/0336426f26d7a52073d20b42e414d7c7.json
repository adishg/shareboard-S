{"ast":null,"code":"import { loadLibraryFromBlob } from \"./blob\";\nimport { restoreElements } from \"./restore\";\nimport { STORAGE_KEYS } from \"../constants\";\nimport { getNonDeletedElements } from \"../element\";\nexport class Library {\n  /** imports library (currently merges, removing duplicates) */\n  static async importLibrary(blob) {\n    const libraryFile = await loadLibraryFromBlob(blob);\n\n    if (!libraryFile || !libraryFile.library) {\n      return;\n    }\n    /**\n     * checks if library item does not exist already in current library\n     */\n\n\n    const isUniqueitem = (existingLibraryItems, targetLibraryItem) => {\n      return !existingLibraryItems.find(libraryItem => {\n        if (libraryItem.length !== targetLibraryItem.length) {\n          return false;\n        } // detect z-index difference by checking the excalidraw elements\n        // are in order\n\n\n        return libraryItem.every((libItemExcalidrawItem, idx) => {\n          return libItemExcalidrawItem.id === targetLibraryItem[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem[idx].versionNonce;\n        });\n      });\n    };\n\n    const existingLibraryItems = await Library.loadLibrary();\n    const filtered = libraryFile.library.reduce((acc, libraryItem) => {\n      const restored = getNonDeletedElements(restoreElements(libraryItem));\n\n      if (isUniqueitem(existingLibraryItems, restored)) {\n        acc.push(restored);\n      }\n\n      return acc;\n    }, []);\n    Library.saveLibrary([...existingLibraryItems, ...filtered]);\n  }\n\n}\nLibrary.libraryCache = null;\n\nLibrary.resetLibrary = () => {\n  Library.libraryCache = null;\n  localStorage.removeItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n};\n\nLibrary.loadLibrary = () => {\n  return new Promise(async resolve => {\n    if (Library.libraryCache) {\n      return resolve(JSON.parse(JSON.stringify(Library.libraryCache)));\n    }\n\n    try {\n      const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n\n      if (!data) {\n        return resolve([]);\n      }\n\n      const items = JSON.parse(data).map(elements => restoreElements(elements)); // clone to ensure we don't mutate the cached library elements in the app\n\n      Library.libraryCache = JSON.parse(JSON.stringify(items));\n      resolve(items);\n    } catch (error) {\n      console.error(error);\n      resolve([]);\n    }\n  });\n};\n\nLibrary.saveLibrary = items => {\n  const prevLibraryItems = Library.libraryCache;\n\n  try {\n    const serializedItems = JSON.stringify(items); // cache optimistically so that consumers have access to the latest\n    // immediately\n\n    Library.libraryCache = JSON.parse(serializedItems);\n    localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY, serializedItems);\n  } catch (error) {\n    Library.libraryCache = prevLibraryItems;\n    console.error(error);\n  }\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/data/library.ts"],"names":["loadLibraryFromBlob","restoreElements","STORAGE_KEYS","getNonDeletedElements","Library","importLibrary","blob","libraryFile","library","isUniqueitem","existingLibraryItems","targetLibraryItem","find","libraryItem","length","every","libItemExcalidrawItem","idx","id","versionNonce","loadLibrary","filtered","reduce","acc","restored","push","saveLibrary","libraryCache","resetLibrary","localStorage","removeItem","LOCAL_STORAGE_LIBRARY","Promise","resolve","JSON","parse","stringify","data","getItem","items","map","elements","error","console","prevLibraryItems","serializedItems","setItem"],"mappings":"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","sourcesContent":["import { loadLibraryFromBlob } from \"./blob\";\nimport { LibraryItems, LibraryItem } from \"../types\";\nimport { restoreElements } from \"./restore\";\nimport { STORAGE_KEYS } from \"../constants\";\nimport { getNonDeletedElements } from \"../element\";\nimport { NonDeleted, ExcalidrawElement } from \"../element/types\";\n\nexport class Library {\n  private static libraryCache: LibraryItems | null = null;\n\n  static resetLibrary = () => {\n    Library.libraryCache = null;\n    localStorage.removeItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n  };\n\n  /** imports library (currently merges, removing duplicates) */\n  static async importLibrary(blob: Blob) {\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      return;\n    }\n\n    /**\n     * checks if library item does not exist already in current library\n     */\n    const isUniqueitem = (\n      existingLibraryItems: LibraryItems,\n      targetLibraryItem: LibraryItem,\n    ) => {\n      return !existingLibraryItems.find((libraryItem) => {\n        if (libraryItem.length !== targetLibraryItem.length) {\n          return false;\n        }\n\n        // detect z-index difference by checking the excalidraw elements\n        // are in order\n        return libraryItem.every((libItemExcalidrawItem, idx) => {\n          return (\n            libItemExcalidrawItem.id === targetLibraryItem[idx].id &&\n            libItemExcalidrawItem.versionNonce ===\n              targetLibraryItem[idx].versionNonce\n          );\n        });\n      });\n    };\n\n    const existingLibraryItems = await Library.loadLibrary();\n\n    const filtered = libraryFile.library!.reduce((acc, libraryItem) => {\n      const restored = getNonDeletedElements(restoreElements(libraryItem));\n      if (isUniqueitem(existingLibraryItems, restored)) {\n        acc.push(restored);\n      }\n      return acc;\n    }, [] as (readonly NonDeleted<ExcalidrawElement>[])[]);\n\n    Library.saveLibrary([...existingLibraryItems, ...filtered]);\n  }\n\n  static loadLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      if (Library.libraryCache) {\n        return resolve(JSON.parse(JSON.stringify(Library.libraryCache)));\n      }\n\n      try {\n        const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n        if (!data) {\n          return resolve([]);\n        }\n\n        const items = (JSON.parse(data) as LibraryItems).map((elements) =>\n          restoreElements(elements),\n        ) as Mutable<LibraryItems>;\n\n        // clone to ensure we don't mutate the cached library elements in the app\n        Library.libraryCache = JSON.parse(JSON.stringify(items));\n\n        resolve(items);\n      } catch (error) {\n        console.error(error);\n        resolve([]);\n      }\n    });\n  };\n\n  static saveLibrary = (items: LibraryItems) => {\n    const prevLibraryItems = Library.libraryCache;\n    try {\n      const serializedItems = JSON.stringify(items);\n      // cache optimistically so that consumers have access to the latest\n      // immediately\n      Library.libraryCache = JSON.parse(serializedItems);\n      localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY, serializedItems);\n    } catch (error) {\n      Library.libraryCache = prevLibraryItems;\n      console.error(error);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}