{"ast":null,"code":"// distance between 2 points\nfunction distance(p1, p2) {\n  return Math.sqrt(distanceSq(p1, p2));\n} // distance between 2 points squared\n\n\nfunction distanceSq(p1, p2) {\n  return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n} // Sistance squared from a point p to the line segment vw\n\n\nfunction distanceToSegmentSq(p, v, w) {\n  const l2 = distanceSq(v, w);\n\n  if (l2 === 0) {\n    return distanceSq(p, v);\n  }\n\n  let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return distanceSq(p, lerp(v, w, t));\n}\n\nfunction lerp(a, b, t) {\n  return [a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t];\n} // Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\n\n\nfunction flatness(points, offset) {\n  const p1 = points[offset + 0];\n  const p2 = points[offset + 1];\n  const p3 = points[offset + 2];\n  const p4 = points[offset + 3];\n  let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n  ux *= ux;\n  let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n  uy *= uy;\n  let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n  vx *= vx;\n  let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n  vy *= vy;\n\n  if (ux < vx) {\n    ux = vx;\n  }\n\n  if (uy < vy) {\n    uy = vy;\n  }\n\n  return ux + uy;\n}\n\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n  const outPoints = newPoints || [];\n\n  if (flatness(points, offset) < tolerance) {\n    const p0 = points[offset + 0];\n\n    if (outPoints.length) {\n      const d = distance(outPoints[outPoints.length - 1], p0);\n\n      if (d > 1) {\n        outPoints.push(p0);\n      }\n    } else {\n      outPoints.push(p0);\n    }\n\n    outPoints.push(points[offset + 3]);\n  } else {\n    // subdivide\n    const t = .5;\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    const q1 = lerp(p1, p2, t);\n    const q2 = lerp(p2, p3, t);\n    const q3 = lerp(p3, p4, t);\n    const r1 = lerp(q1, q2, t);\n    const r2 = lerp(q2, q3, t);\n    const red = lerp(r1, r2, t);\n    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n    getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n  }\n\n  return outPoints;\n}\n\nexport function simplify(points, distance) {\n  return simplifyPoints(points, 0, points.length, distance);\n} // Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n  const outPoints = newPoints || []; // find the most distance point from the endpoints\n\n  const s = points[start];\n  const e = points[end - 1];\n  let maxDistSq = 0;\n  let maxNdx = 1;\n\n  for (let i = start + 1; i < end - 1; ++i) {\n    const distSq = distanceToSegmentSq(points[i], s, e);\n\n    if (distSq > maxDistSq) {\n      maxDistSq = distSq;\n      maxNdx = i;\n    }\n  } // if that point is too far, split\n\n\n  if (Math.sqrt(maxDistSq) > epsilon) {\n    simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n    simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n  } else {\n    if (!outPoints.length) {\n      outPoints.push(s);\n    }\n\n    outPoints.push(e);\n  }\n\n  return outPoints;\n}\n\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n  const newPoints = [];\n  const numSegments = (points.length - 1) / 3;\n\n  for (let i = 0; i < numSegments; i++) {\n    const offset = i * 3;\n    getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n  }\n\n  if (distance && distance > 0) {\n    return simplifyPoints(newPoints, 0, newPoints.length, distance);\n  }\n\n  return newPoints;\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/points-on-curve/lib/index.js"],"names":["distance","p1","p2","Math","sqrt","distanceSq","pow","distanceToSegmentSq","p","v","w","l2","t","max","min","lerp","a","b","flatness","points","offset","p3","p4","ux","uy","vx","vy","getPointsOnBezierCurveWithSplitting","tolerance","newPoints","outPoints","p0","length","d","push","q1","q2","q3","r1","r2","red","simplify","simplifyPoints","start","end","epsilon","s","e","maxDistSq","maxNdx","i","distSq","pointsOnBezierCurves","numSegments"],"mappings":"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","sourcesContent":["// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n"]},"metadata":{},"sourceType":"module"}