{"ast":null,"code":"import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n  randOffset,\n  randOffsetWithRange,\n  ellipse,\n  doubleLineOps: doubleLineFillOps\n};\nexport function line(x1, y1, x2, y2, o) {\n  return {\n    type: 'path',\n    ops: _doubleLine(x1, y1, x2, y2, o)\n  };\n}\nexport function linearPath(points, close, o) {\n  const len = (points || []).length;\n\n  if (len > 2) {\n    const ops = [];\n\n    for (let i = 0; i < len - 1; i++) {\n      ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n    }\n\n    if (close) {\n      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n    }\n\n    return {\n      type: 'path',\n      ops\n    };\n  } else if (len === 2) {\n    return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n  }\n\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function polygon(points, o) {\n  return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n  const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n  return polygon(points, o);\n}\nexport function curve(points, o) {\n  let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n\n  if (!o.disableMultiStroke) {\n    const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n\n    o1 = o1.concat(o2);\n  }\n\n  return {\n    type: 'path',\n    ops: o1\n  };\n}\nexport function ellipse(x, y, width, height, o) {\n  const params = generateEllipseParams(width, height, o);\n  return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n  const stepCount = Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq);\n  const increment = Math.PI * 2 / stepCount;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  const curveFitRandomness = 1 - o.curveFitting;\n  rx += _offsetOpt(rx * curveFitRandomness, o);\n  ry += _offsetOpt(ry * curveFitRandomness, o);\n  return {\n    increment,\n    rx,\n    ry\n  };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n\n  let o1 = _curve(ap1, null, o);\n\n  if (!o.disableMultiStroke) {\n    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n\n    const o2 = _curve(ap2, null, o);\n\n    o1 = o1.concat(o2);\n  }\n\n  return {\n    estimatedPoints: cp1,\n    opset: {\n      type: 'path',\n      ops: o1\n    }\n  };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n\n  const ellipseInc = Math.PI * 2 / o.curveStepCount;\n  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n\n  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n\n  if (!o.disableMultiStroke) {\n    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n\n    ops.push(...o2);\n  }\n\n  if (closed) {\n    if (roughClosure) {\n      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n    } else {\n      ops.push({\n        op: 'lineTo',\n        data: [cx, cy]\n      }, {\n        op: 'lineTo',\n        data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]\n      });\n    }\n  }\n\n  return {\n    type: 'path',\n    ops\n  };\n}\nexport function svgPath(path, o) {\n  const segments = normalize(absolutize(parsePath(path)));\n  const ops = [];\n  let first = [0, 0];\n  let current = [0, 0];\n\n  for (const {\n    key,\n    data\n  } of segments) {\n    switch (key) {\n      case 'M':\n        {\n          const ro = 1 * (o.maxRandomnessOffset || 0);\n          ops.push({\n            op: 'move',\n            data: data.map(d => d + _offsetOpt(ro, o))\n          });\n          current = [data[0], data[1]];\n          first = [data[0], data[1]];\n          break;\n        }\n\n      case 'L':\n        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n        current = [data[0], data[1]];\n        break;\n\n      case 'C':\n        {\n          const [x1, y1, x2, y2, x, y] = data;\n          ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n          current = [x, y];\n          break;\n        }\n\n      case 'Z':\n        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n        current = [first[0], first[1]];\n        break;\n    }\n  }\n\n  return {\n    type: 'path',\n    ops\n  };\n} // Fills\n\nexport function solidFillPolygon(points, o) {\n  const ops = [];\n\n  if (points.length) {\n    const offset = o.maxRandomnessOffset || 0;\n    const len = points.length;\n\n    if (len > 2) {\n      ops.push({\n        op: 'move',\n        data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]\n      });\n\n      for (let i = 1; i < len; i++) {\n        ops.push({\n          op: 'lineTo',\n          data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]\n        });\n      }\n    }\n  }\n\n  return {\n    type: 'fillPath',\n    ops\n  };\n}\nexport function patternFillPolygon(points, o) {\n  return getFiller(o, helper).fillPolygon(points, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n\n  const increment = (stp - strt) / o.curveStepCount;\n  const points = [];\n\n  for (let angle = strt; angle <= stp; angle = angle + increment) {\n    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n  }\n\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx, cy]);\n  return patternFillPolygon(points, o);\n}\nexport function randOffset(x, o) {\n  return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n  return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n  return _doubleLine(x1, y1, x2, y2, o, true);\n} // Private helpers\n\nfunction cloneOptionsAlterSeed(ops) {\n  const result = Object.assign({}, ops);\n  result.randomizer = undefined;\n\n  if (ops.seed) {\n    result.seed = ops.seed + 1;\n  }\n\n  return result;\n}\n\nfunction random(ops) {\n  if (!ops.randomizer) {\n    ops.randomizer = new Random(ops.seed || 0);\n  }\n\n  return ops.randomizer.next();\n}\n\nfunction _offset(min, max, ops, roughnessGain = 1) {\n  return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);\n}\n\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n  return _offset(-x, x, ops, roughnessGain);\n}\n\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n  const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n\n  const o1 = _line(x1, y1, x2, y2, o, true, false);\n\n  if (singleStroke) {\n    return o1;\n  }\n\n  const o2 = _line(x1, y1, x2, y2, o, true, true);\n\n  return o1.concat(o2);\n}\n\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  const length = Math.sqrt(lengthSq);\n  let roughnessGain = 1;\n\n  if (length < 200) {\n    roughnessGain = 1;\n  } else if (length > 500) {\n    roughnessGain = 0.4;\n  } else {\n    roughnessGain = -0.0016668 * length + 1.233334;\n  }\n\n  let offset = o.maxRandomnessOffset || 0;\n\n  if (offset * offset * 100 > lengthSq) {\n    offset = length / 10;\n  }\n\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + random(o) * 0.2;\n  let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _offsetOpt(midDispX, o, roughnessGain);\n  midDispY = _offsetOpt(midDispY, o, roughnessGain);\n  const ops = [];\n\n  const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n\n  const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n\n  if (move) {\n    if (overlay) {\n      ops.push({\n        op: 'move',\n        data: [x1 + randomHalf(), y1 + randomHalf()]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [x1 + _offsetOpt(offset, o, roughnessGain), y1 + _offsetOpt(offset, o, roughnessGain)]\n      });\n    }\n  }\n\n  if (overlay) {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + randomHalf(), y2 + randomHalf()]\n    });\n  } else {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + randomFull(), y2 + randomFull()]\n    });\n  }\n\n  return ops;\n}\n\nfunction _curveWithOffset(points, offset, o) {\n  const ps = [];\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n\n  for (let i = 1; i < points.length; i++) {\n    ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n\n    if (i === points.length - 1) {\n      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    }\n  }\n\n  return _curve(ps, null, o);\n}\n\nfunction _curve(points, closePoint, o) {\n  const len = points.length;\n  const ops = [];\n\n  if (len > 3) {\n    const b = [];\n    const s = 1 - o.curveTightness;\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n\n    for (let i = 1; i + 2 < len; i++) {\n      const cachedVertArray = points[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n      b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n      b[3] = [points[i + 1][0], points[i + 1][1]];\n      ops.push({\n        op: 'bcurveTo',\n        data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]\n      });\n    }\n\n    if (closePoint && closePoint.length === 2) {\n      const ro = o.maxRandomnessOffset;\n      ops.push({\n        op: 'lineTo',\n        data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]\n      });\n    }\n  } else if (len === 3) {\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    ops.push({\n      op: 'bcurveTo',\n      data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]\n    });\n  } else if (len === 2) {\n    ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n  }\n\n  return ops;\n}\n\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n  const corePoints = [];\n  const allPoints = [];\n  const radOffset = _offsetOpt(0.5, o) - Math.PI / 2;\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n\n  for (let angle = radOffset; angle < Math.PI * 2 + radOffset - 0.01; angle = angle + increment) {\n    const p = [_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)];\n    corePoints.push(p);\n    allPoints.push(p);\n  }\n\n  allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  return [allPoints, corePoints];\n}\n\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n  const radOffset = strt + _offsetOpt(0.1, o);\n\n  const points = [];\n  points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n\n  for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n    points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);\n  }\n\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  return _curve(points, null, o);\n}\n\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n  const ops = [];\n  const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n  let f = [0, 0];\n  const iterations = o.disableMultiStroke ? 1 : 2;\n\n  for (let i = 0; i < iterations; i++) {\n    if (i === 0) {\n      ops.push({\n        op: 'move',\n        data: [current[0], current[1]]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [current[0] + _offsetOpt(ros[0], o), current[1] + _offsetOpt(ros[0], o)]\n      });\n    }\n\n    f = [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n    ops.push({\n      op: 'bcurveTo',\n      data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]\n    });\n  }\n\n  return ops;\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/roughjs/bin/renderer.js"],"names":["getFiller","Random","parsePath","normalize","absolutize","helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","doubleLineFillOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","push","polygon","rectangle","x","y","width","height","curve","o1","_curveWithOffset","roughness","disableMultiStroke","o2","cloneOptionsAlterSeed","concat","params","generateEllipseParams","ellipseWithParams","opset","psq","Math","sqrt","PI","pow","stepCount","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","cp1","_computeEllipsePoints","_offset","_curve","ap2","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","op","data","svgPath","path","segments","first","current","key","ro","maxRandomnessOffset","map","d","_bezierTo","solidFillPolygon","offset","patternFillPolygon","fillPolygon","patternFillArc","angle","result","Object","assign","randomizer","undefined","seed","random","next","roughnessGain","filling","singleStroke","disableMultiStrokeFill","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","ps","closePoint","b","s","curveTightness","cachedVertArray","overlap","corePoints","allPoints","radOffset","p","ros","f","iterations"],"mappings":"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","sourcesContent":["import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height]\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq);\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if (!o.disableMultiStroke) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 }\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                ops.push({ op: 'move', data: data.map((d) => d + _offsetOpt(ro, o)) });\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(points, o) {\n    const ops = [];\n    if (points.length) {\n        const offset = o.maxRandomnessOffset || 0;\n        const len = points.length;\n        if (len > 2) {\n            ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n            for (let i = 1; i < len; i++) {\n                ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygon(points, o) {\n    return getFiller(o, helper).fillPolygon(points, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygon(points, o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + randomHalf(),\n                    y1 + randomHalf()\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + _offsetOpt(offset, o, roughnessGain),\n                    y1 + _offsetOpt(offset, o, roughnessGain)\n                ]\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + randomHalf(),\n                y2 + randomHalf()\n            ]\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + randomFull(),\n                y2 + randomFull()\n            ]\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo', data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1]\n            ]\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const corePoints = [];\n    const allPoints = [];\n    const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n        const p = [\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ];\n        corePoints.push(p);\n        allPoints.push(p);\n    }\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n        _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n    ]);\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + _offsetOpt(ros[0], o), current[1] + _offsetOpt(ros[0], o)] });\n        }\n        f = [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo', data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1]\n            ]\n        });\n    }\n    return ops;\n}\n"]},"metadata":{},"sourceType":"module"}