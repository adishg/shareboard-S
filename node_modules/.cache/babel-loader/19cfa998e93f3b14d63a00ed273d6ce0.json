{"ast":null,"code":"import { getImportedKey } from \"../data\";\nimport { createIV } from \"./index\";\nimport { getSceneVersion } from \"../../element\";\nimport { restoreElements } from \"../../data/restore\";\nlet firebasePromise = null;\n\nconst loadFirebase = async () => {\n  const firebase = (await import(\n  /* webpackChunkName: \"firebase\" */\n  \"firebase/app\")).default;\n  await import(\n  /* webpackChunkName: \"firestore\" */\n  \"firebase/firestore\");\n  const firebaseConfig = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n  firebase.initializeApp(firebaseConfig);\n  return firebase;\n};\n\nconst getFirebase = async () => {\n  if (!firebasePromise) {\n    firebasePromise = loadFirebase();\n  }\n\n  return await firebasePromise;\n};\n\nconst encryptElements = async (key, elements) => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv\n  }, importedKey, encoded);\n  return {\n    ciphertext,\n    iv\n  };\n};\n\nconst decryptElements = async (key, iv, ciphertext) => {\n  const importedKey = await getImportedKey(key, \"decrypt\");\n  const decrypted = await window.crypto.subtle.decrypt({\n    name: \"AES-GCM\",\n    iv\n  }, importedKey, ciphertext);\n  const decodedData = new TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n  return JSON.parse(decodedData);\n};\n\nconst firebaseSceneVersionCache = new WeakMap();\nexport const isSavedToFirebase = (portal, elements) => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n    return firebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  } // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n\n\n  return true;\n};\nexport const saveToFirebase = async (portal, elements) => {\n  const {\n    roomId,\n    roomKey,\n    socket\n  } = portal;\n\n  if ( // if no room exists, consider the room saved because there's nothing we can\n  // do at this point\n  !roomId || !roomKey || !socket || isSavedToFirebase(portal, elements)) {\n    return true;\n  }\n\n  const firebase = await getFirebase();\n  const sceneVersion = getSceneVersion(elements);\n  const {\n    ciphertext,\n    iv\n  } = await encryptElements(roomKey, elements);\n  const nextDocData = {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(new Uint8Array(ciphertext)),\n    iv: firebase.firestore.Blob.fromUint8Array(iv)\n  };\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const didUpdate = await db.runTransaction(async transaction => {\n    const doc = await transaction.get(docRef);\n\n    if (!doc.exists) {\n      transaction.set(docRef, nextDocData);\n      return true;\n    }\n\n    const prevDocData = doc.data();\n\n    if (prevDocData.sceneVersion >= nextDocData.sceneVersion) {\n      return false;\n    }\n\n    transaction.update(docRef, nextDocData);\n    return true;\n  });\n\n  if (didUpdate) {\n    firebaseSceneVersionCache.set(socket, sceneVersion);\n  }\n\n  return didUpdate;\n};\nexport const loadFromFirebase = async (roomId, roomKey) => {\n  const firebase = await getFirebase();\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n\n  if (!doc.exists) {\n    return null;\n  }\n\n  const storedScene = doc.data();\n  const ciphertext = storedScene.ciphertext.toUint8Array();\n  const iv = storedScene.iv.toUint8Array();\n  return restoreElements(await decryptElements(roomKey, iv, ciphertext));\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/excalidraw-app/data/firebase.ts"],"names":["getImportedKey","createIV","getSceneVersion","restoreElements","firebasePromise","loadFirebase","firebase","default","firebaseConfig","JSON","parse","process","env","REACT_APP_FIREBASE_CONFIG","initializeApp","getFirebase","encryptElements","key","elements","importedKey","iv","json","stringify","encoded","TextEncoder","encode","ciphertext","window","crypto","subtle","encrypt","name","decryptElements","decrypted","decrypt","decodedData","TextDecoder","decode","Uint8Array","firebaseSceneVersionCache","WeakMap","isSavedToFirebase","portal","socket","roomId","roomKey","sceneVersion","get","saveToFirebase","nextDocData","firestore","Blob","fromUint8Array","db","docRef","collection","doc","didUpdate","runTransaction","transaction","exists","set","prevDocData","data","update","loadFromFirebase","storedScene","toUint8Array"],"mappings":"AAAA,SAASA,cAAT,QAA+B,SAA/B;AACA,SAASC,QAAT,QAAyB,SAAzB;AAEA,SAASC,eAAT,QAAgC,eAAhC;AAEA,SAASC,eAAT,QAAgC,oBAAhC;AAEA,IAAIC,eAEI,GAAG,IAFX;;AAIA,MAAMC,YAAY,GAAG,YAAY;AAC/B,QAAMC,QAAQ,GAAG,CACf,MAAM;AAAO;AAAmC,gBAA1C,CADS,EAEfC,OAFF;AAGA,QAAM;AAAO;AAAoC,sBAA3C,CAAN;AAEA,QAAMC,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWC,OAAO,CAACC,GAAR,CAAYC,yBAAvB,CAAvB;AACAP,EAAAA,QAAQ,CAACQ,aAAT,CAAuBN,cAAvB;AAEA,SAAOF,QAAP;AACD,CAVD;;AAYA,MAAMS,WAAW,GAAG,YAEf;AACH,MAAI,CAACX,eAAL,EAAsB;AACpBA,IAAAA,eAAe,GAAGC,YAAY,EAA9B;AACD;;AACD,SAAO,MAAMD,eAAb;AACD,CAPD;;AAeA,MAAMY,eAAe,GAAG,OACtBC,GADsB,EAEtBC,QAFsB,KAGmC;AACzD,QAAMC,WAAW,GAAG,MAAMnB,cAAc,CAACiB,GAAD,EAAM,SAAN,CAAxC;AACA,QAAMG,EAAE,GAAGnB,QAAQ,EAAnB;AACA,QAAMoB,IAAI,GAAGZ,IAAI,CAACa,SAAL,CAAeJ,QAAf,CAAb;AACA,QAAMK,OAAO,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBJ,IAAzB,CAAhB;AACA,QAAMK,UAAU,GAAG,MAAMC,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBC,OAArB,CACvB;AACEC,IAAAA,IAAI,EAAE,SADR;AAEEX,IAAAA;AAFF,GADuB,EAKvBD,WALuB,EAMvBI,OANuB,CAAzB;AASA,SAAO;AAAEG,IAAAA,UAAF;AAAcN,IAAAA;AAAd,GAAP;AACD,CAlBD;;AAoBA,MAAMY,eAAe,GAAG,OACtBf,GADsB,EAEtBG,EAFsB,EAGtBM,UAHsB,KAIoB;AAC1C,QAAMP,WAAW,GAAG,MAAMnB,cAAc,CAACiB,GAAD,EAAM,SAAN,CAAxC;AACA,QAAMgB,SAAS,GAAG,MAAMN,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBK,OAArB,CACtB;AACEH,IAAAA,IAAI,EAAE,SADR;AAEEX,IAAAA;AAFF,GADsB,EAKtBD,WALsB,EAMtBO,UANsB,CAAxB;AASA,QAAMS,WAAW,GAAG,IAAIC,WAAJ,CAAgB,OAAhB,EAAyBC,MAAzB,CAClB,IAAIC,UAAJ,CAAeL,SAAf,CADkB,CAApB;AAGA,SAAOxB,IAAI,CAACC,KAAL,CAAWyB,WAAX,CAAP;AACD,CAnBD;;AAqBA,MAAMI,yBAAyB,GAAG,IAAIC,OAAJ,EAAlC;AAEA,OAAO,MAAMC,iBAAiB,GAAG,CAC/BC,MAD+B,EAE/BxB,QAF+B,KAGnB;AACZ,MAAIwB,MAAM,CAACC,MAAP,IAAiBD,MAAM,CAACE,MAAxB,IAAkCF,MAAM,CAACG,OAA7C,EAAsD;AACpD,UAAMC,YAAY,GAAG5C,eAAe,CAACgB,QAAD,CAApC;AACA,WAAOqB,yBAAyB,CAACQ,GAA1B,CAA8BL,MAAM,CAACC,MAArC,MAAiDG,YAAxD;AACD,GAJW,CAKZ;AACA;;;AACA,SAAO,IAAP;AACD,CAXM;AAaP,OAAO,MAAME,cAAc,GAAG,OAC5BN,MAD4B,EAE5BxB,QAF4B,KAGzB;AACH,QAAM;AAAE0B,IAAAA,MAAF;AAAUC,IAAAA,OAAV;AAAmBF,IAAAA;AAAnB,MAA8BD,MAApC;;AACA,OACE;AACA;AACA,GAACE,MAAD,IACA,CAACC,OADD,IAEA,CAACF,MAFD,IAGAF,iBAAiB,CAACC,MAAD,EAASxB,QAAT,CANnB,EAOE;AACA,WAAO,IAAP;AACD;;AAED,QAAMZ,QAAQ,GAAG,MAAMS,WAAW,EAAlC;AACA,QAAM+B,YAAY,GAAG5C,eAAe,CAACgB,QAAD,CAApC;AACA,QAAM;AAAEQ,IAAAA,UAAF;AAAcN,IAAAA;AAAd,MAAqB,MAAMJ,eAAe,CAAC6B,OAAD,EAAU3B,QAAV,CAAhD;AAEA,QAAM+B,WAAW,GAAG;AAClBH,IAAAA,YADkB;AAElBpB,IAAAA,UAAU,EAAEpB,QAAQ,CAAC4C,SAAT,CAAmBC,IAAnB,CAAwBC,cAAxB,CACV,IAAId,UAAJ,CAAeZ,UAAf,CADU,CAFM;AAKlBN,IAAAA,EAAE,EAAEd,QAAQ,CAAC4C,SAAT,CAAmBC,IAAnB,CAAwBC,cAAxB,CAAuChC,EAAvC;AALc,GAApB;AAQA,QAAMiC,EAAE,GAAG/C,QAAQ,CAAC4C,SAAT,EAAX;AACA,QAAMI,MAAM,GAAGD,EAAE,CAACE,UAAH,CAAc,QAAd,EAAwBC,GAAxB,CAA4BZ,MAA5B,CAAf;AACA,QAAMa,SAAS,GAAG,MAAMJ,EAAE,CAACK,cAAH,CAAkB,MAAOC,WAAP,IAAuB;AAC/D,UAAMH,GAAG,GAAG,MAAMG,WAAW,CAACZ,GAAZ,CAAgBO,MAAhB,CAAlB;;AACA,QAAI,CAACE,GAAG,CAACI,MAAT,EAAiB;AACfD,MAAAA,WAAW,CAACE,GAAZ,CAAgBP,MAAhB,EAAwBL,WAAxB;AACA,aAAO,IAAP;AACD;;AAED,UAAMa,WAAW,GAAGN,GAAG,CAACO,IAAJ,EAApB;;AACA,QAAID,WAAW,CAAChB,YAAZ,IAA4BG,WAAW,CAACH,YAA5C,EAA0D;AACxD,aAAO,KAAP;AACD;;AAEDa,IAAAA,WAAW,CAACK,MAAZ,CAAmBV,MAAnB,EAA2BL,WAA3B;AACA,WAAO,IAAP;AACD,GAduB,CAAxB;;AAgBA,MAAIQ,SAAJ,EAAe;AACblB,IAAAA,yBAAyB,CAACsB,GAA1B,CAA8BlB,MAA9B,EAAsCG,YAAtC;AACD;;AAED,SAAOW,SAAP;AACD,CAnDM;AAqDP,OAAO,MAAMQ,gBAAgB,GAAG,OAC9BrB,MAD8B,EAE9BC,OAF8B,KAGmB;AACjD,QAAMvC,QAAQ,GAAG,MAAMS,WAAW,EAAlC;AACA,QAAMsC,EAAE,GAAG/C,QAAQ,CAAC4C,SAAT,EAAX;AAEA,QAAMI,MAAM,GAAGD,EAAE,CAACE,UAAH,CAAc,QAAd,EAAwBC,GAAxB,CAA4BZ,MAA5B,CAAf;AACA,QAAMY,GAAG,GAAG,MAAMF,MAAM,CAACP,GAAP,EAAlB;;AACA,MAAI,CAACS,GAAG,CAACI,MAAT,EAAiB;AACf,WAAO,IAAP;AACD;;AACD,QAAMM,WAAW,GAAGV,GAAG,CAACO,IAAJ,EAApB;AACA,QAAMrC,UAAU,GAAGwC,WAAW,CAACxC,UAAZ,CAAuByC,YAAvB,EAAnB;AACA,QAAM/C,EAAE,GAAG8C,WAAW,CAAC9C,EAAZ,CAAe+C,YAAf,EAAX;AACA,SAAOhE,eAAe,CAAC,MAAM6B,eAAe,CAACa,OAAD,EAAUzB,EAAV,EAAcM,UAAd,CAAtB,CAAtB;AACD,CAhBM","sourcesContent":["import { getImportedKey } from \"../data\";\nimport { createIV } from \"./index\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { getSceneVersion } from \"../../element\";\nimport Portal from \"../collab/Portal\";\nimport { restoreElements } from \"../../data/restore\";\n\nlet firebasePromise: Promise<\n  typeof import(\"firebase/app\").default\n> | null = null;\n\nconst loadFirebase = async () => {\n  const firebase = (\n    await import(/* webpackChunkName: \"firebase\" */ \"firebase/app\")\n  ).default;\n  await import(/* webpackChunkName: \"firestore\" */ \"firebase/firestore\");\n\n  const firebaseConfig = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n  firebase.initializeApp(firebaseConfig);\n\n  return firebase;\n};\n\nconst getFirebase = async (): Promise<\n  typeof import(\"firebase/app\").default\n> => {\n  if (!firebasePromise) {\n    firebasePromise = loadFirebase();\n  }\n  return await firebasePromise!;\n};\n\ninterface FirebaseStoredScene {\n  sceneVersion: number;\n  iv: firebase.default.firestore.Blob;\n  ciphertext: firebase.default.firestore.Blob;\n}\n\nconst encryptElements = async (\n  key: string,\n  elements: readonly ExcalidrawElement[],\n): Promise<{ ciphertext: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    encoded,\n  );\n\n  return { ciphertext, iv };\n};\n\nconst decryptElements = async (\n  key: string,\n  iv: Uint8Array,\n  ciphertext: ArrayBuffer,\n): Promise<readonly ExcalidrawElement[]> => {\n  const importedKey = await getImportedKey(key, \"decrypt\");\n  const decrypted = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    ciphertext,\n  );\n\n  const decodedData = new TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted) as any,\n  );\n  return JSON.parse(decodedData);\n};\n\nconst firebaseSceneVersionCache = new WeakMap<SocketIOClient.Socket, number>();\n\nexport const isSavedToFirebase = (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n): boolean => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n    return firebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\n\nexport const saveToFirebase = async (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n) => {\n  const { roomId, roomKey, socket } = portal;\n  if (\n    // if no room exists, consider the room saved because there's nothing we can\n    // do at this point\n    !roomId ||\n    !roomKey ||\n    !socket ||\n    isSavedToFirebase(portal, elements)\n  ) {\n    return true;\n  }\n\n  const firebase = await getFirebase();\n  const sceneVersion = getSceneVersion(elements);\n  const { ciphertext, iv } = await encryptElements(roomKey, elements);\n\n  const nextDocData = {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(\n      new Uint8Array(ciphertext),\n    ),\n    iv: firebase.firestore.Blob.fromUint8Array(iv),\n  } as FirebaseStoredScene;\n\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const didUpdate = await db.runTransaction(async (transaction) => {\n    const doc = await transaction.get(docRef);\n    if (!doc.exists) {\n      transaction.set(docRef, nextDocData);\n      return true;\n    }\n\n    const prevDocData = doc.data() as FirebaseStoredScene;\n    if (prevDocData.sceneVersion >= nextDocData.sceneVersion) {\n      return false;\n    }\n\n    transaction.update(docRef, nextDocData);\n    return true;\n  });\n\n  if (didUpdate) {\n    firebaseSceneVersionCache.set(socket, sceneVersion);\n  }\n\n  return didUpdate;\n};\n\nexport const loadFromFirebase = async (\n  roomId: string,\n  roomKey: string,\n): Promise<readonly ExcalidrawElement[] | null> => {\n  const firebase = await getFirebase();\n  const db = firebase.firestore();\n\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data() as FirebaseStoredScene;\n  const ciphertext = storedScene.ciphertext.toUint8Array();\n  const iv = storedScene.iv.toUint8Array();\n  return restoreElements(await decryptElements(roomKey, iv, ciphertext));\n};\n"]},"metadata":{},"sourceType":"module"}