{"ast":null,"code":"import { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport { FONT_FAMILY, DEFAULT_FONT_FAMILY, DEFAULT_TEXT_ALIGN, DEFAULT_VERTICAL_ALIGN } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nconst getFontFamilyByName = fontFamilyName => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id);\n    }\n  }\n\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = (element, extra) => {\n  var _element$versionNonce, _element$isDeleted, _element$strokeStyle, _element$roughness, _element$seed, _element$groupIds, _element$strokeSharpn, _element$boundElement;\n\n  const base = {\n    type: element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: (_element$versionNonce = element.versionNonce) !== null && _element$versionNonce !== void 0 ? _element$versionNonce : 0,\n    isDeleted: (_element$isDeleted = element.isDeleted) !== null && _element$isDeleted !== void 0 ? _element$isDeleted : false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: (_element$strokeStyle = element.strokeStyle) !== null && _element$strokeStyle !== void 0 ? _element$strokeStyle : \"solid\",\n    roughness: (_element$roughness = element.roughness) !== null && _element$roughness !== void 0 ? _element$roughness : 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: (_element$seed = element.seed) !== null && _element$seed !== void 0 ? _element$seed : 1,\n    groupIds: (_element$groupIds = element.groupIds) !== null && _element$groupIds !== void 0 ? _element$groupIds : [],\n    strokeSharpness: (_element$strokeSharpn = element.strokeSharpness) !== null && _element$strokeSharpn !== void 0 ? _element$strokeSharpn : isLinearElementType(element.type) ? \"round\" : \"sharp\",\n    boundElementIds: (_element$boundElement = element.boundElementIds) !== null && _element$boundElement !== void 0 ? _element$boundElement : []\n  };\n  return { ...base,\n    ...getNormalizedDimensions(base),\n    ...extra\n  };\n};\n\nconst restoreElement = element => {\n  var _element$text;\n\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily] = element.font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: (_element$text = element.text) !== null && _element$text !== void 0 ? _element$text : \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN\n      });\n\n    case \"draw\":\n    case \"line\":\n    case \"arrow\":\n      {\n        const {\n          startArrowhead = null,\n          endArrowhead = element.type === \"arrow\" ? \"arrow\" : null\n        } = element;\n        return restoreElementWithProperties(element, {\n          startBinding: element.startBinding,\n          endBinding: element.endBinding,\n          points: // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2 ? [[0, 0], [element.width, element.height]] : element.points,\n          lastCommittedPoint: null,\n          startArrowhead,\n          endArrowhead\n        });\n      }\n    // generic elements\n\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = elements => {\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = restoreElement(element);\n\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n\n    return elements;\n  }, []);\n};\n\nconst restoreAppState = (appState, localAppState) => {\n  appState = appState || {};\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {};\n\n  for (const [key, val] of Object.entries(defaultAppState)) {\n    const restoredValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    nextAppState[key] = restoredValue !== undefined ? restoredValue : localValue !== undefined ? localValue : val;\n  }\n\n  return { ...nextAppState,\n    offsetLeft: appState.offsetLeft || 0,\n    offsetTop: appState.offsetTop || 0,\n    // Migrates from previous version where appState.zoom was a number\n    zoom: typeof appState.zoom === \"number\" ? {\n      value: appState.zoom,\n      translation: defaultAppState.zoom.translation\n    } : appState.zoom || defaultAppState.zoom\n  };\n};\n\nexport const restore = (data, localAppState) => {\n  return {\n    elements: restoreElements(data === null || data === void 0 ? void 0 : data.elements),\n    appState: restoreAppState(data === null || data === void 0 ? void 0 : data.appState, localAppState || null)\n  };\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/data/restore.ts"],"names":["isInvisiblySmallElement","getNormalizedDimensions","isLinearElementType","randomId","FONT_FAMILY","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","getDefaultAppState","getFontFamilyByName","fontFamilyName","id","fontFamilyString","Object","entries","includes","parseInt","restoreElementWithProperties","element","extra","base","type","version","versionNonce","isDeleted","fillStyle","strokeWidth","strokeStyle","roughness","opacity","angle","x","y","strokeColor","backgroundColor","width","height","seed","groupIds","strokeSharpness","boundElementIds","restoreElement","fontSize","fontFamily","fontPx","_fontFamily","font","split","text","baseline","textAlign","verticalAlign","startArrowhead","endArrowhead","startBinding","endBinding","points","Array","isArray","length","lastCommittedPoint","restoreElements","elements","reduce","migratedElement","push","restoreAppState","appState","localAppState","defaultAppState","nextAppState","key","val","restoredValue","localValue","undefined","offsetLeft","offsetTop","zoom","value","translation","restore","data"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  FontFamily,\n  ExcalidrawSelectionElement,\n} from \"../element/types\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { DataState, ImportedDataState } from \"./types\";\nimport { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  FONT_FAMILY,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamily => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id) as FontFamily;\n    }\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <T extends ExcalidrawElement>(\n  element: Required<T>,\n  extra: Omit<Required<T>, keyof ExcalidrawElement>,\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    strokeSharpness:\n      element.strokeSharpness ??\n      (isLinearElementType(element.type) ? \"round\" : \"sharp\"),\n    boundElementIds: element.boundElementIds ?? [],\n  };\n\n  return ({\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown) as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"draw\":\n    case \"line\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      return restoreElementWithProperties(element, {\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        points:\n          // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2\n            ? [\n                [0, 0],\n                [element.width, element.height],\n              ]\n            : element.points,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n): ExcalidrawElement[] => {\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = restoreElement(element);\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n};\n\nconst restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null,\n): AppState => {\n  appState = appState || {};\n\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  for (const [key, val] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    const restoredValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      restoredValue !== undefined\n        ? restoredValue\n        : localValue !== undefined\n        ? localValue\n        : val;\n  }\n\n  return {\n    ...nextAppState,\n    offsetLeft: appState.offsetLeft || 0,\n    offsetTop: appState.offsetTop || 0,\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n            translation: defaultAppState.zoom.translation,\n          }\n        : appState.zoom || defaultAppState.zoom,\n  };\n};\n\nexport const restore = (\n  data: ImportedDataState | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n): DataState => {\n  return {\n    elements: restoreElements(data?.elements),\n    appState: restoreAppState(data?.appState, localAppState || null),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}