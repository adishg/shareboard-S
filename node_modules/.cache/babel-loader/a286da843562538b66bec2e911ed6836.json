{"ast":null,"code":"import colors from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { randomId } from \"./random\";\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\nconst tryParseNumber = s => {\n  const match = /^[$€£¥₩]?([0-9,]+(\\.[0-9]+)?)$/.exec(s);\n\n  if (!match) {\n    return null;\n  }\n\n  return parseFloat(match[1].replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines, columnIndex) => lines.slice(1).every(line => tryParseNumber(line[columnIndex]) !== null);\n\nconst tryParseCells = cells => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"More than 2 columns\"\n    };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return {\n        type: NOT_SPREADSHEET,\n        reason: \"Value is not numeric\"\n      };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map(line => tryParseNumber(line[0]));\n\n    if (values.length < 2) {\n      return {\n        type: NOT_SPREADSHEET,\n        reason: \"Less than two rows\"\n      };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values\n      }\n    };\n  }\n\n  const valueColumnIndex = isNumericColumn(cells, 0) ? 0 : 1;\n\n  if (!isNumericColumn(cells, valueColumnIndex)) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"Value is not numeric\"\n    };\n  }\n\n  const labelColumnIndex = (valueColumnIndex + 1) % 2;\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"Less than 2 rows\"\n    };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map(row => row[labelColumnIndex]),\n      values: rows.map(row => tryParseNumber(row[valueColumnIndex]))\n    }\n  };\n};\n\nconst transposeCells = cells => {\n  const nextCells = [];\n\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow = [];\n\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n\n    nextCells.push(nextCellRow);\n  }\n\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = text => {\n  // Copy/paste from excel, spreadhseets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n  // Check for tab separated values\n  let lines = text.trim().split(\"\\n\").map(line => line.trim().split(\"\\t\")); // Check for comma separated files\n\n  if (lines.length && lines[0].length !== 2) {\n    lines = text.trim().split(\"\\n\").map(line => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"No values\"\n    };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every(line => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\"\n    };\n  }\n\n  const result = tryParseCells(lines);\n\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n\n  return result;\n};\nconst bgColors = colors.elementBackground.slice(2, colors.elementBackground.length); // Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\n\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: colors.elementStroke[0],\n  strokeSharpness: \"sharp\",\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: \"middle\"\n};\n\nconst getChartDimentions = spreadsheet => {\n  const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return {\n    chartWidth,\n    chartHeight\n  };\n};\n\nconst chartXLabels = (spreadsheet, x, y, groupId, backgroundColor) => {\n  var _spreadsheet$labels;\n\n  return ((_spreadsheet$labels = spreadsheet.labels) === null || _spreadsheet$labels === void 0 ? void 0 : _spreadsheet$labels.map((label, index) => {\n    return newTextElement({\n      groupIds: [groupId],\n      backgroundColor,\n      ...commonProps,\n      text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n      y: y + BAR_GAP / 2,\n      width: BAR_WIDTH,\n      angle: 5.87,\n      fontSize: 16,\n      textAlign: \"center\",\n      verticalAlign: \"top\"\n    });\n  })) || [];\n};\n\nconst chartYLabels = (spreadsheet, x, y, groupId, backgroundColor) => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\"\n  });\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\"\n  });\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (spreadsheet, x, y, groupId, backgroundColor) => {\n  const {\n    chartWidth,\n    chartHeight\n  } = getChartDimentions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [[0, 0], [chartWidth, 0]]\n  });\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [[0, 0], [0, -chartHeight]]\n  });\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [[0, 0], [chartWidth, 0]]\n  });\n  return [xLine, yLine, maxLine];\n}; // For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\n\n\nconst chartBaseElements = (spreadsheet, x, y, groupId, backgroundColor, debug) => {\n  const {\n    chartWidth,\n    chartHeight\n  } = getChartDimentions(spreadsheet);\n  const title = spreadsheet.title ? newTextElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    text: spreadsheet.title,\n    x: x + chartWidth / 2,\n    y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n    strokeSharpness: \"sharp\",\n    strokeStyle: \"solid\",\n    textAlign: \"center\"\n  }) : null;\n  const debugRect = debug ? newElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"rectangle\",\n    x,\n    y: y - chartHeight,\n    width: chartWidth,\n    height: chartHeight,\n    strokeColor: colors.elementStroke[0],\n    fillStyle: \"solid\",\n    opacity: 6\n  }) : null;\n  return [...(debugRect ? [debugRect] : []), ...(title ? [title] : []), ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor), ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor), ...chartLines(spreadsheet, x, y, groupId, backgroundColor)];\n};\n\nconst chartTypeBar = (spreadsheet, x, y) => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = value / max * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight\n    });\n  });\n  return [...bars, ...chartBaseElements(spreadsheet, x, y, groupId, backgroundColor, process.env.NODE_ENV === ENV.DEVELOPMENT)];\n};\n\nconst chartTypeLine = (spreadsheet, x, y) => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n  let index = 0;\n  const points = [];\n\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map(element => element[0]));\n  const maxY = Math.max(...points.map(element => element[1]));\n  const minX = Math.min(...points.map(element => element[0]));\n  const minY = Math.min(...points.map(element => element[1]));\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points\n  });\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP\n    });\n  });\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [[0, 0], [0, cy]]\n    });\n  });\n  return [...chartBaseElements(spreadsheet, x, y, groupId, backgroundColor, process.env.NODE_ENV === ENV.DEVELOPMENT), line, ...lines, ...dots];\n};\n\nexport const renderSpreadsheet = (chartType, spreadsheet, x, y) => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n\n  return chartTypeBar(spreadsheet, x, y);\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/charts.ts"],"names":["colors","DEFAULT_FONT_FAMILY","DEFAULT_FONT_SIZE","ENV","newElement","newLinearElement","newTextElement","randomId","BAR_WIDTH","BAR_GAP","BAR_HEIGHT","GRID_OPACITY","NOT_SPREADSHEET","VALID_SPREADSHEET","tryParseNumber","s","match","exec","parseFloat","replace","isNumericColumn","lines","columnIndex","slice","every","line","tryParseCells","cells","numCols","length","type","reason","hasHeader","values","map","spreadsheet","title","labels","valueColumnIndex","labelColumnIndex","rows","row","transposeCells","nextCells","col","nextCellRow","push","tryParseSpreadsheet","text","trim","split","numColsFirstLine","isSpreadsheet","result","transposedResults","bgColors","elementBackground","commonProps","fillStyle","fontFamily","fontSize","opacity","roughness","strokeColor","elementStroke","strokeSharpness","strokeStyle","strokeWidth","verticalAlign","getChartDimentions","chartWidth","chartHeight","chartXLabels","x","y","groupId","backgroundColor","label","index","groupIds","width","angle","textAlign","chartYLabels","minYLabel","maxYLabel","height","Math","max","toLocaleString","chartLines","xLine","startArrowhead","endArrowhead","points","yLine","maxLine","chartBaseElements","debug","debugRect","chartTypeBar","floor","random","bars","value","barHeight","process","env","NODE_ENV","DEVELOPMENT","chartTypeLine","cx","cy","maxX","element","maxY","minX","min","minY","dots","renderSpreadsheet","chartType"],"mappings":"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","sourcesContent":["import colors from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { NonDeletedExcalidrawElement } from \"./element/types\";\nimport { randomId } from \"./random\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\nconst tryParseNumber = (s: string): number | null => {\n  const match = /^[$€£¥₩]?([0-9,]+(\\.[0-9]+)?)$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(match[1].replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\nconst tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const valueColumnIndex = isNumericColumn(cells, 0) ? 0 : 1;\n\n  if (!isNumericColumn(cells, valueColumnIndex)) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const labelColumnIndex = (valueColumnIndex + 1) % 2;\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadhseets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = colors.elementBackground.slice(\n  2,\n  colors.elementBackground.length,\n);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: colors.elementStroke[0],\n  strokeSharpness: \"sharp\",\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: \"middle\",\n} as const;\n\nconst getChartDimentions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [\n      [0, 0],\n      [0, -chartHeight],\n    ],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        strokeSharpness: \"sharp\",\n        strokeStyle: \"solid\",\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: colors.elementStroke[0],\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [\n        [0, 0],\n        [0, cy],\n      ],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n"]},"metadata":{},"sourceType":"module"}