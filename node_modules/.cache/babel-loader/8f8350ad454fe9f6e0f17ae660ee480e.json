{"ast":null,"code":"import { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\nexport const alignElements = (selectedElements, alignment) => {\n  const groups = getMaximumGroups(selectedElements);\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n  return groups.flatMap(group => {\n    const translation = calculateTranslation(group, selectionBoundingBox, alignment);\n    return group.map(element => newElementWith(element, {\n      x: element.x + translation.x,\n      y: element.y + translation.y\n    }));\n  });\n};\nexport const getMaximumGroups = elements => {\n  const groups = new Map();\n  elements.forEach(element => {\n    const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];\n    const currentGroupMembers = groups.get(groupId) || [];\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n  return Array.from(groups.values());\n};\n\nconst calculateTranslation = (group, selectionBoundingBox, {\n  axis,\n  position\n}) => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n  const [min, max] = axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n  const noTranslation = {\n    x: 0,\n    y: 0\n  };\n\n  if (position === \"start\") {\n    return { ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min]\n    };\n  } else if (position === \"end\") {\n    return { ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max]\n    };\n  } // else if (position === \"center\") {\n\n\n  return { ...noTranslation,\n    [axis]: (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 - (groupBoundingBox[min] + groupBoundingBox[max]) / 2\n  };\n};\n\nconst getCommonBoundingBox = elements => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY\n  };\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/align.ts"],"names":["newElementWith","getCommonBounds","alignElements","selectedElements","alignment","groups","getMaximumGroups","selectionBoundingBox","getCommonBoundingBox","flatMap","group","translation","calculateTranslation","map","element","x","y","elements","Map","forEach","groupId","groupIds","length","id","currentGroupMembers","get","set","Array","from","values","axis","position","groupBoundingBox","min","max","noTranslation","minX","minY","maxX","maxY"],"mappings":"AACA,SAASA,cAAT,QAA+B,yBAA/B;AACA,SAASC,eAAT,QAAgC,WAAhC;AAcA,OAAO,MAAMC,aAAa,GAAG,CAC3BC,gBAD2B,EAE3BC,SAF2B,KAGH;AACxB,QAAMC,MAA6B,GAAGC,gBAAgB,CAACH,gBAAD,CAAtD;AAEA,QAAMI,oBAAoB,GAAGC,oBAAoB,CAACL,gBAAD,CAAjD;AAEA,SAAOE,MAAM,CAACI,OAAP,CAAgBC,KAAD,IAAW;AAC/B,UAAMC,WAAW,GAAGC,oBAAoB,CACtCF,KADsC,EAEtCH,oBAFsC,EAGtCH,SAHsC,CAAxC;AAKA,WAAOM,KAAK,CAACG,GAAN,CAAWC,OAAD,IACfd,cAAc,CAACc,OAAD,EAAU;AACtBC,MAAAA,CAAC,EAAED,OAAO,CAACC,CAAR,GAAYJ,WAAW,CAACI,CADL;AAEtBC,MAAAA,CAAC,EAAEF,OAAO,CAACE,CAAR,GAAYL,WAAW,CAACK;AAFL,KAAV,CADT,CAAP;AAMD,GAZM,CAAP;AAaD,CArBM;AAuBP,OAAO,MAAMV,gBAAgB,GAC3BW,QAD8B,IAEJ;AAC1B,QAAMZ,MAAwC,GAAG,IAAIa,GAAJ,EAAjD;AAKAD,EAAAA,QAAQ,CAACE,OAAT,CAAkBL,OAAD,IAAgC;AAC/C,UAAMM,OAAO,GACXN,OAAO,CAACO,QAAR,CAAiBC,MAAjB,KAA4B,CAA5B,GACIR,OAAO,CAACS,EADZ,GAEIT,OAAO,CAACO,QAAR,CAAiBP,OAAO,CAACO,QAAR,CAAiBC,MAAjB,GAA0B,CAA3C,CAHN;AAKA,UAAME,mBAAmB,GAAGnB,MAAM,CAACoB,GAAP,CAAWL,OAAX,KAAuB,EAAnD;AAEAf,IAAAA,MAAM,CAACqB,GAAP,CAAWN,OAAX,EAAoB,CAAC,GAAGI,mBAAJ,EAAyBV,OAAzB,CAApB;AACD,GATD;AAWA,SAAOa,KAAK,CAACC,IAAN,CAAWvB,MAAM,CAACwB,MAAP,EAAX,CAAP;AACD,CApBM;;AAsBP,MAAMjB,oBAAoB,GAAG,CAC3BF,KAD2B,EAE3BH,oBAF2B,EAG3B;AAAEuB,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAH2B,KAIE;AAC7B,QAAMC,gBAAgB,GAAGxB,oBAAoB,CAACE,KAAD,CAA7C;AAEA,QAAM,CAACuB,GAAD,EAAMC,GAAN,IACJJ,IAAI,KAAK,GAAT,GAAe,CAAC,MAAD,EAAS,MAAT,CAAf,GAAkC,CAAC,MAAD,EAAS,MAAT,CADpC;AAGA,QAAMK,aAAa,GAAG;AAAEpB,IAAAA,CAAC,EAAE,CAAL;AAAQC,IAAAA,CAAC,EAAE;AAAX,GAAtB;;AACA,MAAIe,QAAQ,KAAK,OAAjB,EAA0B;AACxB,WAAO,EACL,GAAGI,aADE;AAEL,OAACL,IAAD,GAAQvB,oBAAoB,CAAC0B,GAAD,CAApB,GAA4BD,gBAAgB,CAACC,GAAD;AAF/C,KAAP;AAID,GALD,MAKO,IAAIF,QAAQ,KAAK,KAAjB,EAAwB;AAC7B,WAAO,EACL,GAAGI,aADE;AAEL,OAACL,IAAD,GAAQvB,oBAAoB,CAAC2B,GAAD,CAApB,GAA4BF,gBAAgB,CAACE,GAAD;AAF/C,KAAP;AAID,GAjB4B,CAiB3B;;;AACF,SAAO,EACL,GAAGC,aADE;AAEL,KAACL,IAAD,GACE,CAACvB,oBAAoB,CAAC0B,GAAD,CAApB,GAA4B1B,oBAAoB,CAAC2B,GAAD,CAAjD,IAA0D,CAA1D,GACA,CAACF,gBAAgB,CAACC,GAAD,CAAhB,GAAwBD,gBAAgB,CAACE,GAAD,CAAzC,IAAkD;AAJ/C,GAAP;AAMD,CA5BD;;AA8BA,MAAM1B,oBAAoB,GAAIS,QAAD,IAAwC;AACnE,QAAM,CAACmB,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,IAAnB,IAA2BtC,eAAe,CAACgB,QAAD,CAAhD;AACA,SAAO;AAAEmB,IAAAA,IAAF;AAAQC,IAAAA,IAAR;AAAcC,IAAAA,IAAd;AAAoBC,IAAAA;AAApB,GAAP;AACD,CAHD","sourcesContent":["import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n): ExcalidrawElement[] => {\n  const groups: ExcalidrawElement[][] = getMaximumGroups(selectedElements);\n\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: Box,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return { minX, minY, maxX, maxY };\n};\n"]},"metadata":{},"sourceType":"module"}