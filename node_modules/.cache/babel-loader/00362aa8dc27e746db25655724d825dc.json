{"ast":null,"code":"import { getNonDeletedElements, isNonDeletedElement } from \"../element\";\n\nconst isIdKey = elementKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n\n  return false;\n};\n\nclass Scene {\n  constructor() {\n    this.callbacks = new Set();\n    this.nonDeletedElements = [];\n    this.elements = [];\n    this.elementsMap = new Map();\n  }\n\n  static mapElementToScene(elementKey, scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey) {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n\n    return this.sceneMapByElement.get(elementKey) || null;\n  } // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  } // TODO: getAllNonDeletedElements\n\n\n  getElements() {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id) {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(id) {\n    const element = this.getElement(id);\n\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n\n    return null;\n  } // TODO: Rename methods here, this is confusing\n\n\n  getNonDeletedElements(ids) {\n    const result = [];\n    ids.forEach(id => {\n      const element = this.getNonDeletedElement(id);\n\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach(element => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb) {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    }); // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n\n    this.callbacks.clear();\n  }\n\n}\n\nScene.sceneMapByElement = new WeakMap();\nScene.sceneMapById = new Map();\nexport default Scene;","map":{"version":3,"sources":["/var/www/html/excalidraw/src/scene/Scene.ts"],"names":["getNonDeletedElements","isNonDeletedElement","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elements","elementsMap","Map","mapElementToScene","scene","sceneMapById","set","sceneMapByElement","getScene","get","getElementsIncludingDeleted","getElements","getElement","id","getNonDeletedElement","element","ids","result","forEach","push","replaceAllElements","nextElements","clear","informMutation","callback","Array","from","addCallback","cb","has","Error","add","delete","destroy","WeakMap"],"mappings":"AAKA,SAASA,qBAAT,EAAgCC,mBAAhC,QAA2D,YAA3D;;AASA,MAAMC,OAAO,GAAIC,UAAD,IAAwD;AACtE,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD,CALD;;AAOA,MAAMC,KAAN,CAAY;AAAA;AAAA,SA2BFC,SA3BE,GA2BmC,IAAIC,GAAJ,EA3BnC;AAAA,SA6BFC,kBA7BE,GA6B2D,EA7B3D;AAAA,SA8BFC,QA9BE,GA8BuC,EA9BvC;AAAA,SA+BFC,WA/BE,GA+BY,IAAIC,GAAJ,EA/BZ;AAAA;;AAQV,SAAOC,iBAAP,CAAyBR,UAAzB,EAAiDS,KAAjD,EAA+D;AAC7D,QAAIV,OAAO,CAACC,UAAD,CAAX,EAAyB;AACvB,WAAKU,YAAL,CAAkBC,GAAlB,CAAsBX,UAAtB,EAAkCS,KAAlC;AACD,KAFD,MAEO;AACL,WAAKG,iBAAL,CAAuBD,GAAvB,CAA2BX,UAA3B,EAAuCS,KAAvC;AACD;AACF;;AAED,SAAOI,QAAP,CAAgBb,UAAhB,EAAsD;AACpD,QAAID,OAAO,CAACC,UAAD,CAAX,EAAyB;AACvB,aAAO,KAAKU,YAAL,CAAkBI,GAAlB,CAAsBd,UAAtB,KAAqC,IAA5C;AACD;;AACD,WAAO,KAAKY,iBAAL,CAAuBE,GAAvB,CAA2Bd,UAA3B,KAA0C,IAAjD;AACD,GArBS,CAuBV;AACA;AACA;;;AAQA;AACAe,EAAAA,2BAA2B,GAAG;AAC5B,WAAO,KAAKV,QAAZ;AACD,GApCS,CAsCV;;;AACAW,EAAAA,WAAW,GAA2C;AACpD,WAAO,KAAKZ,kBAAZ;AACD;;AAEDa,EAAAA,UAAU,CAACC,EAAD,EAAwD;AAChE,WAAO,KAAKZ,WAAL,CAAiBQ,GAAjB,CAAqBI,EAArB,KAA4B,IAAnC;AACD;;AAEDC,EAAAA,oBAAoB,CAClBD,EADkB,EAEoB;AACtC,UAAME,OAAO,GAAG,KAAKH,UAAL,CAAgBC,EAAhB,CAAhB;;AACA,QAAIE,OAAO,IAAItB,mBAAmB,CAACsB,OAAD,CAAlC,EAA6C;AAC3C,aAAOA,OAAP;AACD;;AACD,WAAO,IAAP;AACD,GAvDS,CAyDV;;;AACAvB,EAAAA,qBAAqB,CACnBwB,GADmB,EAEc;AACjC,UAAMC,MAAuC,GAAG,EAAhD;AACAD,IAAAA,GAAG,CAACE,OAAJ,CAAaL,EAAD,IAAQ;AAClB,YAAME,OAAO,GAAG,KAAKD,oBAAL,CAA0BD,EAA1B,CAAhB;;AACA,UAAIE,OAAO,IAAI,IAAf,EAAqB;AACnBE,QAAAA,MAAM,CAACE,IAAP,CAAYJ,OAAZ;AACD;AACF,KALD;AAMA,WAAOE,MAAP;AACD;;AAEDG,EAAAA,kBAAkB,CAACC,YAAD,EAA6C;AAC7D,SAAKrB,QAAL,GAAgBqB,YAAhB;AACA,SAAKpB,WAAL,CAAiBqB,KAAjB;AACAD,IAAAA,YAAY,CAACH,OAAb,CAAsBH,OAAD,IAAa;AAChC,WAAKd,WAAL,CAAiBK,GAAjB,CAAqBS,OAAO,CAACF,EAA7B,EAAiCE,OAAjC;AACAnB,MAAAA,KAAK,CAACO,iBAAN,CAAwBY,OAAxB,EAAiC,IAAjC;AACD,KAHD;AAIA,SAAKhB,kBAAL,GAA0BP,qBAAqB,CAAC,KAAKQ,QAAN,CAA/C;AACA,SAAKuB,cAAL;AACD;;AAEDA,EAAAA,cAAc,GAAG;AACf,SAAK,MAAMC,QAAX,IAAuBC,KAAK,CAACC,IAAN,CAAW,KAAK7B,SAAhB,CAAvB,EAAmD;AACjD2B,MAAAA,QAAQ;AACT;AACF;;AAEDG,EAAAA,WAAW,CAACC,EAAD,EAAoD;AAC7D,QAAI,KAAK/B,SAAL,CAAegC,GAAf,CAAmBD,EAAnB,CAAJ,EAA4B;AAC1B,YAAM,IAAIE,KAAJ,EAAN;AACD;;AAED,SAAKjC,SAAL,CAAekC,GAAf,CAAmBH,EAAnB;AAEA,WAAO,MAAM;AACX,UAAI,CAAC,KAAK/B,SAAL,CAAegC,GAAf,CAAmBD,EAAnB,CAAL,EAA6B;AAC3B,cAAM,IAAIE,KAAJ,EAAN;AACD;;AACD,WAAKjC,SAAL,CAAemC,MAAf,CAAsBJ,EAAtB;AACD,KALD;AAMD;;AAEDK,EAAAA,OAAO,GAAG;AACRrC,IAAAA,KAAK,CAACS,YAAN,CAAmBa,OAAnB,CAA2B,CAACd,KAAD,EAAQT,UAAR,KAAuB;AAChD,UAAIS,KAAK,KAAK,IAAd,EAAoB;AAClBR,QAAAA,KAAK,CAACS,YAAN,CAAmB2B,MAAnB,CAA0BrC,UAA1B;AACD;AACF,KAJD,EADQ,CAMR;AACA;;AACA,SAAKE,SAAL,CAAeyB,KAAf;AACD;;AAhHS;;AAAN1B,K,CAKWW,iB,GAAoB,IAAI2B,OAAJ,E;AAL/BtC,K,CAMWS,Y,GAAe,IAAIH,GAAJ,E;AA6GhC,eAAeN,KAAf","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  // TODO: getAllNonDeletedElements\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  // TODO: Rename methods here, this is confusing\n  getNonDeletedElements(\n    ids: readonly ExcalidrawElement[\"id\"][],\n  ): NonDeleted<ExcalidrawElement>[] {\n    const result: NonDeleted<ExcalidrawElement>[] = [];\n    ids.forEach((id) => {\n      const element = this.getNonDeletedElement(id);\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n"]},"metadata":{},"sourceType":"module"}