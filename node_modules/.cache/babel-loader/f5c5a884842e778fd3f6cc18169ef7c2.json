{"ast":null,"code":"const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\n\nfunction tokenize(d) {\n  const tokens = new Array();\n\n  while (d !== '') {\n    if (d.match(/^([ \\t\\r\\n,]+)/)) {\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n      tokens[tokens.length] = {\n        type: COMMAND,\n        text: RegExp.$1\n      };\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n      tokens[tokens.length] = {\n        type: NUMBER,\n        text: `${parseFloat(RegExp.$1)}`\n      };\n      d = d.substr(RegExp.$1.length);\n    } else {\n      return [];\n    }\n  }\n\n  tokens[tokens.length] = {\n    type: EOD,\n    text: ''\n  };\n  return tokens;\n}\n\nfunction isType(token, type) {\n  return token.type === type;\n}\n\nexport function parsePath(d) {\n  const segments = [];\n  const tokens = tokenize(d);\n  let mode = 'BOD';\n  let index = 0;\n  let token = tokens[index];\n\n  while (!isType(token, EOD)) {\n    let paramsCount = 0;\n    const params = [];\n\n    if (mode === 'BOD') {\n      if (token.text === 'M' || token.text === 'm') {\n        index++;\n        paramsCount = PARAMS[token.text];\n        mode = token.text;\n      } else {\n        return parsePath('M0,0' + d);\n      }\n    } else if (isType(token, NUMBER)) {\n      paramsCount = PARAMS[mode];\n    } else {\n      index++;\n      paramsCount = PARAMS[token.text];\n      mode = token.text;\n    }\n\n    if (index + paramsCount < tokens.length) {\n      for (let i = index; i < index + paramsCount; i++) {\n        const numbeToken = tokens[i];\n\n        if (isType(numbeToken, NUMBER)) {\n          params[params.length] = +numbeToken.text;\n        } else {\n          throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n        }\n      }\n\n      if (typeof PARAMS[mode] === 'number') {\n        const segment = {\n          key: mode,\n          data: params\n        };\n        segments.push(segment);\n        index += paramsCount;\n        token = tokens[index];\n        if (mode === 'M') mode = 'L';\n        if (mode === 'm') mode = 'l';\n      } else {\n        throw new Error('Bad segment: ' + mode);\n      }\n    } else {\n      throw new Error('Path data ended short');\n    }\n  }\n\n  return segments;\n}\nexport function serialize(segments) {\n  const tokens = [];\n\n  for (const {\n    key,\n    data\n  } of segments) {\n    tokens.push(key);\n\n    switch (key) {\n      case 'C':\n      case 'c':\n        tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n        break;\n\n      case 'S':\n      case 's':\n      case 'Q':\n      case 'q':\n        tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n        break;\n\n      default:\n        tokens.push(...data);\n        break;\n    }\n  }\n\n  return tokens.join(' ');\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/path-data-parser/lib/parser.js"],"names":["COMMAND","NUMBER","EOD","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","tokenize","d","tokens","Array","match","substr","RegExp","$1","length","type","text","parseFloat","isType","token","parsePath","segments","mode","index","paramsCount","params","i","numbeToken","Error","segment","key","data","push","serialize","join"],"mappings":"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","sourcesContent":["const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n"]},"metadata":{},"sourceType":"module"}