{"ast":null,"code":"import { getCommonBounds, getClosestElementBounds } from \"../element\";\nimport { sceneCoordsToViewportCoords, viewportCoordsToSceneCoords } from \"../utils\";\nexport const normalizeScroll = pos => Math.floor(pos);\n\nconst isOutsideViewPort = (appState, canvas, cords) => {\n  const [x1, y1, x2, y2] = cords;\n  const {\n    x: viewportX1,\n    y: viewportY1\n  } = sceneCoordsToViewportCoords({\n    sceneX: x1,\n    sceneY: y1\n  }, appState);\n  const {\n    x: viewportX2,\n    y: viewportY2\n  } = sceneCoordsToViewportCoords({\n    sceneX: x2,\n    sceneY: y2\n  }, appState);\n  return viewportX2 - viewportX1 > appState.width || viewportY2 - viewportY1 > appState.height;\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom\n}) => {\n  return {\n    scrollX: normalizeScroll(viewportDimensions.width / 2 * (1 / zoom.value) - scenePoint.x - zoom.translation.x * (1 / zoom.value)),\n    scrollY: normalizeScroll(viewportDimensions.height / 2 * (1 / zoom.value) - scenePoint.y - zoom.translation.y * (1 / zoom.value))\n  };\n};\nexport const calculateScrollCenter = (elements, appState, canvas) => {\n  if (!elements.length) {\n    return {\n      scrollX: normalizeScroll(0),\n      scrollY: normalizeScroll(0)\n    };\n  }\n\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(elements, viewportCoordsToSceneCoords({\n      clientX: appState.scrollX,\n      clientY: appState.scrollY\n    }, appState));\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n  return centerScrollOn({\n    scenePoint: {\n      x: centerX,\n      y: centerY\n    },\n    viewportDimensions: {\n      width: appState.width,\n      height: appState.height\n    },\n    zoom: appState.zoom\n  });\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/scene/scroll.ts"],"names":["getCommonBounds","getClosestElementBounds","sceneCoordsToViewportCoords","viewportCoordsToSceneCoords","normalizeScroll","pos","Math","floor","isOutsideViewPort","appState","canvas","cords","x1","y1","x2","y2","x","viewportX1","y","viewportY1","sceneX","sceneY","viewportX2","viewportY2","width","height","centerScrollOn","scenePoint","viewportDimensions","zoom","scrollX","value","translation","scrollY","calculateScrollCenter","elements","length","clientX","clientY","centerX","centerY"],"mappings":"AAEA,SAASA,eAAT,EAA0BC,uBAA1B,QAAyD,YAAzD;AAEA,SACEC,2BADF,EAEEC,2BAFF,QAGO,UAHP;AAKA,OAAO,MAAMC,eAAe,GAAIC,GAAD,IAC7BC,IAAI,CAACC,KAAL,CAAWF,GAAX,CADK;;AAGP,MAAMG,iBAAiB,GAAG,CACxBC,QADwB,EAExBC,MAFwB,EAGxBC,KAHwB,KAIrB;AACH,QAAM,CAACC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,IAAmBJ,KAAzB;AACA,QAAM;AAAEK,IAAAA,CAAC,EAAEC,UAAL;AAAiBC,IAAAA,CAAC,EAAEC;AAApB,MAAmCjB,2BAA2B,CAClE;AAAEkB,IAAAA,MAAM,EAAER,EAAV;AAAcS,IAAAA,MAAM,EAAER;AAAtB,GADkE,EAElEJ,QAFkE,CAApE;AAIA,QAAM;AAAEO,IAAAA,CAAC,EAAEM,UAAL;AAAiBJ,IAAAA,CAAC,EAAEK;AAApB,MAAmCrB,2BAA2B,CAClE;AAAEkB,IAAAA,MAAM,EAAEN,EAAV;AAAcO,IAAAA,MAAM,EAAEN;AAAtB,GADkE,EAElEN,QAFkE,CAApE;AAIA,SACEa,UAAU,GAAGL,UAAb,GAA0BR,QAAQ,CAACe,KAAnC,IACAD,UAAU,GAAGJ,UAAb,GAA0BV,QAAQ,CAACgB,MAFrC;AAID,CAlBD;;AAoBA,OAAO,MAAMC,cAAc,GAAG,CAAC;AAC7BC,EAAAA,UAD6B;AAE7BC,EAAAA,kBAF6B;AAG7BC,EAAAA;AAH6B,CAAD,KAQxB;AACJ,SAAO;AACLC,IAAAA,OAAO,EAAE1B,eAAe,CACrBwB,kBAAkB,CAACJ,KAAnB,GAA2B,CAA5B,IAAkC,IAAIK,IAAI,CAACE,KAA3C,IACEJ,UAAU,CAACX,CADb,GAEEa,IAAI,CAACG,WAAL,CAAiBhB,CAAjB,IAAsB,IAAIa,IAAI,CAACE,KAA/B,CAHoB,CADnB;AAMLE,IAAAA,OAAO,EAAE7B,eAAe,CACrBwB,kBAAkB,CAACH,MAAnB,GAA4B,CAA7B,IAAmC,IAAII,IAAI,CAACE,KAA5C,IACEJ,UAAU,CAACT,CADb,GAEEW,IAAI,CAACG,WAAL,CAAiBd,CAAjB,IAAsB,IAAIW,IAAI,CAACE,KAA/B,CAHoB;AANnB,GAAP;AAYD,CArBM;AAuBP,OAAO,MAAMG,qBAAqB,GAAG,CACnCC,QADmC,EAEnC1B,QAFmC,EAGnCC,MAHmC,KAIoB;AACvD,MAAI,CAACyB,QAAQ,CAACC,MAAd,EAAsB;AACpB,WAAO;AACLN,MAAAA,OAAO,EAAE1B,eAAe,CAAC,CAAD,CADnB;AAEL6B,MAAAA,OAAO,EAAE7B,eAAe,CAAC,CAAD;AAFnB,KAAP;AAID;;AACD,MAAI,CAACQ,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,IAAmBf,eAAe,CAACmC,QAAD,CAAtC;;AAEA,MAAI3B,iBAAiB,CAACC,QAAD,EAAWC,MAAX,EAAmB,CAACE,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAnB,CAArB,EAA2D;AACzD,KAACH,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,IAAmBd,uBAAuB,CACxCkC,QADwC,EAExChC,2BAA2B,CACzB;AAAEkC,MAAAA,OAAO,EAAE5B,QAAQ,CAACqB,OAApB;AAA6BQ,MAAAA,OAAO,EAAE7B,QAAQ,CAACwB;AAA/C,KADyB,EAEzBxB,QAFyB,CAFa,CAA1C;AAOD;;AAED,QAAM8B,OAAO,GAAG,CAAC3B,EAAE,GAAGE,EAAN,IAAY,CAA5B;AACA,QAAM0B,OAAO,GAAG,CAAC3B,EAAE,GAAGE,EAAN,IAAY,CAA5B;AAEA,SAAOW,cAAc,CAAC;AACpBC,IAAAA,UAAU,EAAE;AAAEX,MAAAA,CAAC,EAAEuB,OAAL;AAAcrB,MAAAA,CAAC,EAAEsB;AAAjB,KADQ;AAEpBZ,IAAAA,kBAAkB,EAAE;AAAEJ,MAAAA,KAAK,EAAEf,QAAQ,CAACe,KAAlB;AAAyBC,MAAAA,MAAM,EAAEhB,QAAQ,CAACgB;AAA1C,KAFA;AAGpBI,IAAAA,IAAI,EAAEpB,QAAQ,CAACoB;AAHK,GAAD,CAArB;AAKD,CA/BM","sourcesContent":["import { AppState, FlooredNumber, PointerCoords, Zoom } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds, getClosestElementBounds } from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nexport const normalizeScroll = (pos: number) =>\n  Math.floor(pos) as FlooredNumber;\n\nconst isOutsideViewPort = (\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) => {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom,\n}: {\n  scenePoint: PointerCoords;\n  viewportDimensions: { height: number; width: number };\n  zoom: Zoom;\n}) => {\n  return {\n    scrollX: normalizeScroll(\n      (viewportDimensions.width / 2) * (1 / zoom.value) -\n        scenePoint.x -\n        zoom.translation.x * (1 / zoom.value),\n    ),\n    scrollY: normalizeScroll(\n      (viewportDimensions.height / 2) * (1 / zoom.value) -\n        scenePoint.y -\n        zoom.translation.y * (1 / zoom.value),\n    ),\n  };\n};\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: FlooredNumber; scrollY: FlooredNumber } => {\n  if (!elements.length) {\n    return {\n      scrollX: normalizeScroll(0),\n      scrollY: normalizeScroll(0),\n    };\n  }\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: { width: appState.width, height: appState.height },\n    zoom: appState.zoom,\n  });\n};\n"]},"metadata":{},"sourceType":"module"}