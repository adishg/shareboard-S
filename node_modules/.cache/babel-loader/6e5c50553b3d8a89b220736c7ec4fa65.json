{"ast":null,"code":"import { isTextElement, isLinearElement } from \"../element/typeChecks\";\nimport { getDiamondPoints, getElementAbsoluteCoords, getArrowheadPoints } from \"../element/bounds\";\nimport { SVG_NS, distance, getFontString, getFontFamilyString, isRTL } from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { getDefaultAppState } from \"../appState\";\nconst defaultAppState = getDefaultAppState();\nconst CANVAS_PADDING = 20;\nconst DASHARRAY_DASHED = [12, 8];\nconst DASHARRAY_DOTTED = [3, 6];\n\nconst generateElementCanvas = (element, zoom) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width = distance(x1, x2) * window.devicePixelRatio * zoom.value + CANVAS_PADDING * zoom.value * 2;\n    canvas.height = distance(y1, y2) * window.devicePixelRatio * zoom.value + CANVAS_PADDING * zoom.value * 2;\n    canvasOffsetX = element.x > x1 ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio * zoom.value : 0;\n    canvasOffsetY = element.y > y1 ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio * zoom.value : 0;\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width = element.width * window.devicePixelRatio * zoom.value + CANVAS_PADDING * zoom.value * 2;\n    canvas.height = element.height * window.devicePixelRatio * zoom.value + CANVAS_PADDING * zoom.value * 2;\n  }\n\n  context.translate(CANVAS_PADDING * zoom.value, CANVAS_PADDING * zoom.value);\n  context.scale(window.devicePixelRatio * zoom.value, window.devicePixelRatio * zoom.value);\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-(CANVAS_PADDING * zoom.value), -(CANVAS_PADDING * zoom.value));\n  context.scale(1 / (window.devicePixelRatio * zoom.value), 1 / (window.devicePixelRatio * zoom.value));\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY\n  };\n};\n\nconst drawElementOnCanvas = (element, rc, context) => {\n  context.globalAlpha = element.opacity / 100;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        rc.draw(getShapeForElement(element));\n        break;\n      }\n\n    case \"arrow\":\n    case \"draw\":\n    case \"line\":\n      {\n        getShapeForElement(element).forEach(shape => {\n          rc.draw(shape);\n        });\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          const rtl = isRTL(element.text);\n          const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n\n          if (shouldTemporarilyAttach) {\n            // to correctly render RTL text mixed with LTR, we have to append it\n            // to the DOM\n            document.body.appendChild(context.canvas);\n          }\n\n          context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n          const font = context.font;\n          context.font = getFontString(element);\n          const fillStyle = context.fillStyle;\n          context.fillStyle = element.strokeColor;\n          const textAlign = context.textAlign;\n          context.textAlign = element.textAlign; // Canvas does not support multiline text by default\n\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const lineHeight = element.height / lines.length;\n          const verticalOffset = element.height - element.baseline;\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n\n          for (let index = 0; index < lines.length; index++) {\n            context.fillText(lines[index], horizontalOffset, (index + 1) * lineHeight - verticalOffset);\n          }\n\n          context.fillStyle = fillStyle;\n          context.font = font;\n          context.textAlign = textAlign;\n\n          if (shouldTemporarilyAttach) {\n            context.canvas.remove();\n          }\n        } else {\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap();\nconst shapeCache = new WeakMap();\nexport const getShapeForElement = element => shapeCache.get(element);\nexport const invalidateShapeForElement = element => shapeCache.delete(element);\nexport const generateRoughOptions = element => {\n  const options = {\n    seed: element.seed,\n    strokeLineDash: element.strokeStyle === \"dashed\" ? DASHARRAY_DASHED : element.strokeStyle === \"dotted\" ? DASHARRAY_DOTTED : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth: element.strokeStyle !== \"solid\" ? element.strokeWidth + 0.5 : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        options.fillStyle = element.fillStyle;\n        options.fill = element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor;\n\n        if (element.type === \"ellipse\") {\n          options.curveFitting = 1;\n        }\n\n        return options;\n      }\n\n    case \"line\":\n    case \"draw\":\n      {\n        // If shape is a line and is a closed shape,\n        // fill the shape if a color is set.\n        if (isPathALoop(element.points)) {\n          options.fillStyle = element.fillStyle;\n          options.fill = element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor;\n        }\n\n        return options;\n      }\n\n    case \"arrow\":\n      return options;\n\n    default:\n      {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n  }\n};\n\nconst generateElementShape = (element, generator) => {\n  let shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(`M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${h - r} Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${h - r} L 0 ${r} Q 0 0, ${r} 0`, generateRoughOptions(element));\n        } else {\n          shape = generator.rectangle(0, 0, element.width, element.height, generateRoughOptions(element));\n        }\n\n        break;\n\n      case \"diamond\":\n        {\n          const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);\n          shape = generator.polygon([[topX, topY], [rightX, rightY], [bottomX, bottomY], [leftX, leftY]], generateRoughOptions(element));\n          break;\n        }\n\n      case \"ellipse\":\n        shape = generator.ellipse(element.width / 2, element.height / 2, element.width, element.height, generateRoughOptions(element));\n        break;\n\n      case \"line\":\n      case \"draw\":\n      case \"arrow\":\n        {\n          const options = generateRoughOptions(element); // points array can be empty in the beginning, so it is important to add\n          // initial position to it\n\n          const points = element.points.length ? element.points : [[0, 0]]; // curve is always the first element\n          // this simplifies finding the curve for an element\n\n          if (element.strokeSharpness === \"sharp\") {\n            if (options.fill) {\n              shape = [generator.polygon(points, options)];\n            } else {\n              shape = [generator.linearPath(points, options)];\n            }\n          } else {\n            shape = [generator.curve(points, options)];\n          } // add lines only in arrow\n\n\n          if (element.type === \"arrow\") {\n            const {\n              startArrowhead = null,\n              endArrowhead = \"arrow\"\n            } = element;\n\n            function getArrowheadShapes(element, shape, position, arrowhead) {\n              const arrowheadPoints = getArrowheadPoints(element, shape, position, arrowhead);\n\n              if (arrowheadPoints === null) {\n                return [];\n              } // Other arrowheads here...\n\n\n              if (arrowhead === \"dot\") {\n                const [x, y, r] = arrowheadPoints;\n                return [generator.circle(x, y, r, { ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\"\n                })];\n              } // Arrow arrowheads\n\n\n              const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n              if (element.strokeStyle === \"dotted\") {\n                // for dotted arrows caps, reduce gap to make it more legible\n                options.strokeLineDash = [3, 4];\n              } else {\n                // for solid/dashed, keep solid arrow cap\n                delete options.strokeLineDash;\n              }\n\n              return [generator.line(x3, y3, x2, y2, options), generator.line(x4, y4, x2, y2, options)];\n            }\n\n            if (startArrowhead !== null) {\n              const shapes = getArrowheadShapes(element, shape, \"start\", startArrowhead);\n              shape.push(...shapes);\n            }\n\n            if (endArrowhead !== null) {\n              if (endArrowhead === undefined) {// Hey, we have an old arrow here!\n              }\n\n              const shapes = getArrowheadShapes(element, shape, \"end\", endArrowhead);\n              shape.push(...shapes);\n            }\n          }\n\n          break;\n        }\n\n      case \"text\":\n        {\n          // just to ensure we don't regenerate element.canvas on rerenders\n          shape = [];\n          break;\n        }\n    }\n\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (element, sceneState) => {\n  const zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.canvasZoom !== zoom.value && !(sceneState === null || sceneState === void 0 ? void 0 : sceneState.shouldCacheIgnoreZoom);\n\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (elementWithCanvas, rc, context, sceneState) => {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(elementWithCanvas.canvas, -(x2 - x1) / 2 * window.devicePixelRatio - CANVAS_PADDING * elementWithCanvas.canvasZoom / elementWithCanvas.canvasZoom, -(y2 - y1) / 2 * window.devicePixelRatio - CANVAS_PADDING * elementWithCanvas.canvasZoom / elementWithCanvas.canvasZoom, elementWithCanvas.canvas.width / elementWithCanvas.canvasZoom, elementWithCanvas.canvas.height / elementWithCanvas.canvasZoom);\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio); // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (element, rc, context, renderOptimizations, sceneState) => {\n  const generator = rc.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        context.translate(element.x + sceneState.scrollX, element.y + sceneState.scrollY);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n        context.fillRect(0, 0, element.width, element.height);\n        context.fillStyle = fillStyle;\n        context.translate(-element.x - sceneState.scrollX, -element.y - sceneState.scrollY);\n        break;\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n    case \"text\":\n      {\n        generateElementShape(element, generator);\n\n        if (renderOptimizations) {\n          const elementWithCanvas = generateElementWithCanvas(element, sceneState);\n          drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n        } else {\n          const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n          const cx = (x1 + x2) / 2 + sceneState.scrollX;\n          const cy = (y1 + y2) / 2 + sceneState.scrollY;\n          const shiftX = (x2 - x1) / 2 - (element.x - x1);\n          const shiftY = (y2 - y1) / 2 - (element.y - y1);\n          context.translate(cx, cy);\n          context.rotate(element.angle);\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context);\n          context.translate(shiftX, shiftY);\n          context.rotate(-element.angle);\n          context.translate(-cx, -cy);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n  }\n};\nexport const renderElementToSvg = (element, rsvg, svgRoot, offsetX, offsetY) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = 180 * element.angle / Math.PI;\n  const generator = rsvg.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        // Since this is used only during editing experience, which is canvas based,\n        // this should not happen\n        throw new Error(\"Selection rendering is not supported for SVG\");\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        generateElementShape(element, generator);\n        const node = rsvg.draw(getShapeForElement(element));\n        const opacity = element.opacity / 100;\n\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n\n        node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n        svgRoot.appendChild(node);\n        break;\n      }\n\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n      {\n        generateElementShape(element, generator);\n        const group = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n        const opacity = element.opacity / 100;\n        getShapeForElement(element).forEach(shape => {\n          const node = rsvg.draw(shape);\n\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n\n          if ((element.type === \"line\" || element.type === \"draw\") && isPathALoop(element.points) && element.backgroundColor !== \"transparent\") {\n            node.setAttribute(\"fill-rule\", \"evenodd\");\n          }\n\n          group.appendChild(node);\n        });\n        svgRoot.appendChild(group);\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          const opacity = element.opacity / 100;\n          const node = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const lineHeight = element.height / lines.length;\n          const verticalOffset = element.height - element.baseline;\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n          const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n          const textAnchor = element.textAlign === \"center\" ? \"middle\" : element.textAlign === \"right\" || direction === \"rtl\" ? \"end\" : \"start\";\n\n          for (let i = 0; i < lines.length; i++) {\n            const text = svgRoot.ownerDocument.createElementNS(SVG_NS, \"text\");\n            text.textContent = lines[i];\n            text.setAttribute(\"x\", `${horizontalOffset}`);\n            text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n            text.setAttribute(\"font-family\", getFontFamilyString(element));\n            text.setAttribute(\"font-size\", `${element.fontSize}px`);\n            text.setAttribute(\"fill\", element.strokeColor);\n            text.setAttribute(\"text-anchor\", textAnchor);\n            text.setAttribute(\"style\", \"white-space: pre;\");\n            text.setAttribute(\"direction\", direction);\n            node.appendChild(text);\n          }\n\n          svgRoot.appendChild(node);\n        } else {\n          // @ts-ignore\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/renderer/renderElement.ts"],"names":["isTextElement","isLinearElement","getDiamondPoints","getElementAbsoluteCoords","getArrowheadPoints","SVG_NS","distance","getFontString","getFontFamilyString","isRTL","isPathALoop","rough","getDefaultAppState","defaultAppState","CANVAS_PADDING","DASHARRAY_DASHED","DASHARRAY_DOTTED","generateElementCanvas","element","zoom","canvas","document","createElement","context","getContext","canvasOffsetX","canvasOffsetY","x1","y1","x2","y2","width","window","devicePixelRatio","value","height","x","Math","floor","y","translate","scale","rc","drawElementOnCanvas","canvasZoom","globalAlpha","opacity","type","draw","getShapeForElement","forEach","shape","rtl","text","shouldTemporarilyAttach","isConnected","body","appendChild","setAttribute","font","fillStyle","strokeColor","textAlign","lines","replace","split","lineHeight","length","verticalOffset","baseline","horizontalOffset","index","fillText","remove","Error","elementWithCanvasCache","WeakMap","shapeCache","get","invalidateShapeForElement","delete","generateRoughOptions","options","seed","strokeLineDash","strokeStyle","undefined","disableMultiStroke","strokeWidth","fillWeight","hachureGap","roughness","stroke","fill","backgroundColor","curveFitting","points","generateElementShape","generator","strokeSharpness","w","h","r","min","path","rectangle","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","polygon","ellipse","linearPath","curve","startArrowhead","endArrowhead","getArrowheadShapes","position","arrowhead","arrowheadPoints","circle","x3","y3","x4","y4","line","shapes","push","set","generateElementWithCanvas","sceneState","prevElementWithCanvas","shouldRegenerateBecauseZoom","shouldCacheIgnoreZoom","elementWithCanvas","drawElementFromCanvas","cx","scrollX","cy","scrollY","rotate","angle","drawImage","renderElement","renderOptimizations","fillRect","shiftX","shiftY","renderElementToSvg","rsvg","svgRoot","offsetX","offsetY","degree","PI","node","group","ownerDocument","createElementNS","direction","textAnchor","i","textContent","fontSize"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { isTextElement, isLinearElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst CANVAS_PADDING = 20;\n\nconst DASHARRAY_DASHED = [12, 8];\nconst DASHARRAY_DOTTED = [3, 6];\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: Zoom[\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n  }\n\n  context.translate(CANVAS_PADDING * zoom.value, CANVAS_PADDING * zoom.value);\n\n  context.scale(\n    window.devicePixelRatio * zoom.value,\n    window.devicePixelRatio * zoom.value,\n  );\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(\n    -(CANVAS_PADDING * zoom.value),\n    -(CANVAS_PADDING * zoom.value),\n  );\n  context.scale(\n    1 / (window.devicePixelRatio * zoom.value),\n    1 / (window.devicePixelRatio * zoom.value),\n  );\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n  };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"draw\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (element: ExcalidrawElement): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? DASHARRAY_DASHED\n        : element.strokeStyle === \"dotted\"\n        ? DASHARRAY_DOTTED\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"draw\": {\n      // If shape is a line and is a closed shape,\n      // fill the shape if a color is set.\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"draw\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (element.strokeSharpness === \"sharp\") {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          function getArrowheadShapes(\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                }),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              options.strokeLineDash = [3, 4];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          }\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom: Zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom.value &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      (CANVAS_PADDING * elementWithCanvas.canvasZoom) /\n        elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      (CANVAS_PADDING * elementWithCanvas.canvasZoom) /\n        elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"draw\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          (element.type === \"line\" || element.type === \"draw\") &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}