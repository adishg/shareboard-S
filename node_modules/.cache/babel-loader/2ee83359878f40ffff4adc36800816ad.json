{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/actions/actionFinalize.tsx\";\nimport { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { resetCursor } from \"../utils\";\nimport React from \"react\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport { maybeBindLinearElement, bindOrUnbindLinearElement } from \"../element/binding\";\nimport { isBindingElement } from \"../element/typeChecks\";\nexport const actionFinalize = register({\n  name: \"finalize\",\n  perform: (elements, appState) => {\n    var _appState$editingElem;\n\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        startBindingElement,\n        endBindingElement\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(element, startBindingElement, endBindingElement);\n        }\n\n        return {\n          elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter(el => el.id !== element.id) : undefined,\n          appState: { ...appState,\n            editingLinearElement: null\n          },\n          commitToHistory: true\n        };\n      }\n    }\n\n    let newElements = elements;\n\n    if (window.document.activeElement instanceof HTMLElement) {\n      window.document.activeElement.blur();\n    }\n\n    const multiPointElement = appState.multiElement ? appState.multiElement : ((_appState$editingElem = appState.editingElement) === null || _appState$editingElem === void 0 ? void 0 : _appState$editingElem.type) === \"draw\" ? appState.editingElement : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (multiPointElement.type !== \"draw\" && appState.lastPointerDownWith !== \"touch\") {\n        const {\n          points,\n          lastCommittedPoint\n        } = multiPointElement;\n\n        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1)\n          });\n        }\n      }\n\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      } // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n\n\n      const isLoop = isPathALoop(multiPointElement.points);\n\n      if (multiPointElement.type === \"line\" || multiPointElement.type === \"draw\") {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) => index === linePoints.length - 1 ? [firstPoint[0], firstPoint[1]] : point)\n          });\n        }\n      }\n\n      if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(multiPointElement, -1);\n        maybeBindLinearElement(multiPointElement, appState, Scene.getScene(multiPointElement), {\n          x,\n          y\n        });\n      }\n\n      if (!appState.elementLocked && appState.elementType !== \"draw\") {\n        appState.selectedElementIds[multiPointElement.id] = true;\n      }\n    }\n\n    if (!appState.elementLocked && appState.elementType !== \"draw\" || !multiPointElement) {\n      resetCursor();\n    }\n\n    return {\n      elements: newElements,\n      appState: { ...appState,\n        elementType: (appState.elementLocked || appState.elementType === \"draw\") && multiPointElement ? appState.elementType : \"selection\",\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds: multiPointElement && !appState.elementLocked && appState.elementType !== \"draw\" ? { ...appState.selectedElementIds,\n          [multiPointElement.id]: true\n        } : appState.selectedElementIds\n      },\n      commitToHistory: appState.elementType === \"draw\"\n    };\n  },\n  keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.draggingElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,\n  PanelComponent: ({\n    appState,\n    updateData\n  }) => /*#__PURE__*/_jsxDEV(ToolButton, {\n    type: \"button\",\n    icon: done,\n    title: t(\"buttons.done\"),\n    \"aria-label\": t(\"buttons.done\"),\n    onClick: updateData,\n    visible: appState.multiElement != null\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 165,\n    columnNumber: 5\n  }, this)\n});","map":{"version":3,"sources":["/var/www/html/excalidraw/src/actions/actionFinalize.tsx"],"names":["KEYS","isInvisiblySmallElement","resetCursor","React","ToolButton","done","t","register","mutateElement","isPathALoop","LinearElementEditor","Scene","maybeBindLinearElement","bindOrUnbindLinearElement","isBindingElement","actionFinalize","name","perform","elements","appState","editingLinearElement","elementId","startBindingElement","endBindingElement","element","getElement","points","length","filter","el","id","undefined","commitToHistory","newElements","window","document","activeElement","HTMLElement","blur","multiPointElement","multiElement","editingElement","type","lastPointerDownWith","lastCommittedPoint","slice","isLoop","linePoints","firstPoint","map","point","index","x","y","getPointAtIndexGlobalCoordinates","getScene","elementLocked","elementType","selectedElementIds","draggingElement","startBoundElement","suggestedBindings","keyTest","event","key","ESCAPE","ENTER","PanelComponent","updateData"],"mappings":"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","sourcesContent":["import { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { resetCursor } from \"../utils\";\nimport React from \"react\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n} from \"../element/binding\";\nimport { isBindingElement } from \"../element/typeChecks\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n          );\n        }\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            editingLinearElement: null,\n          },\n          commitToHistory: true,\n        };\n      }\n    }\n\n    let newElements = elements;\n    if (window.document.activeElement instanceof HTMLElement) {\n      window.document.activeElement.blur();\n    }\n\n    const multiPointElement = appState.multiElement\n      ? appState.multiElement\n      : appState.editingElement?.type === \"draw\"\n      ? appState.editingElement\n      : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (\n        multiPointElement.type !== \"draw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = multiPointElement;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1),\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points);\n      if (\n        multiPointElement.type === \"line\" ||\n        multiPointElement.type === \"draw\"\n      ) {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) =>\n              index === linePoints.length - 1\n                ? ([firstPoint[0], firstPoint[1]] as const)\n                : point,\n            ),\n          });\n        }\n      }\n\n      if (\n        isBindingElement(multiPointElement) &&\n        !isLoop &&\n        multiPointElement.points.length > 1\n      ) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          multiPointElement,\n          -1,\n        );\n        maybeBindLinearElement(\n          multiPointElement,\n          appState,\n          Scene.getScene(multiPointElement)!,\n          { x, y },\n        );\n      }\n\n      if (!appState.elementLocked && appState.elementType !== \"draw\") {\n        appState.selectedElementIds[multiPointElement.id] = true;\n      }\n    }\n    if (\n      (!appState.elementLocked && appState.elementType !== \"draw\") ||\n      !multiPointElement\n    ) {\n      resetCursor();\n    }\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        elementType:\n          (appState.elementLocked || appState.elementType === \"draw\") &&\n          multiPointElement\n            ? appState.elementType\n            : \"selection\",\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          multiPointElement &&\n          !appState.elementLocked &&\n          appState.elementType !== \"draw\"\n            ? {\n                ...appState.selectedElementIds,\n                [multiPointElement.id]: true,\n              }\n            : appState.selectedElementIds,\n      },\n      commitToHistory: appState.elementType === \"draw\",\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.draggingElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n    />\n  ),\n});\n"]},"metadata":{},"sourceType":"module"}