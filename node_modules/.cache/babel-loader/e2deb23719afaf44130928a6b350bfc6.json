{"ast":null,"code":"import { cleanAppStateForExport } from \"../appState\";\nimport { MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { restore } from \"./restore\";\n\nconst parseFileContents = async blob => {\n  let contents;\n\n  if (blob.type === \"image/png\") {\n    try {\n      return await (await import(\n      /* webpackChunkName: \"image\" */\n      \"./image\")).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n      } else {\n        throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise(resolve => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result);\n          }\n        };\n      });\n    }\n\n    if (blob.type === \"image/svg+xml\") {\n      try {\n        return await (await import(\n        /* webpackChunkName: \"image\" */\n        \"./image\")).decodeSvgMetadata({\n          svg: contents\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n        } else {\n          throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n        }\n      }\n    }\n  }\n\n  return contents;\n};\n\nexport const getMimeType = blob => {\n  let name;\n\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n\n    name = blob.name || \"\";\n  }\n\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return \"application/json\";\n  } else if (/\\.png$/.test(name)) {\n    return \"image/png\";\n  } else if (/\\.jpe?g$/.test(name)) {\n    return \"image/jpeg\";\n  } else if (/\\.svg$/.test(name)) {\n    return \"image/svg+xml\";\n  }\n\n  return \"\";\n};\nexport const loadFromBlob = async (blob, localAppState) => {\n  const contents = await parseFileContents(blob);\n\n  try {\n    const data = JSON.parse(contents);\n\n    if (data.type !== \"excalidraw\") {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n\n    const result = restore({\n      elements: clearElementsForExport(data.elements || []),\n      appState: {\n        appearance: localAppState === null || localAppState === void 0 ? void 0 : localAppState.appearance,\n        fileHandle: blob.handle && [\"application/json\", MIME_TYPES.excalidraw].includes(getMimeType(blob)) ? blob.handle : null,\n        ...cleanAppStateForExport(data.appState || {}),\n        ...(localAppState ? calculateScrollCenter(data.elements || [], localAppState, null) : {})\n      }\n    }, localAppState);\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\nexport const loadLibraryFromBlob = async blob => {\n  const contents = await parseFileContents(blob);\n  const data = JSON.parse(contents);\n\n  if (data.type !== \"excalidrawlib\") {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n\n  return data;\n};\nexport const canvasToBlob = async (canvas) => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(blob => {\n        if (!blob) {\n          return reject(new CanvasError(t(\"canvasError.canvasTooBig\"), \"CANVAS_POSSIBLY_TOO_BIG\"));\n        }\n\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/data/blob.ts"],"names":["cleanAppStateForExport","MIME_TYPES","clearElementsForExport","CanvasError","t","calculateScrollCenter","restore","parseFileContents","blob","contents","type","decodePngMetadata","error","message","Error","Blob","text","Promise","resolve","reader","FileReader","readAsText","onloadend","readyState","DONE","result","decodeSvgMetadata","svg","getMimeType","name","test","loadFromBlob","localAppState","data","JSON","parse","elements","appState","appearance","fileHandle","handle","excalidraw","includes","console","loadLibraryFromBlob","canvasToBlob","canvas","reject","toBlob"],"mappings":"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","sourcesContent":["import { cleanAppStateForExport } from \"../appState\";\nimport { MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { restore } from \"./restore\";\nimport { ImportedDataState, LibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === \"image/png\") {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n      } else {\n        throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === \"image/svg+xml\") {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n        } else {\n          throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return \"application/json\";\n  } else if (/\\.png$/.test(name)) {\n    return \"image/png\";\n  } else if (/\\.jpe?g$/.test(name)) {\n    return \"image/jpeg\";\n  } else if (/\\.svg$/.test(name)) {\n    return \"image/svg+xml\";\n  }\n  return \"\";\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data: ImportedDataState = JSON.parse(contents);\n    if (data.type !== \"excalidraw\") {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore(\n      {\n        elements: clearElementsForExport(data.elements || []),\n        appState: {\n          appearance: localAppState?.appearance,\n          fileHandle:\n            blob.handle &&\n            [\"application/json\", MIME_TYPES.excalidraw].includes(\n              getMimeType(blob),\n            )\n              ? blob.handle\n              : null,\n          ...cleanAppStateForExport(data.appState || {}),\n          ...(localAppState\n            ? calculateScrollCenter(data.elements || [], localAppState, null)\n            : {}),\n        },\n      },\n      localAppState,\n    );\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: LibraryData = JSON.parse(contents);\n  if (data.type !== \"excalidrawlib\") {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n"]},"metadata":{},"sourceType":"module"}