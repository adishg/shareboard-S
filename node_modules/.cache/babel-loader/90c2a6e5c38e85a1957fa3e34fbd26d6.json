{"ast":null,"code":"import { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\n\nconst clearAppStatePropertiesForHistory = appState => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name\n  };\n};\n\nexport class SceneHistory {\n  constructor() {\n    this.elementCache = new Map();\n    this.recording = true;\n    this.stateHistory = [];\n    this.redoStack = [];\n    this.lastEntry = null;\n\n    this.generateEntry = (appState, elements) => this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (isLinearElement(element) && appState.multiElement && appState.multiElement.id === element.id) {\n          // don't store multi-point arrow if still has only one point\n          if (appState.multiElement && appState.multiElement.id === element.id && element.points.length < 2) {\n            return elements;\n          }\n\n          elements.push({ ...element,\n            // don't store last point if not committed\n            points: element.lastCommittedPoint !== element.points[element.points.length - 1] ? element.points.slice(0, -1) : element.points\n          });\n        } else {\n          elements.push(element);\n        }\n\n        return elements;\n      }, [])\n    });\n  }\n\n  hydrateHistoryEntry({\n    appState,\n    elements\n  }) {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map(dehydratedExcalidrawElement => {\n        var _this$elementCache$ge;\n\n        const element = (_this$elementCache$ge = this.elementCache.get(dehydratedExcalidrawElement.id)) === null || _this$elementCache$ge === void 0 ? void 0 : _this$elementCache$ge.get(dehydratedExcalidrawElement.versionNonce);\n\n        if (!element) {\n          throw new Error(`Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`);\n        }\n\n        return element;\n      })\n    };\n  }\n\n  dehydrateHistoryEntry({\n    appState,\n    elements\n  }) {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map(element => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n\n        const versions = this.elementCache.get(element.id);\n\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce\n        };\n      })\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map(dehydratedHistoryEntry => this.hydrateHistoryEntry(dehydratedHistoryEntry)),\n      redoStack: this.redoStack.map(dehydratedHistoryEntry => this.hydrateHistoryEntry(dehydratedHistoryEntry))\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  shouldCreateEntry(nextEntry) {\n    const {\n      lastEntry\n    } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    } // loop from right to left as changes are likelier to happen on new elements\n\n\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n\n      if (!prev || !next || prev.id !== next.id || prev.versionNonce !== next.versionNonce) {\n        return true;\n      }\n    } // note: this is safe because entry's appState is guaranteed no excess props\n\n\n    let key;\n\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        var _nextEntry$appState$k, _lastEntry$appState$k;\n\n        if (((_nextEntry$appState$k = nextEntry.appState[key]) === null || _nextEntry$appState$k === void 0 ? void 0 : _nextEntry$appState$k.elementId) === ((_lastEntry$appState$k = lastEntry.appState[key]) === null || _lastEntry$appState$k === void 0 ? void 0 : _lastEntry$appState$k.elementId)) {\n          continue;\n        }\n      }\n\n      if (key === \"selectedElementIds\") {\n        continue;\n      }\n\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState, elements) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry; // As a new entry was pushed, we invalidate the redo stack\n\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce() {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce() {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n\n\n  setCurrentState(appState, elements) {\n    this.lastEntry = this.hydrateHistoryEntry(this.generateEntry(appState, elements));\n  } // Suspicious that this is called so many places. Seems error-prone.\n\n\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state, elements) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n\n}\nexport const createHistory = () => {\n  const history = new SceneHistory();\n  return {\n    history\n  };\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/history.ts"],"names":["isLinearElement","deepCopyElement","clearAppStatePropertiesForHistory","appState","selectedElementIds","viewBackgroundColor","editingLinearElement","editingGroupId","name","SceneHistory","elementCache","Map","recording","stateHistory","redoStack","lastEntry","generateEntry","elements","dehydrateHistoryEntry","reduce","element","multiElement","id","points","length","push","lastCommittedPoint","slice","hydrateHistoryEntry","JSON","parse","map","dehydratedExcalidrawElement","get","versionNonce","Error","stringify","has","set","versions","getSnapshotForTest","dehydratedHistoryEntry","clear","shouldCreateEntry","nextEntry","i","prev","next","key","elementId","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","splice","redoOnce","entryToRestore","pop","undefined","undoOnce","currentEntry","setCurrentState","resumeRecording","record","state","createHistory","history"],"mappings":"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","sourcesContent":["import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nexport class SceneHistory {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport const createHistory: () => { history: SceneHistory } = () => {\n  const history = new SceneHistory();\n  return { history };\n};\n"]},"metadata":{},"sourceType":"module"}