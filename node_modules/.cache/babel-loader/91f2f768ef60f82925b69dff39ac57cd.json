{"ast":null,"code":"var crc32 = require('crc-32');\n\nmodule.exports = extractChunks; // Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\n\nvar uint8 = new Uint8Array(4);\nvar int32 = new Int32Array(uint8.buffer);\nvar uint32 = new Uint32Array(uint8.buffer);\n\nfunction extractChunks(data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header');\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header');\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header');\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header');\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header');\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  var ended = false;\n  var chunks = [];\n  var idx = 8;\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++]; // Chunk includes name/type for CRC check (see below).\n\n    var length = uint32[0] + 4;\n    var chunk = new Uint8Array(length);\n    chunk[0] = data[idx++];\n    chunk[1] = data[idx++];\n    chunk[2] = data[idx++];\n    chunk[3] = data[idx++]; // Get the name in ASCII for identification.\n\n    var name = String.fromCharCode(chunk[0]) + String.fromCharCode(chunk[1]) + String.fromCharCode(chunk[2]) + String.fromCharCode(chunk[3]); // The IHDR header MUST come first.\n\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing');\n    } // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n\n\n    if (name === 'IEND') {\n      ended = true;\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      });\n      break;\n    } // Read the contents of the chunk out of the main buffer.\n\n\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++];\n    } // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n\n\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++];\n    var crcActual = int32[0];\n    var crcExpect = crc32.buf(chunk);\n\n    if (crcExpect !== crcActual) {\n      throw new Error('CRC values for ' + name + ' header do not match, PNG file is likely corrupted');\n    } // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n\n\n    var chunkData = new Uint8Array(chunk.buffer.slice(4));\n    chunks.push({\n      name: name,\n      data: chunkData\n    });\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found');\n  }\n\n  return chunks;\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/png-chunks-extract/index.js"],"names":["crc32","require","module","exports","extractChunks","uint8","Uint8Array","int32","Int32Array","buffer","uint32","Uint32Array","data","Error","ended","chunks","idx","length","chunk","name","String","fromCharCode","push","i","crcActual","crcExpect","buf","chunkData","slice"],"mappings":"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","sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n"]},"metadata":{},"sourceType":"script"}