{"ast":null,"code":"import { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = (element, updates) => {\n  var _Scene$getScene;\n\n  let didChange = false; // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n\n  const {\n    points\n  } = updates;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points),\n      ...updates\n    };\n  }\n\n  for (const key in updates) {\n    const value = updates[key];\n\n    if (typeof value !== \"undefined\") {\n      if (element[key] === value && ( // if object, always update in case its deep prop was mutated\n      typeof value !== \"object\" || value === null || key === \"groupIds\")) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = element[key];\n        const nextPoints = value;\n\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n\n          while (--index) {\n            const prevPoint = prevPoints[index];\n            const nextPoint = nextPoints[index];\n\n            if (prevPoint[0] !== nextPoint[0] || prevPoint[1] !== nextPoint[1]) {\n              didChangePoints = true;\n              break;\n            }\n          }\n\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      element[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (typeof updates.height !== \"undefined\" || typeof updates.width !== \"undefined\" || typeof points !== \"undefined\") {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  (_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.informMutation();\n};\nexport const newElementWith = (element, updates) => ({ ...element,\n  ...updates,\n  version: element.version + 1,\n  versionNonce: randomInteger()\n});","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/mutateElement.ts"],"names":["invalidateShapeForElement","Scene","getSizeFromPoints","randomInteger","mutateElement","element","updates","didChange","points","key","value","prevPoints","nextPoints","length","didChangePoints","index","prevPoint","nextPoint","height","width","version","versionNonce","getScene","informMutation","newElementWith"],"mappings":"AACA,SAASA,yBAAT,QAA0C,2BAA1C;AACA,OAAOC,KAAP,MAAkB,gBAAlB;AACA,SAASC,iBAAT,QAAkC,WAAlC;AACA,SAASC,aAAT,QAA8B,WAA9B;AAQA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,CAC3BC,OAD2B,EAE3BC,OAF2B,KAGxB;AAAA;;AACH,MAAIC,SAAS,GAAG,KAAhB,CADG,CAGH;AACA;;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAaF,OAAnB;;AAEA,MAAI,OAAOE,MAAP,KAAkB,WAAtB,EAAmC;AACjCF,IAAAA,OAAO,GAAG,EAAE,GAAGJ,iBAAiB,CAACM,MAAD,CAAtB;AAAgC,SAAGF;AAAnC,KAAV;AACD;;AAED,OAAK,MAAMG,GAAX,IAAkBH,OAAlB,EAA2B;AACzB,UAAMI,KAAK,GAAIJ,OAAD,CAAiBG,GAAjB,CAAd;;AACA,QAAI,OAAOC,KAAP,KAAiB,WAArB,EAAkC;AAChC,UACGL,OAAD,CAAiBI,GAAjB,MAA0BC,KAA1B,MACA;AACC,aAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+CD,GAAG,KAAK,UAFxD,CADF,EAIE;AACA;AACD;;AAED,UAAIA,GAAG,KAAK,QAAZ,EAAsB;AACpB,cAAME,UAAU,GAAIN,OAAD,CAAiBI,GAAjB,CAAnB;AACA,cAAMG,UAAU,GAAGF,KAAnB;;AACA,YAAIC,UAAU,CAACE,MAAX,KAAsBD,UAAU,CAACC,MAArC,EAA6C;AAC3C,cAAIC,eAAe,GAAG,KAAtB;AACA,cAAIC,KAAK,GAAGJ,UAAU,CAACE,MAAvB;;AACA,iBAAO,EAAEE,KAAT,EAAgB;AACd,kBAAMC,SAAgB,GAAGL,UAAU,CAACI,KAAD,CAAnC;AACA,kBAAME,SAAgB,GAAGL,UAAU,CAACG,KAAD,CAAnC;;AACA,gBACEC,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAS,CAAC,CAAD,CAA1B,IACAD,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAS,CAAC,CAAD,CAF5B,EAGE;AACAH,cAAAA,eAAe,GAAG,IAAlB;AACA;AACD;AACF;;AACD,cAAI,CAACA,eAAL,EAAsB;AACpB;AACD;AACF;AACF;;AAEAT,MAAAA,OAAD,CAAiBI,GAAjB,IAAwBC,KAAxB;AACAH,MAAAA,SAAS,GAAG,IAAZ;AACD;AACF;;AAED,MAAI,CAACA,SAAL,EAAgB;AACd;AACD;;AAED,MACE,OAAOD,OAAO,CAACY,MAAf,KAA0B,WAA1B,IACA,OAAOZ,OAAO,CAACa,KAAf,KAAyB,WADzB,IAEA,OAAOX,MAAP,KAAkB,WAHpB,EAIE;AACAR,IAAAA,yBAAyB,CAACK,OAAD,CAAzB;AACD;;AAEDA,EAAAA,OAAO,CAACe,OAAR;AACAf,EAAAA,OAAO,CAACgB,YAAR,GAAuBlB,aAAa,EAApC;AACA,qBAAAF,KAAK,CAACqB,QAAN,CAAejB,OAAf,qEAAyBkB,cAAzB;AACD,CApEM;AAsEP,OAAO,MAAMC,cAAc,GAAG,CAC5BnB,OAD4B,EAE5BC,OAF4B,MAGd,EACd,GAAGD,OADW;AAEd,KAAGC,OAFW;AAGdc,EAAAA,OAAO,EAAEf,OAAO,CAACe,OAAR,GAAkB,CAHb;AAIdC,EAAAA,YAAY,EAAElB,aAAa;AAJb,CAHc,CAAvB","sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  Scene.getScene(element)?.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => ({\n  ...element,\n  ...updates,\n  version: element.version + 1,\n  versionNonce: randomInteger(),\n});\n"]},"metadata":{},"sourceType":"module"}