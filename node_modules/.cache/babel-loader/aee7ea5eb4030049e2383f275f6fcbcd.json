{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/actions/actionGroup.tsx\";\nimport React from \"react\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { getSelectedGroupIds, selectGroup, selectGroupsForSelectedElements, getElementsInGroup, addToGroup, removeFromSelectedGroups, isElementInGroup } from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\nimport { randomId } from \"../random\";\nimport { ToolButton } from \"../components/ToolButton\";\n\nconst allElementsInSameGroup = elements => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n\n    for (const groupId of groupIds) {\n      if (elements.reduce((acc, element) => acc && isElementInGroup(element, groupId), true)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst enableActionGroup = (elements, appState) => {\n  const selectedElements = getSelectedElements(getNonDeletedElements(elements), appState);\n  return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements);\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(getNonDeletedElements(elements), appState);\n\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return {\n        appState,\n        elements,\n        commitToHistory: false\n      };\n    } // if everything is already grouped into 1 group, there is nothing to do\n\n\n    const selectedGroupIds = getSelectedGroupIds(appState);\n\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(getElementsInGroup(elements, selectedGroupId).map(element => element.id));\n      const selectedElementIds = new Set(selectedElements.map(element => element.id));\n      const combinedSet = new Set([...Array.from(elementIdsInGroup), ...Array.from(selectedElementIds)]);\n\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return {\n          appState,\n          elements,\n          commitToHistory: false\n        };\n      }\n    }\n\n    const newGroupId = randomId();\n    const updatedElements = elements.map(element => {\n      if (!appState.selectedElementIds[element.id]) {\n        return element;\n      }\n\n      return newElementWith(element, {\n        groupIds: addToGroup(element.groupIds, newGroupId, appState.editingGroupId)\n      });\n    }); // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n\n    const elementsInGroup = getElementsInGroup(updatedElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex = updatedElements.lastIndexOf(lastElementInGroup);\n    const elementsAfterGroup = updatedElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = updatedElements.slice(0, lastGroupElementIndex).filter(updatedElement => !isElementInGroup(updatedElement, newGroupId));\n    const updatedElementsInOrder = [...elementsBeforeGroup, ...elementsInGroup, ...elementsAfterGroup];\n    return {\n      appState: selectGroup(newGroupId, { ...appState,\n        selectedGroupIds: {}\n      }, getNonDeletedElements(updatedElementsInOrder)),\n      elements: updatedElementsInOrder,\n      commitToHistory: true\n    };\n  },\n  contextMenuOrder: 4,\n  contextItemLabel: \"labels.group\",\n  contextItemPredicate: (elements, appState) => enableActionGroup(elements, appState),\n  keyTest: event => !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  PanelComponent: ({\n    elements,\n    appState,\n    updateData\n  }) => /*#__PURE__*/_jsxDEV(ToolButton, {\n    hidden: !enableActionGroup(elements, appState),\n    type: \"button\",\n    icon: /*#__PURE__*/_jsxDEV(GroupIcon, {\n      appearance: appState.appearance\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 13\n    }, this),\n    onClick: () => updateData(null),\n    title: `${t(\"labels.group\")} — ${getShortcutKey(\"CtrlOrCmd+G\")}`,\n    \"aria-label\": t(\"labels.group\"),\n    visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 135,\n    columnNumber: 5\n  }, this)\n});\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  perform: (elements, appState) => {\n    const groupIds = getSelectedGroupIds(appState);\n\n    if (groupIds.length === 0) {\n      return {\n        appState,\n        elements,\n        commitToHistory: false\n      };\n    }\n\n    const nextElements = elements.map(element => {\n      const nextGroupIds = removeFromSelectedGroups(element.groupIds, appState.selectedGroupIds);\n\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n\n      return newElementWith(element, {\n        groupIds: nextGroupIds\n      });\n    });\n    return {\n      appState: selectGroupsForSelectedElements({ ...appState,\n        selectedGroupIds: {}\n      }, getNonDeletedElements(nextElements)),\n      elements: nextElements,\n      commitToHistory: true\n    };\n  },\n  keyTest: event => event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  contextMenuOrder: 5,\n  contextItemLabel: \"labels.ungroup\",\n  contextItemPredicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,\n  PanelComponent: ({\n    elements,\n    appState,\n    updateData\n  }) => /*#__PURE__*/_jsxDEV(ToolButton, {\n    type: \"button\",\n    hidden: getSelectedGroupIds(appState).length === 0,\n    icon: /*#__PURE__*/_jsxDEV(UngroupIcon, {\n      appearance: appState.appearance\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 13\n    }, this),\n    onClick: () => updateData(null),\n    title: `${t(\"labels.ungroup\")} — ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`,\n    \"aria-label\": t(\"labels.ungroup\"),\n    visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 183,\n    columnNumber: 5\n  }, this)\n});","map":{"version":3,"sources":["/var/www/html/excalidraw/src/actions/actionGroup.tsx"],"names":["React","CODES","KEYS","t","getShortcutKey","register","UngroupIcon","GroupIcon","newElementWith","getSelectedElements","isSomeElementSelected","getSelectedGroupIds","selectGroup","selectGroupsForSelectedElements","getElementsInGroup","addToGroup","removeFromSelectedGroups","isElementInGroup","getNonDeletedElements","randomId","ToolButton","allElementsInSameGroup","elements","length","groupIds","groupId","reduce","acc","element","enableActionGroup","appState","selectedElements","actionGroup","name","perform","commitToHistory","selectedGroupIds","selectedGroupId","elementIdsInGroup","Set","map","id","selectedElementIds","combinedSet","Array","from","size","newGroupId","updatedElements","editingGroupId","elementsInGroup","lastElementInGroup","lastGroupElementIndex","lastIndexOf","elementsAfterGroup","slice","elementsBeforeGroup","filter","updatedElement","updatedElementsInOrder","contextMenuOrder","contextItemLabel","contextItemPredicate","keyTest","event","shiftKey","CTRL_OR_CMD","code","G","PanelComponent","updateData","appearance","actionUngroup","nextElements","nextGroupIds"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport {\n  getSelectedGroupIds,\n  selectGroup,\n  selectGroupsForSelectedElements,\n  getElementsInGroup,\n  addToGroup,\n  removeFromSelectedGroups,\n  isElementInGroup,\n} from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\nimport { randomId } from \"../random\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\n\nconst allElementsInSameGroup = (elements: readonly ExcalidrawElement[]) => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n    for (const groupId of groupIds) {\n      if (\n        elements.reduce(\n          (acc, element) => acc && isElementInGroup(element, groupId),\n          true,\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return (\n    selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements)\n  );\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return { appState, elements, commitToHistory: false };\n    }\n    // if everything is already grouped into 1 group, there is nothing to do\n    const selectedGroupIds = getSelectedGroupIds(appState);\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(\n        getElementsInGroup(elements, selectedGroupId).map(\n          (element) => element.id,\n        ),\n      );\n      const selectedElementIds = new Set(\n        selectedElements.map((element) => element.id),\n      );\n      const combinedSet = new Set([\n        ...Array.from(elementIdsInGroup),\n        ...Array.from(selectedElementIds),\n      ]);\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return { appState, elements, commitToHistory: false };\n      }\n    }\n    const newGroupId = randomId();\n    const updatedElements = elements.map((element) => {\n      if (!appState.selectedElementIds[element.id]) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: addToGroup(\n          element.groupIds,\n          newGroupId,\n          appState.editingGroupId,\n        ),\n      });\n    });\n    // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n    const elementsInGroup = getElementsInGroup(updatedElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex = updatedElements.lastIndexOf(\n      lastElementInGroup,\n    );\n    const elementsAfterGroup = updatedElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = updatedElements\n      .slice(0, lastGroupElementIndex)\n      .filter(\n        (updatedElement) => !isElementInGroup(updatedElement, newGroupId),\n      );\n    const updatedElementsInOrder = [\n      ...elementsBeforeGroup,\n      ...elementsInGroup,\n      ...elementsAfterGroup,\n    ];\n\n    return {\n      appState: selectGroup(\n        newGroupId,\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(updatedElementsInOrder),\n      ),\n      elements: updatedElementsInOrder,\n      commitToHistory: true,\n    };\n  },\n  contextMenuOrder: 4,\n  contextItemLabel: \"labels.group\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionGroup(elements, appState),\n  keyTest: (event) =>\n    !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<GroupIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.group\")} — ${getShortcutKey(\"CtrlOrCmd+G\")}`}\n      aria-label={t(\"labels.group\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  perform: (elements, appState) => {\n    const groupIds = getSelectedGroupIds(appState);\n    if (groupIds.length === 0) {\n      return { appState, elements, commitToHistory: false };\n    }\n    const nextElements = elements.map((element) => {\n      const nextGroupIds = removeFromSelectedGroups(\n        element.groupIds,\n        appState.selectedGroupIds,\n      );\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: nextGroupIds,\n      });\n    });\n    return {\n      appState: selectGroupsForSelectedElements(\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(nextElements),\n      ),\n      elements: nextElements,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  contextMenuOrder: 5,\n  contextItemLabel: \"labels.ungroup\",\n  contextItemPredicate: (elements, appState) =>\n    getSelectedGroupIds(appState).length > 0,\n\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      hidden={getSelectedGroupIds(appState).length === 0}\n      icon={<UngroupIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.ungroup\")} — ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`}\n      aria-label={t(\"labels.ungroup\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n"]},"metadata":{},"sourceType":"module"}