{"ast":null,"code":"import { encryptAESGEM } from \"../data\";\nimport { getElementMap, getSyncableElements } from \"../../packages/excalidraw/index\";\nimport { BROADCAST, SCENE } from \"../app_constants\";\n\nclass Portal {\n  // we don't want the socket to emit any updates until it is fully initialized\n  constructor(app) {\n    this.app = void 0;\n    this.socket = null;\n    this.socketInitialized = false;\n    this.roomId = null;\n    this.roomKey = null;\n    this.broadcastedElementVersions = new Map();\n\n    this.broadcastScene = async (sceneType, syncableElements, syncAll) => {\n      if (sceneType === SCENE.INIT && !syncAll) {\n        throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n      }\n\n      if (!syncAll) {\n        // sync out only the elements we think we need to to save bandwidth.\n        // periodically we'll resync the whole thing to make sure no one diverges\n        // due to a dropped message (server goes down etc).\n        syncableElements = syncableElements.filter(syncableElement => !this.broadcastedElementVersions.has(syncableElement.id) || syncableElement.version > this.broadcastedElementVersions.get(syncableElement.id));\n      }\n\n      const data = {\n        type: sceneType,\n        payload: {\n          elements: syncableElements\n        }\n      };\n\n      for (const syncableElement of syncableElements) {\n        this.broadcastedElementVersions.set(syncableElement.id, syncableElement.version);\n      }\n\n      const broadcastPromise = this._broadcastSocketData(data);\n\n      if (syncAll && this.app.state.isCollaborating) {\n        await Promise.all([broadcastPromise, this.app.saveCollabRoomToFirebase(syncableElements)]);\n      } else {\n        await broadcastPromise;\n      }\n    };\n\n    this.broadcastMouseLocation = payload => {\n      var _this$socket;\n\n      if ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.id) {\n        var _this$app$excalidrawA;\n\n        const data = {\n          type: \"MOUSE_LOCATION\",\n          payload: {\n            socketId: this.socket.id,\n            pointer: payload.pointer,\n            button: payload.button || \"up\",\n            selectedElementIds: ((_this$app$excalidrawA = this.app.excalidrawAppState) === null || _this$app$excalidrawA === void 0 ? void 0 : _this$app$excalidrawA.selectedElementIds) || {},\n            username: this.app.state.username\n          }\n        };\n        return this._broadcastSocketData(data, true // volatile\n        );\n      }\n    };\n\n    this.reconcileElements = sceneElements => {\n      const currentElements = this.app.getSceneElementsIncludingDeleted(); // create a map of ids so we don't have to iterate\n      // over the array more than once.\n\n      const localElementMap = getElementMap(currentElements); // Reconcile\n\n      return sceneElements.reduce((elements, element) => {\n        var _this$app$excalidrawA2, _this$app$excalidrawA3, _this$app$excalidrawA4, _this$app$excalidrawA5, _this$app$excalidrawA6, _this$app$excalidrawA7;\n\n        // if the remote element references one that's currently\n        // edited on local, skip it (it'll be added in the next step)\n        if (element.id === ((_this$app$excalidrawA2 = this.app.excalidrawAppState) === null || _this$app$excalidrawA2 === void 0 ? void 0 : (_this$app$excalidrawA3 = _this$app$excalidrawA2.editingElement) === null || _this$app$excalidrawA3 === void 0 ? void 0 : _this$app$excalidrawA3.id) || element.id === ((_this$app$excalidrawA4 = this.app.excalidrawAppState) === null || _this$app$excalidrawA4 === void 0 ? void 0 : (_this$app$excalidrawA5 = _this$app$excalidrawA4.resizingElement) === null || _this$app$excalidrawA5 === void 0 ? void 0 : _this$app$excalidrawA5.id) || element.id === ((_this$app$excalidrawA6 = this.app.excalidrawAppState) === null || _this$app$excalidrawA6 === void 0 ? void 0 : (_this$app$excalidrawA7 = _this$app$excalidrawA6.draggingElement) === null || _this$app$excalidrawA7 === void 0 ? void 0 : _this$app$excalidrawA7.id)) {\n          return elements;\n        }\n\n        if (localElementMap.hasOwnProperty(element.id) && localElementMap[element.id].version > element.version) {\n          elements.push(localElementMap[element.id]);\n          delete localElementMap[element.id];\n        } else if (localElementMap.hasOwnProperty(element.id) && localElementMap[element.id].version === element.version && localElementMap[element.id].versionNonce !== element.versionNonce) {\n          // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n          if (localElementMap[element.id].versionNonce < element.versionNonce) {\n            elements.push(localElementMap[element.id]);\n          } else {\n            // it should be highly unlikely that the two versionNonces are the same. if we are\n            // really worried about this, we can replace the versionNonce with the socket id.\n            elements.push(element);\n          }\n\n          delete localElementMap[element.id];\n        } else {\n          elements.push(element);\n          delete localElementMap[element.id];\n        }\n\n        return elements;\n      }, []) // add local elements that weren't deleted or on remote\n      .concat(...Object.values(localElementMap));\n    };\n\n    this.app = app;\n  }\n\n  open(socket, id, key) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key; // Initialize socket listeners (moving from App)\n\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n      }\n    });\n    this.socket.on(\"new-user\", async _socketId => {\n      this.broadcastScene(SCENE.INIT, getSyncableElements(this.app.getSceneElementsIncludingDeleted()),\n      /* syncAll */\n      true);\n    });\n    this.socket.on(\"room-user-change\", clients => {\n      this.app.setCollaborators(clients);\n    });\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(this.socketInitialized && this.socket && this.roomId && this.roomKey);\n  }\n\n  async _broadcastSocketData(data, volatile = false) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey);\n      this.socket.emit(volatile ? BROADCAST.SERVER_VOLATILE : BROADCAST.SERVER, this.roomId, encrypted.data, encrypted.iv);\n    }\n  }\n\n}\n\nexport default Portal;","map":{"version":3,"sources":["/var/www/html/excalidraw/src/excalidraw-app/collab/Portal.tsx"],"names":["encryptAESGEM","getElementMap","getSyncableElements","BROADCAST","SCENE","Portal","constructor","app","socket","socketInitialized","roomId","roomKey","broadcastedElementVersions","Map","broadcastScene","sceneType","syncableElements","syncAll","INIT","Error","filter","syncableElement","has","id","version","get","data","type","payload","elements","set","broadcastPromise","_broadcastSocketData","state","isCollaborating","Promise","all","saveCollabRoomToFirebase","broadcastMouseLocation","socketId","pointer","button","selectedElementIds","excalidrawAppState","username","reconcileElements","sceneElements","currentElements","getSceneElementsIncludingDeleted","localElementMap","reduce","element","editingElement","resizingElement","draggingElement","hasOwnProperty","push","versionNonce","concat","Object","values","open","key","on","emit","_socketId","clients","setCollaborators","close","isOpen","volatile","json","JSON","stringify","encoded","TextEncoder","encode","encrypted","SERVER_VOLATILE","SERVER","iv"],"mappings":"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","sourcesContent":["import {\n  encryptAESGEM,\n  SocketUpdateData,\n  SocketUpdateDataSource,\n} from \"../data\";\n\nimport CollabWrapper from \"./CollabWrapper\";\n\nimport {\n  getElementMap,\n  getSyncableElements,\n} from \"../../packages/excalidraw/index\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { BROADCAST, SCENE } from \"../app_constants\";\n\nclass Portal {\n  app: CollabWrapper;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initialized\n  roomId: string | null = null;\n  roomKey: string | null = null;\n  broadcastedElementVersions: Map<string, number> = new Map();\n\n  constructor(app: CollabWrapper) {\n    this.app = app;\n  }\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners (moving from App)\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n      }\n    });\n    this.socket.on(\"new-user\", async (_socketId: string) => {\n      this.broadcastScene(\n        SCENE.INIT,\n        getSyncableElements(this.app.getSceneElementsIncludingDeleted()),\n        /* syncAll */ true,\n      );\n    });\n    this.socket.on(\"room-user-change\", (clients: string[]) => {\n      this.app.setCollaborators(clients);\n    });\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(\n      this.socketInitialized &&\n      this.socket &&\n      this.roomId &&\n      this.roomKey\n    );\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateData,\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey!);\n      this.socket!.emit(\n        volatile ? BROADCAST.SERVER_VOLATILE : BROADCAST.SERVER,\n        this.roomId,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  }\n\n  broadcastScene = async (\n    sceneType: SCENE.INIT | SCENE.UPDATE,\n    syncableElements: ExcalidrawElement[],\n    syncAll: boolean,\n  ) => {\n    if (sceneType === SCENE.INIT && !syncAll) {\n      throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n    }\n\n    if (!syncAll) {\n      // sync out only the elements we think we need to to save bandwidth.\n      // periodically we'll resync the whole thing to make sure no one diverges\n      // due to a dropped message (server goes down etc).\n      syncableElements = syncableElements.filter(\n        (syncableElement) =>\n          !this.broadcastedElementVersions.has(syncableElement.id) ||\n          syncableElement.version >\n            this.broadcastedElementVersions.get(syncableElement.id)!,\n      );\n    }\n\n    const data: SocketUpdateDataSource[typeof sceneType] = {\n      type: sceneType,\n      payload: {\n        elements: syncableElements,\n      },\n    };\n\n    for (const syncableElement of syncableElements) {\n      this.broadcastedElementVersions.set(\n        syncableElement.id,\n        syncableElement.version,\n      );\n    }\n\n    const broadcastPromise = this._broadcastSocketData(\n      data as SocketUpdateData,\n    );\n\n    if (syncAll && this.app.state.isCollaborating) {\n      await Promise.all([\n        broadcastPromise,\n        this.app.saveCollabRoomToFirebase(syncableElements),\n      ]);\n    } else {\n      await broadcastPromise;\n    }\n  };\n\n  broadcastMouseLocation = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketId: this.socket.id,\n          pointer: payload.pointer,\n          button: payload.button || \"up\",\n          selectedElementIds:\n            this.app.excalidrawAppState?.selectedElementIds || {},\n          username: this.app.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n\n  reconcileElements = (\n    sceneElements: readonly ExcalidrawElement[],\n  ): readonly ExcalidrawElement[] => {\n    const currentElements = this.app.getSceneElementsIncludingDeleted();\n    // create a map of ids so we don't have to iterate\n    // over the array more than once.\n    const localElementMap = getElementMap(currentElements);\n\n    // Reconcile\n    return (\n      sceneElements\n        .reduce((elements, element) => {\n          // if the remote element references one that's currently\n          // edited on local, skip it (it'll be added in the next step)\n          if (\n            element.id === this.app.excalidrawAppState?.editingElement?.id ||\n            element.id === this.app.excalidrawAppState?.resizingElement?.id ||\n            element.id === this.app.excalidrawAppState?.draggingElement?.id\n          ) {\n            return elements;\n          }\n\n          if (\n            localElementMap.hasOwnProperty(element.id) &&\n            localElementMap[element.id].version > element.version\n          ) {\n            elements.push(localElementMap[element.id]);\n            delete localElementMap[element.id];\n          } else if (\n            localElementMap.hasOwnProperty(element.id) &&\n            localElementMap[element.id].version === element.version &&\n            localElementMap[element.id].versionNonce !== element.versionNonce\n          ) {\n            // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n            if (\n              localElementMap[element.id].versionNonce < element.versionNonce\n            ) {\n              elements.push(localElementMap[element.id]);\n            } else {\n              // it should be highly unlikely that the two versionNonces are the same. if we are\n              // really worried about this, we can replace the versionNonce with the socket id.\n              elements.push(element);\n            }\n            delete localElementMap[element.id];\n          } else {\n            elements.push(element);\n            delete localElementMap[element.id];\n          }\n\n          return elements;\n        }, [] as Mutable<typeof sceneElements>)\n        // add local elements that weren't deleted or on remote\n        .concat(...Object.values(localElementMap))\n    );\n  };\n}\n\nexport default Portal;\n"]},"metadata":{},"sourceType":"module"}