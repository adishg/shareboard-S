{"ast":null,"code":"import { getElementAtPosition } from \"../scene\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport { bindingBorderTest, distanceToBindableElement, maxBindingGap, determineFocusDistance, intersectElementWithLine, determineFocusPoint } from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\nexport const shouldEnableBindingForPointerEvent = event => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\nexport const isBindingEnabled = appState => {\n  return appState.isBindingEnabled;\n};\nexport const bindOrUnbindLinearElement = (linearElement, startBindingElement, endBindingElement) => {\n  const boundToElementIds = new Set();\n  const unboundFromElementIds = new Set();\n  bindOrUnbindLinearElementEdge(linearElement, startBindingElement, endBindingElement, \"start\", boundToElementIds, unboundFromElementIds);\n  bindOrUnbindLinearElementEdge(linearElement, endBindingElement, startBindingElement, \"end\", boundToElementIds, unboundFromElementIds);\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(id => !boundToElementIds.has(id));\n  Scene.getScene(linearElement).getNonDeletedElements(onlyUnbound).forEach(element => {\n    var _element$boundElement;\n\n    mutateElement(element, {\n      boundElementIds: (_element$boundElement = element.boundElementIds) === null || _element$boundElement === void 0 ? void 0 : _element$boundElement.filter(id => id !== linearElement.id)\n    });\n  });\n};\n\nconst bindOrUnbindLinearElementEdge = (linearElement, bindableElement, otherEdgeBindableElement, startOrEnd, boundToElementIds, unboundFromElementIds) => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (otherEdgeBindableElement == null || (otherEdgeBindableElement === \"keep\" ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, bindableElement, startOrEnd) : startOrEnd === \"start\" || otherEdgeBindableElement.id !== bindableElement.id)) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = elements => {\n  elements.forEach(element => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, getElligibleElementForBindingElement(element, \"start\"), getElligibleElementForBindingElement(element, \"end\"));\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = bindableElement => {\n  getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(([linearElement, where]) => bindOrUnbindLinearElement(linearElement, where === \"end\" ? \"keep\" : bindableElement, where === \"start\" ? \"keep\" : bindableElement));\n};\n\nexport const maybeBindLinearElement = (linearElement, appState, scene, pointerCoords) => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n\n  if (hoveredElement != null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, hoveredElement, \"end\")) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (linearElement, hoveredElement, startOrEnd) => {\n  var _hoveredElement$bound;\n\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd)\n    }\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: [...new Set([...((_hoveredElement$bound = hoveredElement.boundElementIds) !== null && _hoveredElement$bound !== void 0 ? _hoveredElement$bound : []), linearElement.id])]\n  });\n}; // Don't bind both ends of a simple segment\n\n\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (linearElement, bindableElement, startOrEnd) => {\n  const otherBinding = linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(linearElement, otherBinding === null || otherBinding === void 0 ? void 0 : otherBinding.elementId, bindableElement);\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (linearElement, alreadyBoundToId, bindableElement) => {\n  return alreadyBoundToId === bindableElement.id && linearElement.points.length < 3;\n};\nexport const unbindLinearElements = elements => {\n  elements.forEach(element => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (linearElement, startOrEnd) => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n\n  if (binding == null) {\n    return null;\n  }\n\n  mutateElement(linearElement, {\n    [field]: null\n  });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (pointerCoords, scene) => {\n  const hoveredElement = getElementAtPosition(scene.getElements(), element => isBindableElement(element) && bindingBorderTest(element, pointerCoords));\n  return hoveredElement;\n};\n\nconst calculateFocusAndGap = (linearElement, hoveredElement, startOrEnd) => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, edgePointIndex);\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, adjacentPointIndex);\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint))\n  };\n}; // Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\n\n\nexport const updateBoundElements = (changedElement, options) => {\n  var _changedElement$bound;\n\n  const boundElementIds = (_changedElement$bound = changedElement.boundElementIds) !== null && _changedElement$bound !== void 0 ? _changedElement$bound : [];\n\n  if (boundElementIds.length === 0) {\n    return;\n  }\n\n  const {\n    newSize,\n    simultaneouslyUpdated\n  } = options !== null && options !== void 0 ? options : {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(simultaneouslyUpdated);\n  Scene.getScene(changedElement).getNonDeletedElements(boundElementIds).forEach(linearElement => {\n    const bindableElement = changedElement; // In case the boundElementIds are stale\n\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n\n    const startBinding = maybeCalculateNewGapWhenScaling(bindableElement, linearElement.startBinding, newSize);\n    const endBinding = maybeCalculateNewGapWhenScaling(bindableElement, linearElement.endBinding, newSize); // `linearElement` is being moved/scaled already, just update the binding\n\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, {\n        startBinding,\n        endBinding\n      });\n      return;\n    }\n\n    updateBoundPoint(linearElement, \"start\", startBinding, changedElement);\n    updateBoundPoint(linearElement, \"end\", endBinding, changedElement);\n  });\n};\n\nconst doesNeedUpdate = (boundElement, changedElement) => {\n  var _boundElement$startBi, _boundElement$endBind;\n\n  return ((_boundElement$startBi = boundElement.startBinding) === null || _boundElement$startBi === void 0 ? void 0 : _boundElement$startBi.elementId) === changedElement.id || ((_boundElement$endBind = boundElement.endBinding) === null || _boundElement$endBind === void 0 ? void 0 : _boundElement$endBind.elementId) === changedElement.id;\n};\n\nconst getSimultaneouslyUpdatedElementIds = simultaneouslyUpdated => {\n  return new Set((simultaneouslyUpdated || []).map(element => element.id));\n};\n\nconst updateBoundPoint = (linearElement, startOrEnd, binding, changedElement) => {\n  if (binding == null || // We only need to update the other end if this is a 2 point line element\n  binding.elementId !== changedElement.id && linearElement.points.length > 2) {\n    return;\n  }\n\n  const bindingElement = Scene.getScene(linearElement).getElement(binding.elementId);\n\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, adjacentPointIndex);\n  const focusPointAbsolute = determineFocusPoint(bindingElement, binding.focus, adjacentPoint);\n  let newEdgePoint; // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(bindingElement, adjacentPoint, focusPointAbsolute, binding.gap);\n\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n\n  LinearElementEditor.movePoint(linearElement, edgePointIndex, LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint), {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding\n  });\n};\n\nconst maybeCalculateNewGapWhenScaling = (changedElement, currentBinding, newSize) => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n\n  const {\n    gap,\n    focus,\n    elementId\n  } = currentBinding;\n  const {\n    width: newWidth,\n    height: newHeight\n  } = newSize;\n  const {\n    width,\n    height\n  } = changedElement;\n  const newGap = Math.max(1, Math.min(maxBindingGap(changedElement, newWidth, newHeight), gap * (newWidth < newHeight ? newWidth / width : newHeight / height)));\n  return {\n    elementId,\n    gap: newGap,\n    focus\n  };\n};\n\nexport const getEligibleElementsForBinding = elements => {\n  const includedElementIds = new Set(elements.map(({\n    id\n  }) => id));\n  return elements.flatMap(element => isBindingElement(element) ? getElligibleElementsForBindingElement(element).filter(element => !includedElementIds.has(element.id)) : isBindableElement(element) ? getElligibleElementsForBindableElementAndWhere(element).filter(binding => !includedElementIds.has(binding[0].id)) : []);\n};\n\nconst getElligibleElementsForBindingElement = linearElement => {\n  return [getElligibleElementForBindingElement(linearElement, \"start\"), getElligibleElementForBindingElement(linearElement, \"end\")].filter(element => element != null);\n};\n\nconst getElligibleElementForBindingElement = (linearElement, startOrEnd) => {\n  return getHoveredElementForBinding(getLinearElementEdgeCoors(linearElement, startOrEnd), Scene.getScene(linearElement));\n};\n\nconst getLinearElementEdgeCoors = (linearElement, startOrEnd) => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index));\n};\n\nconst getElligibleElementsForBindableElementAndWhere = bindableElement => {\n  return Scene.getScene(bindableElement).getElements().map(element => {\n    if (!isBindingElement(element)) {\n      return null;\n    }\n\n    const canBindStart = isLinearElementEligibleForNewBindingByBindable(element, \"start\", bindableElement);\n    const canBindEnd = isLinearElementEligibleForNewBindingByBindable(element, \"end\", bindableElement);\n\n    if (!canBindStart && !canBindEnd) {\n      return null;\n    }\n\n    return [element, canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\", bindableElement];\n  }).filter(maybeElement => maybeElement != null);\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (linearElement, startOrEnd, bindableElement) => {\n  const existingBinding = linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return existingBinding == null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, bindableElement, startOrEnd) && bindingBorderTest(bindableElement, getLinearElementEdgeCoors(linearElement, startOrEnd));\n}; // We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\n\n\nexport const fixBindingsAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId, duplicatesServeAsOld) => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds = new Set();\n  const allBindableElementIds = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach(oldElement => {\n    const {\n      boundElementIds\n    } = oldElement;\n\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach(boundElementId => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));\n    }\n\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const {\n          elementId\n        } = oldElement.startBinding;\n\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n\n      if (oldElement.endBinding != null) {\n        const {\n          elementId\n        } = oldElement.endBinding;\n\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));\n      }\n    }\n  }); // Update the linear elements\n\n  sceneElements.filter(({\n    id\n  }) => allBoundElementIds.has(id)).forEach(element => {\n    const {\n      startBinding,\n      endBinding\n    } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(startBinding, oldIdToDuplicatedId),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId)\n    });\n  }); // Update the bindable shapes\n\n  sceneElements.filter(({\n    id\n  }) => allBindableElementIds.has(id)).forEach(bindableElement => {\n    const {\n      boundElementIds\n    } = bindableElement;\n\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      mutateElement(bindableElement, {\n        boundElementIds: boundElementIds.map(boundElementId => {\n          var _oldIdToDuplicatedId$;\n\n          return (_oldIdToDuplicatedId$ = oldIdToDuplicatedId.get(boundElementId)) !== null && _oldIdToDuplicatedId$ !== void 0 ? _oldIdToDuplicatedId$ : boundElementId;\n        })\n      });\n    }\n  });\n};\n\nconst newBindingAfterDuplication = (binding, oldIdToDuplicatedId) => {\n  var _oldIdToDuplicatedId$2;\n\n  if (binding == null) {\n    return null;\n  }\n\n  const {\n    elementId,\n    focus,\n    gap\n  } = binding;\n  return {\n    focus,\n    gap,\n    elementId: (_oldIdToDuplicatedId$2 = oldIdToDuplicatedId.get(elementId)) !== null && _oldIdToDuplicatedId$2 !== void 0 ? _oldIdToDuplicatedId$2 : elementId\n  };\n};\n\nexport const fixBindingsAfterDeletion = (sceneElements, deletedElements) => {\n  const deletedElementIds = new Set(deletedElements.map(element => element.id)); // Non deleted and need an update\n\n  const boundElementIds = new Set();\n  deletedElements.forEach(deletedElement => {\n    if (isBindableElement(deletedElement)) {\n      var _deletedElement$bound;\n\n      (_deletedElement$bound = deletedElement.boundElementIds) === null || _deletedElement$bound === void 0 ? void 0 : _deletedElement$bound.forEach(id => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  sceneElements.filter(({\n    id\n  }) => boundElementIds.has(id)).forEach(element => {\n    const {\n      startBinding,\n      endBinding\n    } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n      endBinding: newBindingAfterDeletion(endBinding, deletedElementIds)\n    });\n  });\n};\n\nconst newBindingAfterDeletion = (binding, deletedElementIds) => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n\n  return binding;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/binding.ts"],"names":["getElementAtPosition","isBindableElement","isBindingElement","bindingBorderTest","distanceToBindableElement","maxBindingGap","determineFocusDistance","intersectElementWithLine","determineFocusPoint","mutateElement","Scene","LinearElementEditor","tupleToCoors","KEYS","shouldEnableBindingForPointerEvent","event","CTRL_OR_CMD","isBindingEnabled","appState","bindOrUnbindLinearElement","linearElement","startBindingElement","endBindingElement","boundToElementIds","Set","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","Array","from","filter","id","has","getScene","getNonDeletedElements","forEach","element","boundElementIds","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","add","unbound","unbindLinearElement","bindOrUnbindSelectedElements","elements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","where","maybeBindLinearElement","scene","pointerCoords","startBoundElement","hoveredElement","getHoveredElementForBinding","elementId","calculateFocusAndGap","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","points","length","unbindLinearElements","field","binding","getElements","direction","edgePointIndex","adjacentPointIndex","edgePoint","getPointAtIndexGlobalCoordinates","adjacentPoint","focus","gap","Math","max","updateBoundElements","changedElement","options","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","doesNeedUpdate","startBinding","maybeCalculateNewGapWhenScaling","endBinding","updateBoundPoint","boundElement","map","bindingElement","getElement","focusPointAbsolute","newEdgePoint","intersections","movePoint","pointFromAbsoluteCoords","currentBinding","width","newWidth","height","newHeight","newGap","min","getEligibleElementsForBinding","includedElementIds","flatMap","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","index","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","existingBinding","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","boundElementId","get","newBindingAfterDuplication","fixBindingsAfterDeletion","deletedElements","deletedElementIds","deletedElement","newBindingAfterDeletion"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLCanvasElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n  Scene.getScene(linearElement)!\n    .getNonDeletedElements(onlyUnbound)\n    .forEach((element) => {\n      mutateElement(element, {\n        boundElementIds: element.boundElementIds?.filter(\n          (id) => id !== linearElement.id,\n        ),\n      });\n    });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(\n    bindableElement,\n  ).forEach(([linearElement, where]) =>\n    bindOrUnbindLinearElement(\n      linearElement,\n      where === \"end\" ? \"keep\" : bindableElement,\n      where === \"start\" ? \"keep\" : bindableElement,\n    ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: [\n      ...new Set([...(hoveredElement.boundElementIds ?? []), linearElement.id]),\n    ],\n  });\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getElements(),\n    (element) =>\n      isBindableElement(element) && bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundElementIds = changedElement.boundElementIds ?? [];\n  if (boundElementIds.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n  (Scene.getScene(changedElement)!.getNonDeletedElements(\n    boundElementIds,\n  ) as NonDeleted<ExcalidrawLinearElement>[]).forEach((linearElement) => {\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElementIds are stale\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      linearElement,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      linearElement,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoint(\n    linearElement,\n    edgePointIndex,\n    LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint),\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getElements()\n    .map((element) => {\n      if (!isBindingElement(element)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElementIds } = oldElement;\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach((boundElementId) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (sceneElements.filter(({ id }) =>\n    allBoundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElementIds } = bindableElement;\n      if (boundElementIds != null && boundElementIds.length > 0) {\n        mutateElement(bindableElement, {\n          boundElementIds: boundElementIds.map(\n            (boundElementId) =>\n              oldIdToDuplicatedId.get(boundElementId) ?? boundElementId,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // Non deleted and need an update\n  const boundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElementIds?.forEach((id) => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  (sceneElements.filter(({ id }) =>\n    boundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach(\n    (element: ExcalidrawLinearElement) => {\n      const { startBinding, endBinding } = element;\n      mutateElement(element, {\n        startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n        endBinding: newBindingAfterDeletion(endBinding, deletedElementIds),\n      });\n    },\n  );\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n"]},"metadata":{},"sourceType":"module"}