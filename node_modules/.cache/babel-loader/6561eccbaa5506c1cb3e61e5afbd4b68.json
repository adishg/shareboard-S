{"ast":null,"code":"import { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\nconst _newElementBase = (type, {\n  x,\n  y,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  width = 0,\n  height = 0,\n  angle = 0,\n  groupIds = [],\n  strokeSharpness,\n  boundElementIds = null,\n  ...rest\n}) => {\n  var _rest$seed, _rest$versionNonce;\n\n  return {\n    id: rest.id || randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    groupIds,\n    strokeSharpness,\n    seed: (_rest$seed = rest.seed) !== null && _rest$seed !== void 0 ? _rest$seed : randomInteger(),\n    version: rest.version || 1,\n    versionNonce: (_rest$versionNonce = rest.versionNonce) !== null && _rest$versionNonce !== void 0 ? _rest$versionNonce : 0,\n    isDeleted: false,\n    boundElementIds\n  };\n};\n\nexport const newElement = opts => _newElementBase(opts.type, opts);\n/** computes element x/y offset based on textAlign/verticalAlign */\n\nconst getTextElementPositionOffsets = (opts, metrics) => {\n  return {\n    x: opts.textAlign === \"center\" ? metrics.width / 2 : opts.textAlign === \"right\" ? metrics.width : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0\n  };\n};\n\nexport const newTextElement = opts => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith({ ..._newElementBase(\"text\", opts),\n    text: opts.text,\n    fontSize: opts.fontSize,\n    fontFamily: opts.fontFamily,\n    textAlign: opts.textAlign,\n    verticalAlign: opts.verticalAlign,\n    x: opts.x - offsets.x,\n    y: opts.y - offsets.y,\n    width: metrics.width,\n    height: metrics.height,\n    baseline: metrics.baseline\n  }, {});\n  return textElement;\n};\n\nconst getAdjustedDimensions = (element, nextText) => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline\n  } = measureText(nextText, getFontString(element));\n  const {\n    textAlign,\n    verticalAlign\n  } = element;\n  let x;\n  let y;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height\n    });\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(element, nextWidth, nextHeight);\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    [x, y] = adjustXYWithRotation({\n      s: true,\n      e: textAlign === \"center\" || textAlign === \"left\",\n      w: textAlign === \"center\" || textAlign === \"right\"\n    }, element.x, element.y, element.angle, deltaX1, deltaY1, deltaX2, deltaY2);\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline\n  };\n};\n\nexport const updateTextElement = (element, {\n  text,\n  isDeleted\n}) => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted !== null && isDeleted !== void 0 ? isDeleted : element.isDeleted,\n    ...getAdjustedDimensions(element, text)\n  });\n};\nexport const newLinearElement = opts => {\n  return { ..._newElementBase(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead\n  };\n}; // Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\n\nexport const deepCopyElement = (val, depth = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp = typeof val.constructor === \"function\" ? Object.create(Object.getPrototypeOf(val)) : {};\n\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n\n    return arr;\n  }\n\n  return val;\n};\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\n\nexport const duplicateElement = (editingGroupId, groupIdMapForOperation, element, overrides) => {\n  let copy = deepCopyElement(element);\n  copy.id = process.env.NODE_ENV === \"test\" ? `${copy.id}_copy` : randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(copy.groupIds, editingGroupId, groupId => {\n    if (!groupIdMapForOperation.has(groupId)) {\n      groupIdMapForOperation.set(groupId, randomId());\n    }\n\n    return groupIdMapForOperation.get(groupId);\n  });\n\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n\n  return copy;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/newElement.ts"],"names":["measureText","getFontString","randomInteger","randomId","newElementWith","getNewGroupIdsForDuplication","getElementAbsoluteCoords","adjustXYWithRotation","getResizedElementAbsoluteCoords","_newElementBase","type","x","y","strokeColor","backgroundColor","fillStyle","strokeWidth","strokeStyle","roughness","opacity","width","height","angle","groupIds","strokeSharpness","boundElementIds","rest","id","seed","version","versionNonce","isDeleted","newElement","opts","getTextElementPositionOffsets","metrics","textAlign","verticalAlign","newTextElement","text","offsets","textElement","fontSize","fontFamily","baseline","getAdjustedDimensions","element","nextText","nextWidth","nextHeight","nextBaseline","prevMetrics","x1","y1","x2","y2","nextX1","nextY1","nextX2","nextY2","deltaX1","deltaY1","deltaX2","deltaY2","s","e","w","Number","isFinite","updateTextElement","newLinearElement","points","lastCommittedPoint","startBinding","endBinding","startArrowhead","endArrowhead","deepCopyElement","val","depth","Object","prototype","toString","call","tmp","constructor","create","getPrototypeOf","key","hasOwnProperty","Array","isArray","k","length","arr","duplicateElement","editingGroupId","groupIdMapForOperation","overrides","copy","process","env","NODE_ENV","groupId","has","set","get","assign"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  FontFamily,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"boundElementIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    strokeSharpness,\n    boundElementIds = null,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  strokeSharpness,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n  boundElementIds,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamily;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n  const { textAlign, verticalAlign } = element;\n\n  let x: number;\n  let y: number;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  copy.id = process.env.NODE_ENV === \"test\" ? `${copy.id}_copy` : randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n"]},"metadata":{},"sourceType":"module"}