{"ast":null,"code":"import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n  constructor(helper) {\n    this.helper = helper;\n  }\n\n  fillPolygon(points, o) {\n    o = Object.assign({}, o, {\n      curveStepCount: 4,\n      hachureAngle: 0,\n      roughness: 1\n    });\n    const lines = polygonHachureLines(points, o);\n    return this.dotsOnLines(lines, o);\n  }\n\n  dotsOnLines(lines, o) {\n    const ops = [];\n    let gap = o.hachureGap;\n\n    if (gap < 0) {\n      gap = o.strokeWidth * 4;\n    }\n\n    gap = Math.max(gap, 0.1);\n    let fweight = o.fillWeight;\n\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n\n    const ro = gap / 4;\n\n    for (const line of lines) {\n      const length = lineLength(line);\n      const dl = length / gap;\n      const count = Math.ceil(dl) - 1;\n      const offset = length - count * gap;\n      const x = (line[0][0] + line[1][0]) / 2 - gap / 4;\n      const minY = Math.min(line[0][1], line[1][1]);\n\n      for (let i = 0; i < count; i++) {\n        const y = minY + offset + i * gap;\n        const cx = this.helper.randOffsetWithRange(x - ro, x + ro, o);\n        const cy = this.helper.randOffsetWithRange(y - ro, y + ro, o);\n        const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n        ops.push(...el.ops);\n      }\n    }\n\n    return {\n      type: 'fillSketch',\n      ops\n    };\n  }\n\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/roughjs/bin/fillers/dot-filler.js"],"names":["lineLength","polygonHachureLines","DotFiller","constructor","helper","fillPolygon","points","o","Object","assign","curveStepCount","hachureAngle","roughness","lines","dotsOnLines","ops","gap","hachureGap","strokeWidth","Math","max","fweight","fillWeight","ro","line","length","dl","count","ceil","offset","x","minY","min","i","y","cx","randOffsetWithRange","cy","el","ellipse","push","type"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0, roughness: 1 });\n        const lines = polygonHachureLines(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = this.helper.randOffsetWithRange(x - ro, x + ro, o);\n                const cy = this.helper.randOffsetWithRange(y - ro, y + ro, o);\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}