{"ast":null,"code":"import { getSelectedElements } from \"./scene\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { canvasToBlob } from \"./data/blob\";\nconst TYPE_ELEMENTS = \"excalidraw/elements\";\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\nexport const probablySupportsClipboardReadText = \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\nexport const probablySupportsClipboardWriteText = \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\nexport const probablySupportsClipboardBlob = \"clipboard\" in navigator && \"write\" in navigator.clipboard && \"ClipboardItem\" in window && \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst isElementsClipboard = contents => {\n  if ((contents === null || contents === void 0 ? void 0 : contents.type) === TYPE_ELEMENTS) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const copyToClipboard = async (elements, appState) => {\n  const contents = {\n    type: TYPE_ELEMENTS,\n    created: Date.now(),\n    elements: getSelectedElements(elements, appState)\n  };\n  const json = JSON.stringify(contents);\n  CLIPBOARD = json;\n\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = () => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = text => {\n  const result = tryParseSpreadsheet(text);\n\n  if (result.type === VALID_SPREADSHEET) {\n    return {\n      spreadsheet: result.spreadsheet\n    };\n  }\n\n  return null;\n};\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\n\n\nconst getSystemClipboard = async (event) => {\n  try {\n    var _event$clipboardData;\n\n    const text = event ? (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData(\"text/plain\").trim() : probablySupportsClipboardReadText && (await navigator.clipboard.readText());\n    return text || \"\";\n  } catch {\n    return \"\";\n  }\n};\n/**\n * Attemps to parse clipboard. Prefers system clipboard.\n */\n\n\nexport const parseClipboard = async (event) => {\n  const systemClipboard = await getSystemClipboard(event); // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n\n  if (!systemClipboard || systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  } // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n\n\n  const spreadsheetResult = parsePotentialSpreadsheet(systemClipboard);\n\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard); // system clipboard elements are newer than in-app clipboard\n\n    if (isElementsClipboard(systemClipboardData) && (!(appClipboardData === null || appClipboardData === void 0 ? void 0 : appClipboardData.created) || appClipboardData.created < systemClipboardData.created)) {\n      return {\n        elements: systemClipboardData.elements\n      };\n    } // in-app clipboard is newer than system clipboard\n\n\n    return appClipboardData;\n  } catch {\n    // system clipboard doesn't contain excalidraw elements → return plaintext\n    // unless we set a flag to prefer in-app clipboard because browser didn't\n    // support storing to system clipboard on copy\n    return PREFER_APP_CLIPBOARD && appClipboardData.elements ? appClipboardData : {\n      text: systemClipboard\n    };\n  }\n};\nexport const copyCanvasToClipboardAsPng = async canvas => {\n  const blob = await canvasToBlob(canvas);\n  await navigator.clipboard.write([new window.ClipboardItem({\n    \"image/png\": blob\n  })]);\n};\nexport const copyTextToSystemClipboard = async text => {\n  let copied = false;\n\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  } // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n\n\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n}; // adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\n\nconst copyTextViaExecCommand = text => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n  const textarea = document.createElement(\"textarea\");\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`; // Prevent zooming on iOS\n\n  textarea.style.fontSize = \"12pt\";\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n  document.body.appendChild(textarea);\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n  return success;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/clipboard.ts"],"names":["getSelectedElements","SVG_EXPORT_TAG","tryParseSpreadsheet","VALID_SPREADSHEET","canvasToBlob","TYPE_ELEMENTS","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","navigator","clipboard","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","window","HTMLCanvasElement","prototype","isElementsClipboard","contents","type","copyToClipboard","elements","appState","created","Date","now","json","JSON","stringify","copyTextToSystemClipboard","error","console","getAppClipboard","parse","parsePotentialSpreadsheet","text","result","spreadsheet","getSystemClipboard","event","clipboardData","getData","trim","readText","parseClipboard","systemClipboard","includes","spreadsheetResult","appClipboardData","systemClipboardData","copyCanvasToClipboardAsPng","canvas","blob","write","ClipboardItem","copied","writeText","copyTextViaExecCommand","Error","isRTL","document","documentElement","getAttribute","textarea","createElement","style","border","padding","margin","position","yPosition","pageYOffset","scrollTop","top","fontSize","setAttribute","value","body","appendChild","success","select","setSelectionRange","length","execCommand","remove"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, Spreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { canvasToBlob } from \"./data/blob\";\n\nconst TYPE_ELEMENTS = \"excalidraw/elements\";\n\ntype ElementsClipboard = {\n  type: typeof TYPE_ELEMENTS;\n  created: number;\n  elements: ExcalidrawElement[];\n};\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst isElementsClipboard = (contents: any): contents is ElementsClipboard => {\n  if (contents?.type === TYPE_ELEMENTS) {\n    return true;\n  }\n  return false;\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  const contents: ElementsClipboard = {\n    type: TYPE_ELEMENTS,\n    created: Date.now(),\n    elements: getSelectedElements(elements, appState),\n  };\n  const json = JSON.stringify(contents);\n  CLIPBOARD = json;\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = (): Partial<ElementsClipboard> => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nconst getSystemClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<string> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    return text || \"\";\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attemps to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<{\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  text?: string;\n  errorMessage?: string;\n}> => {\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (!systemClipboard || systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult = parsePotentialSpreadsheet(systemClipboard);\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    // system clipboard elements are newer than in-app clipboard\n    if (\n      isElementsClipboard(systemClipboardData) &&\n      (!appClipboardData?.created ||\n        appClipboardData.created < systemClipboardData.created)\n    ) {\n      return { elements: systemClipboardData.elements };\n    }\n    // in-app clipboard is newer than system clipboard\n    return appClipboardData;\n  } catch {\n    // system clipboard doesn't contain excalidraw elements → return plaintext\n    // unless we set a flag to prefer in-app clipboard because browser didn't\n    // support storing to system clipboard on copy\n    return PREFER_APP_CLIPBOARD && appClipboardData.elements\n      ? appClipboardData\n      : { text: systemClipboard };\n  }\n};\n\nexport const copyCanvasToClipboardAsPng = async (canvas: HTMLCanvasElement) => {\n  const blob = await canvasToBlob(canvas);\n  await navigator.clipboard.write([\n    new window.ClipboardItem({ \"image/png\": blob }),\n  ]);\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n"]},"metadata":{},"sourceType":"module"}