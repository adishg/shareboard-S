{"ast":null,"code":"import { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { bindOrUnbindLinearElement, getHoveredElementForBinding, isBindingEnabled } from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\nexport class LinearElementEditor {\n  /** whether you're dragging a point */\n  constructor(element, scene) {\n    this.elementId = void 0;\n    this.activePointIndex = void 0;\n    this.isDragging = void 0;\n    this.lastUncommittedPoint = void 0;\n    this.pointerOffset = void 0;\n    this.startBindingElement = void 0;\n    this.endBindingElement = void 0;\n    this.elementId = element.id;\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = {\n      x: 0,\n      y: 0\n    };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  } // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id) {\n    var _Scene$getScene;\n\n    const element = (_Scene$getScene = Scene.getScene(id)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getNonDeletedElement(id);\n\n    if (element) {\n      return element;\n    }\n\n    return null;\n  }\n  /** @returns whether point was dragged */\n\n\n  static handlePointDragging(appState, setState, scenePointerX, scenePointerY, maybeSuggestBinding) {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n\n    const {\n      editingLinearElement\n    } = appState;\n    const {\n      activePointIndex,\n      elementId,\n      isDragging\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: { ...editingLinearElement,\n            isDragging: true\n          }\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(element, scenePointerX - editingLinearElement.pointerOffset.x, scenePointerY - editingLinearElement.pointerOffset.y, appState.gridSize);\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  static handlePointerUp(event, editingLinearElement, appState) {\n    const {\n      elementId,\n      activePointIndex,\n      isDragging\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n\n    if (isDragging && (activePointIndex === 0 || activePointIndex === element.points.length - 1)) {\n      if (isPathALoop(element.points)) {\n        LinearElementEditor.movePoint(element, activePointIndex, activePointIndex === 0 ? element.points[element.points.length - 1] : element.points[0]);\n      }\n\n      const bindingElement = isBindingEnabled(appState) ? getHoveredElementForBinding(tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(element, activePointIndex)), Scene.getScene(element)) : null;\n      binding = {\n        [activePointIndex === 0 ? \"startBindingElement\" : \"endBindingElement\"]: bindingElement\n      };\n    }\n\n    return { ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: {\n        x: 0,\n        y: 0\n      }\n    };\n  }\n\n  static handlePointerDown(event, appState, setState, history, scenePointer) {\n    const ret = {\n      didAddPoint: false,\n      hitElement: null\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const {\n      elementId\n    } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [...element.points, LinearElementEditor.createPointAt(element, scenePointer.x, scenePointer.y, appState.gridSize)]\n        });\n      }\n\n      history.resumeRecording();\n      setState({\n        editingLinearElement: { ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(scenePointer, Scene.getScene(element))\n        }\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(element, appState.zoom, scenePointer.x, scenePointer.y); // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement\n      } = appState.editingLinearElement;\n\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(element, startBindingElement, endBindingElement);\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint = clickedPointIndex > -1 && rotate(element.x + element.points[clickedPointIndex][0], element.y + element.points[clickedPointIndex][1], cx, cy, element.angle);\n    setState({\n      editingLinearElement: { ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint ? {\n          x: scenePointer.x - targetPoint[0],\n          y: scenePointer.y - targetPoint[1]\n        } : {\n          x: 0,\n          y: 0\n        }\n      }\n    });\n    return ret;\n  }\n\n  static handlePointerMove(event, scenePointerX, scenePointerY, editingLinearElement, gridSize) {\n    const {\n      elementId,\n      lastUncommittedPoint\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const {\n      points\n    } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n\n      return { ...editingLinearElement,\n        lastUncommittedPoint: null\n      };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(element, scenePointerX - editingLinearElement.pointerOffset.x, scenePointerY - editingLinearElement.pointerOffset.y, gridSize);\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(element, element.points.length - 1, newPoint);\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return { ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1]\n    };\n  }\n\n  static getPointsGlobalCoordinates(element) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map(point => {\n      let {\n        x,\n        y\n      } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(element, indexMaybeFromEnd) {\n    const index = indexMaybeFromEnd < 0 ? element.points.length + indexMaybeFromEnd : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const point = element.points[index];\n    const {\n      x,\n      y\n    } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(element, absoluteCoords) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(absoluteCoords[0], absoluteCoords[1], cx, cy, -element.angle);\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(element, zoom, x, y) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length; // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n\n      if (distance2d(x, y, point[0], point[1]) * zoom.value < // +1px to account for outline stroke\n      this.POINT_HANDLE_SIZE / 2 + 1) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  static createPointAt(element, scenePointerX, scenePointerY, gridSize) {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(pointerOnGrid[0], pointerOnGrid[1], cx, cy, -element.angle);\n    return [rotatedX - element.x, rotatedY - element.y];\n  } // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n\n\n  static normalizePoints(element) {\n    const {\n      points\n    } = element;\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY];\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY\n    });\n  }\n\n  static movePointByOffset(element, pointIndex, offset) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [x + offset.x, y + offset.y]);\n  }\n\n  static movePoint(element, pointIndex, targetPosition, otherUpdates) {\n    const {\n      points\n    } = element; // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n\n    let offsetX = 0;\n    let offsetY = 0;\n    let nextPoints;\n\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n\n          offsetX = 0;\n          offsetY = 0;\n          return [point[0] + deltaX, point[1] + deltaY];\n        }\n\n        return offsetX || offsetY ? [point[0] - offsetX, point[1] - offsetY] : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(element, nextPoints, element.strokeSharpness || \"round\");\n    const prevCoords = getElementPointsCoords(element, points, element.strokeSharpness || \"round\");\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n    mutateElement(element, { ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1]\n    });\n  }\n\n}\nLinearElementEditor.POINT_HANDLE_SIZE = 20;","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/linearElementEditor.ts"],"names":["distance2d","rotate","isPathALoop","getGridPoint","getElementAbsoluteCoords","getElementPointsCoords","mutateElement","Scene","bindOrUnbindLinearElement","getHoveredElementForBinding","isBindingEnabled","tupleToCoors","isBindingElement","LinearElementEditor","constructor","element","scene","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","id","mapElementToScene","normalizePoints","x","y","getElement","getScene","getNonDeletedElement","handlePointDragging","appState","setState","scenePointerX","scenePointerY","maybeSuggestBinding","editingLinearElement","newPoint","createPointAt","gridSize","movePoint","handlePointerUp","event","binding","points","length","bindingElement","getPointAtIndexGlobalCoordinates","handlePointerDown","history","scenePointer","ret","didAddPoint","hitElement","altKey","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","zoom","x1","y1","x2","y2","cx","cy","targetPoint","angle","handlePointerMove","lastPoint","getPointsGlobalCoordinates","map","point","indexMaybeFromEnd","index","pointFromAbsoluteCoords","absoluteCoords","pointHandles","idx","value","POINT_HANDLE_SIZE","pointerOnGrid","rotatedX","rotatedY","offsetX","offsetY","_idx","movePointByOffset","pointIndex","offset","targetPosition","otherUpdates","nextPoints","Error","slice","splice","deltaX","deltaY","nextCoords","strokeSharpness","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","dX","dY","rotated"],"mappings":"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","sourcesContent":["import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { SceneHistory } from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n  public startBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      startOrEnd: \"start\" | \"end\",\n    ) => void,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n    if (\n      isDragging &&\n      (activePointIndex === 0 || activePointIndex === element.points.length - 1)\n    ) {\n      if (isPathALoop(element.points)) {\n        LinearElementEditor.movePoint(\n          element,\n          activePointIndex,\n          activePointIndex === 0\n            ? element.points[element.points.length - 1]\n            : element.points[0],\n        );\n      }\n      const bindingElement = isBindingEnabled(appState)\n        ? getHoveredElementForBinding(\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                activePointIndex!,\n              ),\n            ),\n            Scene.getScene(element)!,\n          )\n        : null;\n      binding = {\n        [activePointIndex === 0\n          ? \"startBindingElement\"\n          : \"endBindingElement\"]: bindingElement,\n      };\n    }\n    return {\n      ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: SceneHistory,\n    scenePointer: { x: number; y: number },\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(\n            scenePointer,\n            Scene.getScene(element)!,\n          ),\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointer.x - targetPoint[0],\n              y: scenePointer.y - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return { ...editingLinearElement, lastUncommittedPoint: null };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    });\n  }\n\n  static movePointByOffset(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number,\n    offset: { x: number; y: number },\n  ) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [\n      x + offset.x,\n      y + offset.y,\n    ]);\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(\n      element,\n      nextPoints,\n      element.strokeSharpness || \"round\",\n    );\n    const prevCoords = getElementPointsCoords(\n      element,\n      points,\n      element.strokeSharpness || \"round\",\n    );\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}