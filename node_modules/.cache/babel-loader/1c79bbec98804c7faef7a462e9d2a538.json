{"ast":null,"code":"import { RoughGenerator } from './generator';\nexport class RoughCanvas {\n  constructor(canvas, config) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.gen = new RoughGenerator(config);\n  }\n\n  draw(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.getDefaultOptions();\n    const ctx = this.ctx;\n\n    for (const drawing of sets) {\n      switch (drawing.type) {\n        case 'path':\n          ctx.save();\n          ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n          ctx.lineWidth = o.strokeWidth;\n\n          if (o.strokeLineDash) {\n            ctx.setLineDash(o.strokeLineDash);\n          }\n\n          if (o.strokeLineDashOffset) {\n            ctx.lineDashOffset = o.strokeLineDashOffset;\n          }\n\n          this._drawToContext(ctx, drawing);\n\n          ctx.restore();\n          break;\n\n        case 'fillPath':\n          ctx.save();\n          ctx.fillStyle = o.fill || '';\n          const fillRule = drawable.shape === 'curve' || drawable.shape === 'polygon' ? 'evenodd' : 'nonzero';\n\n          this._drawToContext(ctx, drawing, fillRule);\n\n          ctx.restore();\n          break;\n\n        case 'fillSketch':\n          this.fillSketch(ctx, drawing, o);\n          break;\n      }\n    }\n  }\n\n  fillSketch(ctx, drawing, o) {\n    let fweight = o.fillWeight;\n\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n\n    ctx.save();\n\n    if (o.fillLineDash) {\n      ctx.setLineDash(o.fillLineDash);\n    }\n\n    if (o.fillLineDashOffset) {\n      ctx.lineDashOffset = o.fillLineDashOffset;\n    }\n\n    ctx.strokeStyle = o.fill || '';\n    ctx.lineWidth = fweight;\n\n    this._drawToContext(ctx, drawing);\n\n    ctx.restore();\n  }\n\n  _drawToContext(ctx, drawing, rule = 'nonzero') {\n    ctx.beginPath();\n\n    for (const item of drawing.ops) {\n      const data = item.data;\n\n      switch (item.op) {\n        case 'move':\n          ctx.moveTo(data[0], data[1]);\n          break;\n\n        case 'bcurveTo':\n          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n          break;\n\n        case 'lineTo':\n          ctx.lineTo(data[0], data[1]);\n          break;\n      }\n    }\n\n    if (drawing.type === 'fillPath') {\n      ctx.fill(rule);\n    } else {\n      ctx.stroke();\n    }\n  }\n\n  get generator() {\n    return this.gen;\n  }\n\n  getDefaultOptions() {\n    return this.gen.defaultOptions;\n  }\n\n  line(x1, y1, x2, y2, options) {\n    const d = this.gen.line(x1, y1, x2, y2, options);\n    this.draw(d);\n    return d;\n  }\n\n  rectangle(x, y, width, height, options) {\n    const d = this.gen.rectangle(x, y, width, height, options);\n    this.draw(d);\n    return d;\n  }\n\n  ellipse(x, y, width, height, options) {\n    const d = this.gen.ellipse(x, y, width, height, options);\n    this.draw(d);\n    return d;\n  }\n\n  circle(x, y, diameter, options) {\n    const d = this.gen.circle(x, y, diameter, options);\n    this.draw(d);\n    return d;\n  }\n\n  linearPath(points, options) {\n    const d = this.gen.linearPath(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  polygon(points, options) {\n    const d = this.gen.polygon(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  arc(x, y, width, height, start, stop, closed = false, options) {\n    const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n    this.draw(d);\n    return d;\n  }\n\n  curve(points, options) {\n    const d = this.gen.curve(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  path(d, options) {\n    const drawing = this.gen.path(d, options);\n    this.draw(drawing);\n    return drawing;\n  }\n\n}","map":{"version":3,"sources":["/var/www/html/excalidraw/node_modules/roughjs/bin/canvas.js"],"names":["RoughGenerator","RoughCanvas","constructor","canvas","config","ctx","getContext","gen","draw","drawable","sets","o","options","getDefaultOptions","drawing","type","save","strokeStyle","stroke","lineWidth","strokeWidth","strokeLineDash","setLineDash","strokeLineDashOffset","lineDashOffset","_drawToContext","restore","fillStyle","fill","fillRule","shape","fillSketch","fweight","fillWeight","fillLineDash","fillLineDashOffset","rule","beginPath","item","ops","data","op","moveTo","bezierCurveTo","lineTo","generator","defaultOptions","line","x1","y1","x2","y2","d","rectangle","x","y","width","height","ellipse","circle","diameter","linearPath","points","polygon","arc","start","stop","closed","curve","path"],"mappings":"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","sourcesContent":["import { RoughGenerator } from './generator';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, fillRule);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}