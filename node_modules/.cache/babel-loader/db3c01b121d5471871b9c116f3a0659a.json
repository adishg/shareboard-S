{"ast":null,"code":"import { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nexport const rotate = (x1, y1, x2, y2, angle) => // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n// 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n// https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n[(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];\nexport const rotatePoint = (point, center, angle) => rotate(point[0], point[1], center[0], center[1], angle);\nexport const adjustXYWithRotation = (sides, x, y, angle, deltaX1, deltaY1, deltaX2, deltaY2) => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n\n  return [x, y];\n};\nexport const getPointOnAPath = (point, path) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine = 0;\n  let idx = 0; // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n    lastX = x2;\n    lastY = y2; // if a point is not within the domain of the line segment\n    // it is not on the line segment\n\n    if (px < x1 || px > x2) {\n      return false;\n    } // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n    // coefficient for the line (p0, p1)\n\n\n    const kL = (y2 - y1) / (x2 - x1); // coefficient for the line segment (p0, point)\n\n    const kP1 = (py - y1) / (px - x1); // coefficient for the line segment (point, p1)\n\n    const kP2 = (py - y2) / (px - x2); // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n    // using it for floating point comparisons\n\n    const epsilon = 0.3; // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    } // store the coefficient because we are goint to need it\n\n\n    kLine = kL;\n    idx = i;\n    return true;\n  }); // Return a coordinate that is always on the line segment\n\n  if (retVal === true) {\n    return {\n      x: point[0],\n      y: kLine * point[0],\n      segment: idx\n    };\n  }\n\n  return null;\n};\nexport const distance2d = (x1, y1, x2, y2) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\nexport const centerPoint = (a, b) => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n}; // Checks if the first and last point are close enough\n// to be considered a loop\n\nexport const isPathALoop = points => {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <= LINE_CONFIRM_THRESHOLD;\n  }\n\n  return false;\n}; // Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\n\nexport const isPointInPolygon = (points, x, y) => {\n  const vertices = points.length; // There must be at least 3 vertices in polygon\n\n  if (vertices < 3) {\n    return false;\n  }\n\n  const extreme = [Number.MAX_SAFE_INTEGER, y];\n  const p = [x, y];\n  let count = 0;\n\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n\n      count++;\n    }\n  } // true if count is off\n\n\n  return count % 2 === 1;\n}; // Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\n\nconst isPointWithinBounds = (p, q, r) => {\n  return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);\n}; // For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\n\n\nconst orderedColinearOrientation = (p, q, r) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (val === 0) {\n    return 0;\n  }\n\n  return val > 0 ? 1 : 2;\n}; // Check is p1q1 intersects with p2q2\n\n\nconst doSegmentsIntersect = (p1, q1, p2, q2) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  } // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n\n\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  } // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n\n\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  } // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n\n\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  } // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n\n\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getGridPoint = (x, y, gridSize) => {\n  if (gridSize) {\n    return [Math.round(x / gridSize) * gridSize, Math.round(y / gridSize) * gridSize];\n  }\n\n  return [x, y];\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/math.ts"],"names":["LINE_CONFIRM_THRESHOLD","rotate","x1","y1","x2","y2","angle","Math","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","x","y","deltaX1","deltaY1","deltaX2","deltaY2","e","w","n","s","getPointOnAPath","path","px","py","start","other","lastX","lastY","kLine","idx","retVal","some","i","kL","kP1","kP2","epsilon","abs","segment","distance2d","xd","yd","hypot","centerPoint","a","b","isPathALoop","points","length","firstPoint","lastPoint","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","min","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","gridSize","round"],"mappings":"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","sourcesContent":["import { Point } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n): boolean => {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return (\n      distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <=\n      LINE_CONFIRM_THRESHOLD\n    );\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nconst isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n"]},"metadata":{},"sourceType":"module"}