{"ast":null,"code":"import { deflate, inflate } from \"pako\"; // -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n// fast, Buffer-compatible implem\n\nexport const toByteString = data => {\n  return new Promise((resolve, reject) => {\n    const blob = typeof data === \"string\" ? new Blob([new TextEncoder().encode(data)]) : new Blob([data]);\n    const reader = new FileReader();\n\n    reader.onload = event => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n\n      resolve(event.target.result);\n    };\n\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = byteString => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n\n  return buffer;\n};\n\nconst byteStringToString = byteString => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n}; // -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\n\n\nexport const stringToBase64 = async (str, isByteString = false) => {\n  return isByteString ? btoa(str) : btoa(await toByteString(str));\n}; // async to align with stringToBase64\n\nexport const base64ToString = async (base64, isByteString = false) => {\n  return isByteString ? atob(base64) : byteStringToString(atob(base64));\n}; // -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress\n}) => {\n  let deflated;\n\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text))\n  };\n};\nexport const decode = async data => {\n  let decoded;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed ? data.encoded : await byteStringToString(data.encoded);\n      break;\n\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\"\n    });\n  }\n\n  return decoded;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/data/encode.ts"],"names":["deflate","inflate","toByteString","data","Promise","resolve","reject","blob","Blob","TextEncoder","encode","reader","FileReader","onload","event","target","result","Error","readAsBinaryString","byteStringToArrayBuffer","byteString","buffer","ArrayBuffer","length","bufferView","Uint8Array","i","len","charCodeAt","byteStringToString","TextDecoder","decode","stringToBase64","str","isByteString","btoa","base64ToString","base64","atob","text","compress","deflated","error","console","version","encoding","compressed","encoded","decoded","to"],"mappings":"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","sourcesContent":["import { deflate, inflate } from \"pako\";\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n\n// fast, Buffer-compatible implem\nexport const toByteString = (data: string | Uint8Array): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const blob =\n      typeof data === \"string\"\n        ? new Blob([new TextEncoder().encode(data)])\n        : new Blob([data]);\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = (byteString: string) => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n};\n\nconst byteStringToString = (byteString: string) => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nexport const stringToBase64 = async (str: string, isByteString = false) => {\n  return isByteString ? btoa(str) : btoa(await toByteString(str));\n};\n\n// async to align with stringToBase64\nexport const base64ToString = async (base64: string, isByteString = false) => {\n  return isByteString ? atob(base64) : byteStringToString(atob(base64));\n};\n\n// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\ntype EncodedData = {\n  encoded: string;\n  encoding: \"bstring\";\n  /** whether text is compressed (zlib) */\n  compressed: boolean;\n  /** version for potential migration purposes */\n  version?: string;\n};\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress,\n}: {\n  text: string;\n  /** defaults to `true`. If compression fails, falls back to bstring alone. */\n  compress?: boolean;\n}): Promise<EncodedData> => {\n  let deflated!: string;\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text)),\n  };\n};\n\nexport const decode = async (data: EncodedData): Promise<string> => {\n  let decoded: string;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed\n        ? data.encoded\n        : await byteStringToString(data.encoded);\n      break;\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\",\n    });\n  }\n\n  return decoded;\n};\n"]},"metadata":{},"sourceType":"module"}