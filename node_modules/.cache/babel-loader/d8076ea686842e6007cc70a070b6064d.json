{"ast":null,"code":"import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { MIME_TYPES } from \"../constants\"; // -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nconst blobToArrayBuffer = blob => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  } // Safari\n\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = event => {\n      var _event$target;\n\n      if (!((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result)) {\n        return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n      }\n\n      resolve(event.target.result);\n    };\n\n    reader.readAsArrayBuffer(blob);\n  });\n};\n\nexport const getTEXtChunk = async (blob) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find(chunk => chunk.name === \"tEXt\");\n\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n\n  return null;\n};\nexport const encodePngMetadata = async ({\n  blob,\n  metadata\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = tEXt.encode(MIME_TYPES.excalidraw, JSON.stringify(await encode({\n    text: metadata,\n    compress: true\n  }))); // insert metadata before last chunk (iEND)\n\n  chunks.splice(-1, 0, metadataChunk);\n  return new Blob([encodePng(chunks)], {\n    type: \"image/png\"\n  });\n};\nexport const decodePngMetadata = async blob => {\n  const metadata = await getTEXtChunk(blob);\n\n  if ((metadata === null || metadata === void 0 ? void 0 : metadata.keyword) === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return metadata.text;\n        }\n\n        throw new Error(\"FAILED\");\n      }\n\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n\n  throw new Error(\"INVALID\");\n}; // -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({\n  text\n}) => {\n  const base64 = await stringToBase64(JSON.stringify(await encode({\n    text\n  })), true\n  /* is already byte string */\n  );\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\nexport const decodeSvgMetadata = async ({\n  svg\n}) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = (versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch[1]) || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return json;\n        }\n\n        throw new Error(\"FAILED\");\n      }\n\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n\n  throw new Error(\"INVALID\");\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/data/image.ts"],"names":["decodePng","tEXt","encodePng","stringToBase64","encode","decode","base64ToString","MIME_TYPES","blobToArrayBuffer","blob","arrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","result","Error","readAsArrayBuffer","getTEXtChunk","chunks","Uint8Array","metadataChunk","find","chunk","name","data","encodePngMetadata","metadata","excalidraw","JSON","stringify","text","compress","splice","Blob","type","decodePngMetadata","keyword","encodedData","parse","error","console","encodeSvgMetadata","base64","decodeSvgMetadata","svg","includes","match","versionMatch","version","isByteString","json"],"mappings":"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","sourcesContent":["import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { MIME_TYPES } from \"../constants\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nconst blobToArrayBuffer = (blob: Blob): Promise<ArrayBuffer> => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target?.result) {\n        return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result as ArrayBuffer);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: \"image/png\" });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"]},"metadata":{},"sourceType":"module"}