{"ast":null,"code":"import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\nimport { rotate, adjustXYWithRotation, centerPoint, rotatePoint } from \"../math\";\nimport { getElementAbsoluteCoords, getCommonBounds, getResizedElementAbsoluteCoords } from \"./bounds\";\nimport { isLinearElement, isTextElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getCursorForResizingElement } from \"./resizeTest\";\nimport { measureText, getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\n\nconst normalizeAngle = angle => {\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n\n  return angle;\n}; // Returns true when transform (resizing/rotation) happened\n\n\nexport const transformElements = (pointerDownState, transformHandleType, selectedElements, resizeArrowDirection, isRotateWithDiscreteAngle, isResizeCenterPoint, shouldKeepSidesRatio, pointerX, pointerY, centerX, centerY) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(element, pointerX, pointerY, isRotateWithDiscreteAngle);\n      updateBoundElements(element);\n    } else if (isLinearElement(element) && element.points.length === 2 && (transformHandleType === \"nw\" || transformHandleType === \"ne\" || transformHandleType === \"sw\" || transformHandleType === \"se\")) {\n      reshapeSingleTwoPointElement(element, resizeArrowDirection, isRotateWithDiscreteAngle, pointerX, pointerY);\n    } else if (isTextElement(element) && (transformHandleType === \"nw\" || transformHandleType === \"ne\" || transformHandleType === \"sw\" || transformHandleType === \"se\")) {\n      resizeSingleTextElement(element, transformHandleType, isResizeCenterPoint, pointerX, pointerY);\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(pointerDownState.originalElements.get(element.id), shouldKeepSidesRatio, element, transformHandleType, isResizeCenterPoint, pointerX, pointerY);\n    } // update cursor\n    // FIXME it is not very nice to have this here\n\n\n    document.documentElement.style.cursor = getCursorForResizingElement({\n      element,\n      transformHandleType\n    });\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(pointerDownState, selectedElements, pointerX, pointerY, isRotateWithDiscreteAngle, centerX, centerY);\n      return true;\n    } else if (transformHandleType === \"nw\" || transformHandleType === \"ne\" || transformHandleType === \"sw\" || transformHandleType === \"se\") {\n      resizeMultipleElements(selectedElements, transformHandleType, pointerX, pointerY);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst rotateSingleElement = (element, pointerX, pointerY, isRotateWithDiscreteAngle) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle = 5 * Math.PI / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n\n  if (isRotateWithDiscreteAngle) {\n    angle += SHIFT_LOCKING_ANGLE / 2;\n    angle -= angle % SHIFT_LOCKING_ANGLE;\n  }\n\n  angle = normalizeAngle(angle);\n  mutateElement(element, {\n    angle\n  });\n}; // used in DEV only\n\n\nconst validateTwoPointElementNormalized = element => {\n  if (element.points.length !== 2 || element.points[0][0] !== 0 || element.points[0][1] !== 0 || Math.abs(element.points[1][0]) !== element.width || Math.abs(element.points[1][1]) !== element.height) {\n    throw new Error(\"Two-point element is not normalized\");\n  }\n};\n\nconst getPerfectElementSizeWithRotation = (elementType, width, height, angle) => {\n  const size = getPerfectElementSize(elementType, ...rotate(width, height, 0, 0, angle));\n  return rotate(size.width, size.height, 0, 0, -angle);\n};\n\nconst reshapeSingleTwoPointElement = (element, resizeArrowDirection, isRotateWithDiscreteAngle, pointerX, pointerY) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTwoPointElementNormalized(element);\n  }\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2; // rotation pointer with reverse angle\n\n  const [rotatedX, rotatedY] = rotate(pointerX, pointerY, cx, cy, -element.angle);\n  let [width, height] = resizeArrowDirection === \"end\" ? [rotatedX - element.x, rotatedY - element.y] : [element.x + element.points[1][0] - rotatedX, element.y + element.points[1][1] - rotatedY];\n\n  if (isRotateWithDiscreteAngle) {\n    [width, height] = getPerfectElementSizeWithRotation(element.type, width, height, element.angle);\n  }\n\n  const [nextElementX, nextElementY] = adjustXYWithRotation(resizeArrowDirection === \"end\" ? {\n    s: true,\n    e: true\n  } : {\n    n: true,\n    w: true\n  }, element.x, element.y, element.angle, 0, 0, (element.points[1][0] - width) / 2, (element.points[1][1] - height) / 2);\n  mutateElement(element, {\n    x: nextElementX,\n    y: nextElementY,\n    points: [[0, 0], [width, height]]\n  });\n};\n\nconst rescalePointsInElement = (element, width, height) => isLinearElement(element) ? {\n  points: rescalePoints(0, width, rescalePoints(1, height, element.points))\n} : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWH = (element, nextWidth, nextHeight) => {\n  // We only use width to scale font on resize\n  const nextFontSize = element.fontSize * (nextWidth / element.width);\n\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n\n  const metrics = measureText(element.text, getFontString({\n    fontSize: nextFontSize,\n    fontFamily: element.fontFamily\n  }));\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height)\n  };\n};\n\nconst getSidesForTransformHandle = (transformHandleType, isResizeFromCenter) => {\n  return {\n    n: /^(n|ne|nw)$/.test(transformHandleType) || isResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType),\n    s: /^(s|se|sw)$/.test(transformHandleType) || isResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType),\n    w: /^(w|nw|sw)$/.test(transformHandleType) || isResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType),\n    e: /^(e|ne|se)$/.test(transformHandleType) || isResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)\n  };\n};\n\nconst resizeSingleTextElement = (element, transformHandleType, isResizeFromCenter, pointerX, pointerY) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2; // rotation pointer with reverse angle\n\n  const [rotatedX, rotatedY] = rotate(pointerX, pointerY, cx, cy, -element.angle);\n  let scale;\n\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max((rotatedX - x1) / (x2 - x1), (rotatedY - y1) / (y2 - y1));\n      break;\n\n    case \"nw\":\n      scale = Math.max((x2 - rotatedX) / (x2 - x1), (y2 - rotatedY) / (y2 - y1));\n      break;\n\n    case \"ne\":\n      scale = Math.max((rotatedX - x1) / (x2 - x1), (y2 - rotatedY) / (y2 - y1));\n      break;\n\n    case \"sw\":\n      scale = Math.max((x2 - rotatedX) / (x2 - x1), (rotatedY - y1) / (y2 - y1));\n      break;\n  }\n\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const nextFont = measureFontSizeFromWH(element, nextWidth, nextHeight);\n\n    if (nextFont === null) {\n      return;\n    }\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(element, nextWidth, nextHeight);\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(getSidesForTransformHandle(transformHandleType, isResizeFromCenter), element.x, element.y, element.angle, deltaX1, deltaY1, deltaX2, deltaY2);\n    mutateElement(element, {\n      fontSize: nextFont.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextFont.baseline,\n      x: nextElementX,\n      y: nextElementY\n    });\n  }\n};\n\nconst resizeSingleElement = (stateAtResizeStart, shouldKeepSidesRatio, element, transformHandleDirection, isResizeFromCenter, pointerX, pointerY) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(stateAtResizeStart, stateAtResizeStart.width, stateAtResizeStart.height);\n  const startTopLeft = [x1, y1];\n  const startBottomRight = [x2, y2];\n  const startCenter = centerPoint(startTopLeft, startBottomRight); // Calculate new dimensions based on cursor position\n\n  const rotatedPointer = rotatePoint([pointerX, pointerY], startCenter, -stateAtResizeStart.angle); //Get bounds corners rendered on screen\n\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(element, element.width, element.height);\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1; // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  } // Linear elements dimensions differ from bounds dimensions\n\n\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height; // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY; // adjust dimensions for resizing from center\n\n  if (isResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  } // adjust dimensions to keep sides ratio\n\n\n  if (shouldKeepSidesRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(stateAtResizeStart, eleNewWidth, eleNewHeight);\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1; // Calculate new topLeft based on fixed corner during resize\n\n  let newTopLeft = [...startTopLeft];\n\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [startBottomRight[0] - Math.abs(newBoundsWidth), startBottomRight[1] - Math.abs(newBoundsHeight)];\n  }\n\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  } // Keeps opposite handle fixed during resize\n\n\n  if (shouldKeepSidesRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  } // Flip horizontally\n\n\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  } // Flip vertically\n\n\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (isResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  } // adjust topLeft to new rotation point\n\n\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter = [newTopLeft[0] + Math.abs(newBoundsWidth) / 2, newTopLeft[1] + Math.abs(newBoundsHeight) / 2];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle); // Readjust points for linear elements\n\n  const rescaledPoints = rescalePointsInElement(stateAtResizeStart, eleNewWidth, eleNewHeight); // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    ...rescaledPoints\n  };\n\n  if (resizedElement.width !== 0 && resizedElement.height !== 0 && Number.isFinite(resizedElement.x) && Number.isFinite(resizedElement.y)) {\n    updateBoundElements(element, {\n      newSize: {\n        width: resizedElement.width,\n        height: resizedElement.height\n      }\n    });\n    mutateElement(element, resizedElement);\n  }\n};\n\nconst resizeMultipleElements = (elements, transformHandleType, pointerX, pointerY) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements);\n  let scale;\n  let getNextXY;\n\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max((pointerX - x1) / (x2 - x1), (pointerY - y1) / (y2 - y1));\n\n      getNextXY = (element, [origX1, origY1], [finalX1, finalY1]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return {\n          x,\n          y\n        };\n      };\n\n      break;\n\n    case \"nw\":\n      scale = Math.max((x2 - pointerX) / (x2 - x1), (y2 - pointerY) / (y2 - y1));\n\n      getNextXY = (element, [,, origX2, origY2], [,, finalX2, finalY2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return {\n          x,\n          y\n        };\n      };\n\n      break;\n\n    case \"ne\":\n      scale = Math.max((pointerX - x1) / (x2 - x1), (y2 - pointerY) / (y2 - y1));\n\n      getNextXY = (element, [origX1,,, origY2], [finalX1,,, finalY2]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return {\n          x,\n          y\n        };\n      };\n\n      break;\n\n    case \"sw\":\n      scale = Math.max((x2 - pointerX) / (x2 - x1), (pointerY - y1) / (y2 - y1));\n\n      getNextXY = (element, [, origY1, origX2], [, finalY1, finalX2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return {\n          x,\n          y\n        };\n      };\n\n      break;\n  }\n\n  if (scale > 0) {\n    const updates = elements.reduce((prev, element) => {\n      if (!prev) {\n        return prev;\n      }\n\n      const width = element.width * scale;\n      const height = element.height * scale;\n      let font = {};\n\n      if (element.type === \"text\") {\n        const nextFont = measureFontSizeFromWH(element, width, height);\n\n        if (nextFont === null) {\n          return null;\n        }\n\n        font = {\n          fontSize: nextFont.size,\n          baseline: nextFont.baseline\n        };\n      }\n\n      const origCoords = getElementAbsoluteCoords(element);\n      const rescaledPoints = rescalePointsInElement(element, width, height);\n      updateBoundElements(element, {\n        newSize: {\n          width,\n          height\n        },\n        simultaneouslyUpdated: elements\n      });\n      const finalCoords = getResizedElementAbsoluteCoords({ ...element,\n        ...rescaledPoints\n      }, width, height);\n      const {\n        x,\n        y\n      } = getNextXY(element, origCoords, finalCoords);\n      return [...prev, {\n        width,\n        height,\n        x,\n        y,\n        ...rescaledPoints,\n        ...font\n      }];\n    }, []);\n\n    if (updates) {\n      elements.forEach((element, index) => {\n        mutateElement(element, updates[index]);\n      });\n    }\n  }\n};\n\nconst rotateMultipleElements = (pointerDownState, elements, pointerX, pointerY, isRotateWithDiscreteAngle, centerX, centerY) => {\n  let centerAngle = 5 * Math.PI / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n\n  if (isRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n\n  elements.forEach((element, index) => {\n    var _pointerDownState$ori, _pointerDownState$ori2;\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle = (_pointerDownState$ori = (_pointerDownState$ori2 = pointerDownState.originalElements.get(element.id)) === null || _pointerDownState$ori2 === void 0 ? void 0 : _pointerDownState$ori2.angle) !== null && _pointerDownState$ori !== void 0 ? _pointerDownState$ori : element.angle;\n    const [rotatedCX, rotatedCY] = rotate(cx, cy, centerX, centerY, centerAngle + origAngle - element.angle);\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle)\n    });\n  });\n};\n\nexport const getResizeOffsetXY = (transformHandleType, selectedElements, x, y) => {\n  const [x1, y1, x2, y2] = selectedElements.length === 1 ? getElementAbsoluteCoords(selectedElements[0]) : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n\n    default:\n      return [0, 0];\n  }\n};\nexport const getResizeArrowDirection = (transformHandleType, element) => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd = transformHandleType === \"nw\" && (px < 0 || py < 0) || transformHandleType === \"ne\" && px >= 0 || transformHandleType === \"sw\" && px <= 0 || transformHandleType === \"se\" && (px > 0 || py > 0);\n  return isResizeEnd ? \"end\" : \"origin\";\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/resizeElements.ts"],"names":["SHIFT_LOCKING_ANGLE","rescalePoints","rotate","adjustXYWithRotation","centerPoint","rotatePoint","getElementAbsoluteCoords","getCommonBounds","getResizedElementAbsoluteCoords","isLinearElement","isTextElement","mutateElement","getPerfectElementSize","getCursorForResizingElement","measureText","getFontString","updateBoundElements","normalizeAngle","angle","Math","PI","transformElements","pointerDownState","transformHandleType","selectedElements","resizeArrowDirection","isRotateWithDiscreteAngle","isResizeCenterPoint","shouldKeepSidesRatio","pointerX","pointerY","centerX","centerY","length","element","rotateSingleElement","points","reshapeSingleTwoPointElement","resizeSingleTextElement","resizeSingleElement","originalElements","get","id","document","documentElement","style","cursor","rotateMultipleElements","resizeMultipleElements","x1","y1","x2","y2","cx","cy","atan2","validateTwoPointElementNormalized","abs","width","height","Error","getPerfectElementSizeWithRotation","elementType","size","process","env","NODE_ENV","rotatedX","rotatedY","x","y","type","nextElementX","nextElementY","s","e","n","w","rescalePointsInElement","MIN_FONT_SIZE","measureFontSizeFromWH","nextWidth","nextHeight","nextFontSize","fontSize","metrics","text","fontFamily","baseline","getSidesForTransformHandle","isResizeFromCenter","test","scale","max","nextFont","nextX1","nextY1","nextX2","nextY2","deltaX1","deltaY1","deltaX2","deltaY2","stateAtResizeStart","transformHandleDirection","startTopLeft","startBottomRight","startCenter","rotatedPointer","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","atStartBoundsWidth","atStartBoundsHeight","scaleX","scaleY","includes","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","heightRatio","ratio","sign","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledPoints","newOrigin","resizedElement","Number","isFinite","newSize","elements","getNextXY","origX1","origY1","finalX1","finalY1","origX2","origY2","finalX2","finalY2","updates","reduce","prev","font","origCoords","simultaneouslyUpdated","finalCoords","forEach","index","centerAngle","origAngle","rotatedCX","rotatedCY","getResizeOffsetXY","getResizeArrowDirection","px","py","isResizeEnd"],"mappings":"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","sourcesContent":["import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport { isLinearElement, isTextElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getCursorForResizingElement } from \"./resizeTest\";\nimport { measureText, getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { PointerDownState } from \"../components/App\";\nimport { Point } from \"../types\";\n\nconst normalizeAngle = (angle: number): number => {\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  isResizeCenterPoint: boolean,\n  shouldKeepSidesRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n      );\n      updateBoundElements(element);\n    } else if (\n      isLinearElement(element) &&\n      element.points.length === 2 &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      reshapeSingleTwoPointElement(\n        element,\n        resizeArrowDirection,\n        isRotateWithDiscreteAngle,\n        pointerX,\n        pointerY,\n      );\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements.get(element.id) as typeof element,\n        shouldKeepSidesRatio,\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    // update cursor\n    // FIXME it is not very nice to have this here\n    document.documentElement.style.cursor = getCursorForResizingElement({\n      element,\n      transformHandleType,\n    });\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        selectedElements,\n        transformHandleType,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n  if (isRotateWithDiscreteAngle) {\n    angle += SHIFT_LOCKING_ANGLE / 2;\n    angle -= angle % SHIFT_LOCKING_ANGLE;\n  }\n  angle = normalizeAngle(angle);\n  mutateElement(element, { angle });\n};\n\n// used in DEV only\nconst validateTwoPointElementNormalized = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  if (\n    element.points.length !== 2 ||\n    element.points[0][0] !== 0 ||\n    element.points[0][1] !== 0 ||\n    Math.abs(element.points[1][0]) !== element.width ||\n    Math.abs(element.points[1][1]) !== element.height\n  ) {\n    throw new Error(\"Two-point element is not normalized\");\n  }\n};\n\nconst getPerfectElementSizeWithRotation = (\n  elementType: string,\n  width: number,\n  height: number,\n  angle: number,\n): [number, number] => {\n  const size = getPerfectElementSize(\n    elementType,\n    ...rotate(width, height, 0, 0, angle),\n  );\n  return rotate(size.width, size.height, 0, 0, -angle);\n};\n\nconst reshapeSingleTwoPointElement = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTwoPointElementNormalized(element);\n  }\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let [width, height] =\n    resizeArrowDirection === \"end\"\n      ? [rotatedX - element.x, rotatedY - element.y]\n      : [\n          element.x + element.points[1][0] - rotatedX,\n          element.y + element.points[1][1] - rotatedY,\n        ];\n  if (isRotateWithDiscreteAngle) {\n    [width, height] = getPerfectElementSizeWithRotation(\n      element.type,\n      width,\n      height,\n      element.angle,\n    );\n  }\n  const [nextElementX, nextElementY] = adjustXYWithRotation(\n    resizeArrowDirection === \"end\"\n      ? { s: true, e: true }\n      : { n: true, w: true },\n    element.x,\n    element.y,\n    element.angle,\n    0,\n    0,\n    (element.points[1][0] - width) / 2,\n    (element.points[1][1] - height) / 2,\n  );\n  mutateElement(element, {\n    x: nextElementX,\n    y: nextElementY,\n    points: [\n      [0, 0],\n      [width, height],\n    ],\n  });\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n) =>\n  isLinearElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points),\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWH = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  const nextFontSize = element.fontSize * (nextWidth / element.width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  isResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const nextFont = measureFontSizeFromWH(element, nextWidth, nextHeight);\n    if (nextFont === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, isResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: nextFont.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextFont.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nconst resizeSingleElement = (\n  stateAtResizeStart: NonDeletedExcalidrawElement,\n  shouldKeepSidesRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  //Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n  );\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (isResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldKeepSidesRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  const [\n    newBoundsX1,\n    newBoundsY1,\n    newBoundsX2,\n    newBoundsY2,\n  ] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldKeepSidesRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (isResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  const rescaledPoints = rescalePointsInElement(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    ...rescaledPoints,\n  };\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n    mutateElement(element, resizedElement);\n  }\n};\n\nconst resizeMultipleElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements);\n  let scale: number;\n  let getNextXY: (\n    element: NonDeletedExcalidrawElement,\n    origCoords: readonly [number, number, number, number],\n    finalCoords: readonly [number, number, number, number],\n  ) => { x: number; y: number };\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, origY1], [finalX1, finalY1]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [, , origX2, origY2], [, , finalX2, finalY2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, , , origY2], [finalX1, , , finalY2]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [, origY1, origX2], [, finalY1, finalX2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n  }\n  if (scale > 0) {\n    const updates = elements.reduce(\n      (prev, element) => {\n        if (!prev) {\n          return prev;\n        }\n        const width = element.width * scale;\n        const height = element.height * scale;\n        let font: { fontSize?: number; baseline?: number } = {};\n        if (element.type === \"text\") {\n          const nextFont = measureFontSizeFromWH(element, width, height);\n          if (nextFont === null) {\n            return null;\n          }\n          font = { fontSize: nextFont.size, baseline: nextFont.baseline };\n        }\n        const origCoords = getElementAbsoluteCoords(element);\n        const rescaledPoints = rescalePointsInElement(element, width, height);\n        updateBoundElements(element, {\n          newSize: { width, height },\n          simultaneouslyUpdated: elements,\n        });\n        const finalCoords = getResizedElementAbsoluteCoords(\n          {\n            ...element,\n            ...rescaledPoints,\n          },\n          width,\n          height,\n        );\n        const { x, y } = getNextXY(element, origCoords, finalCoords);\n        return [...prev, { width, height, x, y, ...rescaledPoints, ...font }];\n      },\n      [] as\n        | {\n            width: number;\n            height: number;\n            x: number;\n            y: number;\n            points?: (readonly [number, number])[];\n            fontSize?: number;\n            baseline?: number;\n          }[]\n        | null,\n    );\n    if (updates) {\n      elements.forEach((element, index) => {\n        mutateElement(element, updates[index]);\n      });\n    }\n  }\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (isRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n  elements.forEach((element, index) => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle =\n      pointerDownState.originalElements.get(element.id)?.angle ?? element.angle;\n    const [rotatedCX, rotatedCY] = rotate(\n      cx,\n      cy,\n      centerX,\n      centerY,\n      centerAngle + origAngle - element.angle,\n    );\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle),\n    });\n  });\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n"]},"metadata":{},"sourceType":"module"}