{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/var/www/html/excalidraw/src/components/App.tsx\";\nimport { simplify } from \"points-on-curve\";\nimport React from \"react\";\nimport rough from \"roughjs/bin/rough\";\nimport \"../actions\";\nimport { actionDeleteSelected, actionFinalize } from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport { copyToClipboard, parseClipboard, probablySupportsClipboardBlob, probablySupportsClipboardWriteText } from \"../clipboard\";\nimport { APP_NAME, CANVAS_ONLY_ACTIONS, CURSOR_TYPE, DEFAULT_VERTICAL_ALIGN, DRAGGING_THRESHOLD, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, ENV, EVENT, GRID_SIZE, LINE_CONFIRM_THRESHOLD, MIME_TYPES, POINTER_BUTTON, TAP_TWICE_TIMEOUT, TEXT_TO_CENTER_SNAP_THRESHOLD, TOUCH_CTX_MENU_TIMEOUT } from \"../constants\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { restore } from \"../data/restore\";\nimport { dragNewElement, dragSelectedElements, duplicateElement, getCommonBounds, getCursorForResizingElement, getDragOffsetXY, getElementWithTransformHandleType, getNonDeletedElements, getNormalizedDimensions, getPerfectElementSize, getResizeArrowDirection, getResizeOffsetXY, getTransformHandleTypeFromCoords, hitTest, isHittingElementBoundingBoxWithoutHittingElement, isInvisiblySmallElement, isNonDeletedElement, isTextElement, newElement, newLinearElement, newTextElement, textWysiwyg, transformElements, updateTextElement } from \"../element\";\nimport { bindOrUnbindSelectedElements, fixBindingsAfterDeletion, fixBindingsAfterDuplication, getEligibleElementsForBinding, getHoveredElementForBinding, isBindingEnabled, isLinearElementSimpleAndAlreadyBound, maybeBindLinearElement, shouldEnableBindingForPointerEvent, unbindLinearElements, updateBoundElements } from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { deepCopyElement } from \"../element/newElement\";\nimport { isBindingElement, isBindingElementType, isLinearElement, isLinearElementType } from \"../element/typeChecks\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { editGroupForSelectedElement, getElementsInGroup, getSelectedGroupIdForElement, getSelectedGroupIds, isElementInGroup, isSelectedViaGroup, selectGroupsForSelectedElements } from \"../groups\";\nimport { createHistory } from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport { CODES, getResizeCenterPointKey, getResizeWithSidesSameLengthKey, getRotateWithDiscreteAngleKey, isArrowKey, KEYS } from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { calculateScrollCenter, getElementContainingPosition, getElementsAtPosition, getElementsWithinSelection, getNormalizedZoom, getSelectedElements, isOverScrollBars, isSomeElementSelected, normalizeScroll } from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport { debounce, distance, isInputLike, isToolIcon, isWritableElement, resetCursor, resolvablePromise, sceneCoordsToViewportCoords, setCursorForShape, tupleToCoors, viewportCoordsToSceneCoords, withBatchedUpdates } from \"../utils\";\nimport ContextMenu from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\nconst {\n  history\n} = createHistory();\nlet didTapTwice = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace = false;\nlet isPanning = false;\nlet isDraggingScrollBar = false;\nlet currentScrollBars = {\n  horizontal: null,\n  vertical: null\n};\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\nlet lastPointerUp = null;\nconst gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n    this.rc = null;\n    this.unmounted = false;\n    this.actionManager = void 0;\n    this.excalidrawContainerRef = /*#__PURE__*/React.createRef();\n    this.scene = void 0;\n\n    this.getSceneElementsIncludingDeleted = () => {\n      return this.scene.getElementsIncludingDeleted();\n    };\n\n    this.getSceneElements = () => {\n      return this.scene.getElements();\n    };\n\n    this.syncActionResult = withBatchedUpdates(actionResult => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement = null;\n\n      if (actionResult.elements) {\n        actionResult.elements.forEach(element => {\n          var _this$state$editingEl;\n\n          if (((_this$state$editingEl = this.state.editingElement) === null || _this$state$editingEl === void 0 ? void 0 : _this$state$editingEl.id) === element.id && this.state.editingElement !== element && isNonDeletedElement(element)) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n\n        this.setState(state => {\n          var _actionResult$appStat;\n\n          return { ...actionResult.appState,\n            editingElement: editingElement || ((_actionResult$appStat = actionResult.appState) === null || _actionResult$appStat === void 0 ? void 0 : _actionResult$appStat.editingElement) || null,\n            width: state.width,\n            height: state.height,\n            offsetTop: state.offsetTop,\n            offsetLeft: state.offsetLeft\n          };\n        }, () => {\n          if (actionResult.syncHistory) {\n            history.setCurrentState(this.state, this.scene.getElementsIncludingDeleted());\n          }\n        });\n      }\n    });\n    this.onBlur = withBatchedUpdates(() => {\n      isHoldingSpace = false;\n      this.setState({\n        isBindingEnabled: true\n      });\n    });\n\n    this.onUnload = () => {\n      this.onBlur();\n    };\n\n    this.disableEvent = event => {\n      event.preventDefault();\n    };\n\n    this.onFontLoaded = () => {\n      this.scene.getElementsIncludingDeleted().forEach(element => {\n        if (isTextElement(element)) {\n          invalidateShapeForElement(element);\n        }\n      });\n      this.onSceneUpdated();\n    };\n\n    this.importLibraryFromUrl = async url => {\n      window.history.replaceState({}, APP_NAME, window.location.origin);\n\n      try {\n        const request = await fetch(url);\n        const blob = await request.blob();\n        const json = JSON.parse(await blob.text());\n\n        if (!isValidLibrary(json)) {\n          throw new Error();\n        }\n\n        if (window.confirm(t(\"alerts.confirmAddLibrary\", {\n          numShapes: json.library.length\n        }))) {\n          await Library.importLibrary(blob);\n          this.setState({\n            isLibraryOpen: true\n          });\n        }\n      } catch (error) {\n        window.alert(t(\"alerts.errorLoadingLibrary\"));\n        console.error(error);\n      }\n    };\n\n    this.resetHistory = () => {\n      history.clear();\n    };\n\n    this.resetScene = withBatchedUpdates(opts => {\n      this.scene.replaceAllElements([]);\n      this.setState(state => ({ ...getDefaultAppState(),\n        isLoading: (opts === null || opts === void 0 ? void 0 : opts.resetLoadingState) ? false : state.isLoading,\n        appearance: this.state.appearance\n      }));\n      this.resetHistory();\n    });\n\n    this.initializeScene = async () => {\n      if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n        window.launchQueue.setConsumer(async launchParams => {\n          if (!launchParams.files.length) {\n            return;\n          }\n\n          const fileHandle = launchParams.files[0];\n          const blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(blob, this.state).then(({\n            elements,\n            appState\n          }) => this.syncActionResult({\n            elements,\n            appState: { ...(appState || this.state),\n              isLoading: false\n            },\n            commitToHistory: true\n          })).catch(error => {\n            this.setState({\n              isLoading: false,\n              errorMessage: error.message\n            });\n          });\n        });\n      }\n\n      if (!this.state.isLoading) {\n        this.setState({\n          isLoading: true\n        });\n      }\n\n      let initialData = null;\n\n      try {\n        initialData = (await this.props.initialData) || null;\n      } catch (error) {\n        console.error(error);\n      }\n\n      const scene = restore(initialData, null);\n      scene.appState = { ...scene.appState,\n        ...calculateScrollCenter(scene.elements, { ...scene.appState,\n          width: this.state.width,\n          height: this.state.height,\n          offsetTop: this.state.offsetTop,\n          offsetLeft: this.state.offsetLeft\n        }, null),\n        isLoading: false\n      };\n      this.resetHistory();\n      this.syncActionResult({ ...scene,\n        commitToHistory: true\n      });\n      const addToLibraryUrl = new URLSearchParams(window.location.search).get(\"addLibrary\");\n\n      if (addToLibraryUrl) {\n        await this.importLibraryFromUrl(addToLibraryUrl);\n      }\n    };\n\n    this.onResize = withBatchedUpdates(() => {\n      this.scene.getElementsIncludingDeleted().forEach(element => invalidateShapeForElement(element));\n      this.setState({});\n    });\n    this.onCut = withBatchedUpdates(event => {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      this.cutAll();\n      event.preventDefault();\n    });\n    this.onCopy = withBatchedUpdates(event => {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      this.copyAll();\n      event.preventDefault();\n    });\n\n    this.cutAll = () => {\n      this.copyAll();\n      this.actionManager.executeAction(actionDeleteSelected);\n    };\n\n    this.copyAll = () => {\n      copyToClipboard(this.scene.getElements(), this.state);\n    };\n\n    this.copyToClipboardAsPng = async () => {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n\n      try {\n        await exportCanvas(\"clipboard\", selectedElements.length ? selectedElements : elements, this.state, this.canvas, this.state);\n        this.setState({\n          toastMessage: t(\"toast.copyToClipboardAsPng\")\n        });\n      } catch (error) {\n        console.error(error);\n        this.setState({\n          errorMessage: error.message\n        });\n      }\n    };\n\n    this.copyToClipboardAsSvg = async () => {\n      const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n\n      try {\n        await exportCanvas(\"clipboard-svg\", selectedElements.length ? selectedElements : this.scene.getElements(), this.state, this.canvas, this.state);\n      } catch (error) {\n        console.error(error);\n        this.setState({\n          errorMessage: error.message\n        });\n      }\n    };\n\n    this.onTapStart = event => {\n      if (!didTapTwice) {\n        didTapTwice = true;\n        clearTimeout(tappedTwiceTimer);\n        tappedTwiceTimer = window.setTimeout(App.resetTapTwice, TAP_TWICE_TIMEOUT);\n        return;\n      } // insert text only if we tapped twice with a single finger\n      // event.touches.length === 1 will also prevent inserting text when user's zooming\n\n\n      if (didTapTwice && event.touches.length === 1) {\n        const [touch] = event.touches; // @ts-ignore\n\n        this.handleCanvasDoubleClick({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n        didTapTwice = false;\n        clearTimeout(tappedTwiceTimer);\n      }\n\n      event.preventDefault();\n\n      if (event.touches.length === 2) {\n        this.setState({\n          selectedElementIds: {}\n        });\n      }\n    };\n\n    this.onTapEnd = event => {\n      event.preventDefault();\n\n      if (event.touches.length > 0) {\n        this.setState({\n          previousSelectedElementIds: {},\n          selectedElementIds: this.state.previousSelectedElementIds\n        });\n      }\n    };\n\n    this.pasteFromClipboard = withBatchedUpdates(async event => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n\n      if ( // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n      // thus these checks don't make sense\n      event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {\n        return;\n      }\n\n      const data = await parseClipboard(event);\n\n      if (data.errorMessage) {\n        this.setState({\n          errorMessage: data.errorMessage\n        });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true\n          }\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n\n      this.selectShapeTool(\"selection\");\n      event === null || event === void 0 ? void 0 : event.preventDefault();\n    });\n\n    this.addElementsFromPasteOrLibrary = (clipboardElements, clientX = cursorX, clientY = cursorY) => {\n      const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n      const elementsCenterX = distance(minX, maxX) / 2;\n      const elementsCenterY = distance(minY, maxY) / 2;\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords({\n        clientX,\n        clientY\n      }, this.state);\n      const dx = x - elementsCenterX;\n      const dy = y - elementsCenterY;\n      const groupIdMap = new Map();\n      const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n      const oldIdToDuplicatedId = new Map();\n      const newElements = clipboardElements.map(element => {\n        const newElement = duplicateElement(this.state.editingGroupId, groupIdMap, element, {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY\n        });\n        oldIdToDuplicatedId.set(element.id, newElement.id);\n        return newElement;\n      });\n      const nextElements = [...this.scene.getElementsIncludingDeleted(), ...newElements];\n      fixBindingsAfterDuplication(nextElements, clipboardElements, oldIdToDuplicatedId);\n      this.scene.replaceAllElements(nextElements);\n      history.resumeRecording();\n      this.setState(selectGroupsForSelectedElements({ ...this.state,\n        isLibraryOpen: false,\n        selectedElementIds: newElements.reduce((map, element) => {\n          map[element.id] = true;\n          return map;\n        }, {}),\n        selectedGroupIds: {}\n      }, this.scene.getElements()));\n    };\n\n    this.setAppState = obj => {\n      this.setState(obj);\n    };\n\n    this.removePointer = event => {\n      // remove touch handler for context menu on touch devices\n      if (event.pointerType === \"touch\" && touchTimeout) {\n        clearTimeout(touchTimeout);\n        touchTimeout = 0;\n        invalidateContextMenu = false;\n      }\n\n      gesture.pointers.delete(event.pointerId);\n    };\n\n    this.toggleLock = () => {\n      this.setState(prevState => {\n        return {\n          elementLocked: !prevState.elementLocked,\n          elementType: prevState.elementLocked ? \"selection\" : prevState.elementType\n        };\n      });\n    };\n\n    this.toggleZenMode = () => {\n      this.setState({\n        zenModeEnabled: !this.state.zenModeEnabled\n      });\n    };\n\n    this.toggleGridMode = () => {\n      this.setState({\n        gridSize: this.state.gridSize ? null : GRID_SIZE\n      });\n    };\n\n    this.toggleStats = () => {\n      if (!this.state.showStats) {\n        trackEvent(\"dialog\", \"stats\");\n      }\n\n      this.setState({\n        showStats: !this.state.showStats\n      });\n    };\n\n    this.setScrollToCenter = remoteElements => {\n      this.setState({ ...calculateScrollCenter(getNonDeletedElements(remoteElements), this.state, this.canvas)\n      });\n    };\n\n    this.clearToast = () => {\n      this.setState({\n        toastMessage: null\n      });\n    };\n\n    this.updateScene = withBatchedUpdates(sceneData => {\n      var _sceneData$appState;\n\n      if (sceneData.commitToHistory) {\n        history.resumeRecording();\n      } // currently we only support syncing background color\n\n\n      if ((_sceneData$appState = sceneData.appState) === null || _sceneData$appState === void 0 ? void 0 : _sceneData$appState.viewBackgroundColor) {\n        this.setState({\n          viewBackgroundColor: sceneData.appState.viewBackgroundColor\n        });\n      }\n\n      if (sceneData.elements) {\n        this.scene.replaceAllElements(sceneData.elements);\n      }\n\n      if (sceneData.collaborators) {\n        this.setState({\n          collaborators: sceneData.collaborators\n        });\n      }\n    });\n\n    this.onSceneUpdated = () => {\n      this.setState({});\n    };\n\n    this.updateCurrentCursorPosition = withBatchedUpdates(event => {\n      cursorX = event.x;\n      cursorY = event.y;\n    });\n    this.onKeyDown = withBatchedUpdates(event => {\n      // normalize `event.key` when CapsLock is pressed #2372\n      if (\"Proxy\" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {\n        event = new Proxy(event, {\n          get(ev, prop) {\n            const value = ev[prop];\n\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n\n            return prop === \"key\" ? // CapsLock inverts capitalization based on ShiftKey, so invert\n            // it back\n            event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase() : value;\n          }\n\n        });\n      }\n\n      if (isWritableElement(event.target) && event.key !== KEYS.ESCAPE || // case: using arrows to move between buttons\n      isArrowKey(event.key) && isInputLike(event.target)) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          showShortcutsDialog: true\n        });\n      }\n\n      if (!event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z) {\n        this.toggleZenMode();\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE) {\n        this.toggleGridMode();\n      }\n\n      if (event[KEYS.CTRL_OR_CMD]) {\n        this.setState({\n          isBindingEnabled: false\n        });\n      }\n\n      if (event.code === CODES.C && event.altKey && event.shiftKey) {\n        this.copyToClipboardAsPng();\n        event.preventDefault();\n        return;\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      if (event.code === CODES.NINE) {\n        this.setState({\n          isLibraryOpen: !this.state.isLibraryOpen\n        });\n      }\n\n      if (isArrowKey(event.key)) {\n        const step = this.state.gridSize && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);\n        const selectedElements = this.scene.getElements().filter(element => this.state.selectedElementIds[element.id]);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n\n        selectedElements.forEach(element => {\n          mutateElement(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY\n          });\n          updateBoundElements(element, {\n            simultaneouslyUpdated: selectedElements\n          });\n        });\n        this.maybeSuggestBindingForAll(selectedElements);\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n\n        if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n          if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {\n            history.resumeRecording();\n            this.setState({\n              editingLinearElement: new LinearElementEditor(selectedElements[0], this.scene)\n            });\n          }\n        } else if (selectedElements.length === 1 && !isLinearElement(selectedElements[0])) {\n          const selectedElement = selectedElements[0];\n          this.startTextEditing({\n            sceneX: selectedElement.x + selectedElement.width / 2,\n            sceneY: selectedElement.y + selectedElement.height / 2\n          });\n          event.preventDefault();\n          return;\n        }\n      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && this.state.draggingElement === null) {\n        const shape = findShapeByKey(event.key);\n\n        if (shape) {\n          this.selectShapeTool(shape);\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock();\n        }\n      }\n\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      }\n    });\n    this.onKeyUp = withBatchedUpdates(event => {\n      if (event.key === KEYS.SPACE) {\n        if (this.state.elementType === \"selection\") {\n          resetCursor();\n        } else {\n          setCursorForShape(this.state.elementType);\n          this.setState({\n            selectedElementIds: {},\n            selectedGroupIds: {},\n            editingGroupId: null\n          });\n        }\n\n        isHoldingSpace = false;\n      }\n\n      if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n        this.setState({\n          isBindingEnabled: true\n        });\n      }\n\n      if (isArrowKey(event.key)) {\n        const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n        isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(selectedElements) : unbindLinearElements(selectedElements);\n        this.setState({\n          suggestedBindings: []\n        });\n      }\n    });\n    this.onGestureStart = withBatchedUpdates(event => {\n      event.preventDefault();\n      this.setState({\n        selectedElementIds: {}\n      });\n      gesture.initialScale = this.state.zoom.value;\n    });\n    this.onGestureChange = withBatchedUpdates(event => {\n      event.preventDefault(); // onGestureChange only has zoom factor but not the center.\n      // If we're on iPad or iPhone, then we recognize multi-touch and will\n      // zoom in at the right location on the touchMove handler already.\n      // On Macbook, we don't have those events so will zoom in at the\n      // current location instead.\n\n      if (gesture.pointers.size === 2) {\n        return;\n      }\n\n      const initialScale = gesture.initialScale;\n\n      if (initialScale) {\n        this.setState(({\n          zoom,\n          offsetLeft,\n          offsetTop\n        }) => ({\n          zoom: getNewZoom(getNormalizedZoom(initialScale * event.scale), zoom, {\n            left: offsetLeft,\n            top: offsetTop\n          }, {\n            x: cursorX,\n            y: cursorY\n          })\n        }));\n      }\n    });\n    this.onGestureEnd = withBatchedUpdates(event => {\n      event.preventDefault();\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds\n      });\n      gesture.initialScale = null;\n    });\n\n    this.startTextEditing = ({\n      sceneX,\n      sceneY,\n      insertAtParentCenter = true\n    }) => {\n      const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n      const parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(sceneX, sceneY, this.state, this.canvas, window.devicePixelRatio);\n      const element = existingTextElement ? existingTextElement : newTextElement({\n        x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,\n        y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemStrokeSharpness,\n        text: \"\",\n        fontSize: this.state.currentItemFontSize,\n        fontFamily: this.state.currentItemFontFamily,\n        textAlign: parentCenterPosition ? \"center\" : this.state.currentItemTextAlign,\n        verticalAlign: parentCenterPosition ? \"middle\" : DEFAULT_VERTICAL_ALIGN\n      });\n      this.setState({\n        editingElement: element\n      });\n\n      if (existingTextElement) {\n        // if text element is no longer centered to a container, reset\n        // verticalAlign to default because it's currently internal-only\n        if (!parentCenterPosition || element.textAlign !== \"center\") {\n          mutateElement(element, {\n            verticalAlign: DEFAULT_VERTICAL_ALIGN\n          });\n        }\n      } else {\n        this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), element]); // case: creating new text not centered to parent elemenent → offset Y\n        // so that the text is centered to cursor position\n\n        if (!parentCenterPosition) {\n          mutateElement(element, {\n            y: element.y - element.baseline / 2\n          });\n        }\n      }\n\n      this.setState({\n        editingElement: element\n      });\n      this.handleTextWysiwyg(element, {\n        isExistingElement: !!existingTextElement\n      });\n    };\n\n    this.handleCanvasDoubleClick = event => {\n      // case: double-clicking with arrow/line tool selected would both create\n      // text and enter multiElement mode\n      if (this.state.multiElement) {\n        return;\n      } // we should only be able to double click when mode is selection\n\n\n      if (this.state.elementType !== \"selection\") {\n        return;\n      }\n\n      const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n\n      if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n        if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {\n          history.resumeRecording();\n          this.setState({\n            editingLinearElement: new LinearElementEditor(selectedElements[0], this.scene)\n          });\n        }\n\n        return;\n      }\n\n      resetCursor();\n      const {\n        x: sceneX,\n        y: sceneY\n      } = viewportCoordsToSceneCoords(event, this.state);\n      const selectedGroupIds = getSelectedGroupIds(this.state);\n\n      if (selectedGroupIds.length > 0) {\n        const hitElement = this.getElementAtPosition(sceneX, sceneY);\n        const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n        if (selectedGroupId) {\n          this.setState(prevState => selectGroupsForSelectedElements({ ...prevState,\n            editingGroupId: selectedGroupId,\n            selectedElementIds: {\n              [hitElement.id]: true\n            },\n            selectedGroupIds: {}\n          }, this.scene.getElements()));\n          return;\n        }\n      }\n\n      resetCursor();\n\n      if (!event[KEYS.CTRL_OR_CMD]) {\n        this.startTextEditing({\n          sceneX,\n          sceneY,\n          insertAtParentCenter: !event.altKey\n        });\n      }\n    };\n\n    this.handleCanvasPointerMove = event => {\n      this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n      if (gesture.pointers.has(event.pointerId)) {\n        gesture.pointers.set(event.pointerId, {\n          x: event.clientX,\n          y: event.clientY\n        });\n      }\n\n      const initialScale = gesture.initialScale;\n\n      if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {\n        const center = getCenter(gesture.pointers);\n        const deltaX = center.x - gesture.lastCenter.x;\n        const deltaY = center.y - gesture.lastCenter.y;\n        gesture.lastCenter = center;\n        const distance = getDistance(Array.from(gesture.pointers.values()));\n        const scaleFactor = distance / gesture.initialDistance;\n        this.setState(({\n          zoom,\n          scrollX,\n          scrollY,\n          offsetLeft,\n          offsetTop\n        }) => ({\n          scrollX: normalizeScroll(scrollX + deltaX / zoom.value),\n          scrollY: normalizeScroll(scrollY + deltaY / zoom.value),\n          zoom: getNewZoom(getNormalizedZoom(initialScale * scaleFactor), zoom, {\n            left: offsetLeft,\n            top: offsetTop\n          }, center),\n          shouldCacheIgnoreZoom: true\n        }));\n        this.resetShouldCacheIgnoreZoomDebounced();\n      } else {\n        gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n      }\n\n      if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n        return;\n      }\n\n      const isPointerOverScrollBars = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n      const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n\n      if (!this.state.draggingElement && !this.state.multiElement) {\n        if (isOverScrollBar) {\n          resetCursor();\n        } else {\n          setCursorForShape(this.state.elementType);\n        }\n      }\n\n      const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n      const {\n        x: scenePointerX,\n        y: scenePointerY\n      } = scenePointer;\n\n      if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {\n        const editingLinearElement = LinearElementEditor.handlePointerMove(event, scenePointerX, scenePointerY, this.state.editingLinearElement, this.state.gridSize);\n\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement\n          });\n        }\n\n        if (editingLinearElement.lastUncommittedPoint != null) {\n          this.maybeSuggestBindingAtCursor(scenePointer);\n        } else {\n          this.setState({\n            suggestedBindings: []\n          });\n        }\n      }\n\n      if (isBindingElementType(this.state.elementType)) {\n        // Hovering with a selected tool or creating new linear element via click\n        // and point\n        const {\n          draggingElement\n        } = this.state;\n\n        if (isBindingElement(draggingElement)) {\n          this.maybeSuggestBindingForLinearElementAtCursor(draggingElement, \"end\", scenePointer, this.state.startBoundElement);\n        } else {\n          this.maybeSuggestBindingAtCursor(scenePointer);\n        }\n      }\n\n      if (this.state.multiElement) {\n        const {\n          multiElement\n        } = this.state;\n        const {\n          x: rx,\n          y: ry\n        } = multiElement;\n        const {\n          points,\n          lastCommittedPoint\n        } = multiElement;\n        const lastPoint = points[points.length - 1];\n        setCursorForShape(this.state.elementType);\n\n        if (lastPoint === lastCommittedPoint) {\n          // if we haven't yet created a temp point and we're beyond commit-zone\n          // threshold, add a point\n          if (distance2d(scenePointerX - rx, scenePointerY - ry, lastPoint[0], lastPoint[1]) >= LINE_CONFIRM_THRESHOLD) {\n            mutateElement(multiElement, {\n              points: [...points, [scenePointerX - rx, scenePointerY - ry]]\n            });\n          } else {\n            document.documentElement.style.cursor = CURSOR_TYPE.POINTER; // in this branch, we're inside the commit zone, and no uncommitted\n            // point exists. Thus do nothing (don't add/remove points).\n          }\n        } else if (points.length > 2 && lastCommittedPoint && distance2d(scenePointerX - rx, scenePointerY - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          mutateElement(multiElement, {\n            points: points.slice(0, -1)\n          });\n        } else {\n          if (isPathALoop(points)) {\n            document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          } // update last uncommitted point\n\n\n          mutateElement(multiElement, {\n            points: [...points.slice(0, -1), [scenePointerX - rx, scenePointerY - ry]]\n          });\n        }\n\n        return;\n      }\n\n      const hasDeselectedButton = Boolean(event.buttons);\n\n      if (hasDeselectedButton || this.state.elementType !== \"selection\" && this.state.elementType !== \"text\") {\n        return;\n      }\n\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n\n      if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(elements, this.state, scenePointerX, scenePointerY, this.state.zoom, event.pointerType);\n\n        if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {\n          document.documentElement.style.cursor = getCursorForResizingElement(elementWithTransformHandleType);\n          return;\n        }\n      } else if (selectedElements.length > 1 && !isOverScrollBar) {\n        const transformHandleType = getTransformHandleTypeFromCoords(getCommonBounds(selectedElements), scenePointerX, scenePointerY, this.state.zoom, event.pointerType);\n\n        if (transformHandleType) {\n          document.documentElement.style.cursor = getCursorForResizingElement({\n            transformHandleType\n          });\n          return;\n        }\n      }\n\n      const hitElement = this.getElementAtPosition(scenePointer.x, scenePointer.y);\n\n      if (this.state.elementType === \"text\") {\n        document.documentElement.style.cursor = isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR;\n      } else if (isOverScrollBar) {\n        document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n      } else if (hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(scenePointer, selectedElements)) {\n        document.documentElement.style.cursor = CURSOR_TYPE.MOVE;\n      } else {\n        document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n      }\n    };\n\n    this.handleTouchMove = event => {\n      invalidateContextMenu = true;\n    };\n\n    this.handleCanvasPointerDown = event => {\n      event.persist();\n      this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n      this.maybeCleanupAfterMissingPointerUp(event);\n\n      if (isPanning) {\n        return;\n      }\n\n      this.setState({\n        lastPointerDownWith: event.pointerType,\n        cursorButton: \"down\"\n      });\n      this.savePointer(event.clientX, event.clientY, \"down\");\n\n      if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n        return;\n      } // only handle left mouse button or touch\n\n\n      if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH) {\n        return;\n      }\n\n      this.updateGestureOnPointerDown(event); // fixes pointermove causing selection of UI texts #32\n\n      event.preventDefault(); // Preventing the event above disables default behavior\n      // of defocusing potentially focused element, which is what we\n      // want when clicking inside the canvas.\n\n      if (document.activeElement instanceof HTMLElement) {\n        document.activeElement.blur();\n      } // don't select while panning\n\n\n      if (gesture.pointers.size > 1) {\n        return;\n      } // State for the duration of a pointer interaction, which starts with a\n      // pointerDown event, ends with a pointerUp event (or another pointerDown)\n\n\n      const pointerDownState = this.initialPointerDownState(event);\n\n      if (this.handleDraggingScrollBar(event, pointerDownState)) {\n        return;\n      }\n\n      this.clearSelectionIfNotUsingSelection();\n      this.updateBindingEnabledOnPointerMove(event);\n\n      if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n        return;\n      }\n\n      if (this.state.elementType === \"text\") {\n        this.handleTextOnPointerDown(event, pointerDownState);\n        return;\n      } else if (this.state.elementType === \"arrow\" || this.state.elementType === \"draw\" || this.state.elementType === \"line\") {\n        this.handleLinearElementOnPointerDown(event, this.state.elementType, pointerDownState);\n      } else {\n        this.createGenericElementOnPointerDown(this.state.elementType, pointerDownState);\n      }\n\n      const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);\n      const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);\n      const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n      const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n      lastPointerUp = onPointerUp;\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    };\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices = event => {\n      // deal with opening context menu on touch devices\n      if (event.pointerType === \"touch\") {\n        invalidateContextMenu = false;\n\n        if (touchTimeout) {\n          // If there's already a touchTimeout, this means that there's another\n          // touch down and we are doing another touch, so we shouldn't open the\n          // context menu.\n          invalidateContextMenu = true;\n        } else {\n          // open the context menu with the first touch's clientX and clientY\n          // if the touch is not moving\n          touchTimeout = window.setTimeout(() => {\n            touchTimeout = 0;\n\n            if (!invalidateContextMenu) {\n              this.openContextMenu({\n                clientX: event.clientX,\n                clientY: event.clientY\n              });\n            }\n          }, TOUCH_CTX_MENU_TIMEOUT);\n        }\n      }\n    };\n\n    this.handleCanvasPanUsingWheelOrSpaceDrag = event => {\n      if (!(gesture.pointers.size === 0 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace))) {\n        return false;\n      }\n\n      isPanning = true;\n      let nextPastePrevented = false;\n      const isLinux = /Linux/.test(window.navigator.platform);\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      let {\n        clientX: lastX,\n        clientY: lastY\n      } = event;\n      const onPointerMove = withBatchedUpdates(event => {\n        const deltaX = lastX - event.clientX;\n        const deltaY = lastY - event.clientY;\n        lastX = event.clientX;\n        lastY = event.clientY;\n        /*\n         * Prevent paste event if we move while middle clicking on Linux.\n         * See issue #1383.\n         */\n\n        if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {\n          nextPastePrevented = true;\n          /* Prevent the next paste event */\n\n          const preventNextPaste = event => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            event.stopPropagation();\n          };\n          /*\n           * Reenable next paste in case of disabled middle click paste for\n           * any reason:\n           * - rigth click paste\n           * - empty clipboard\n           */\n\n\n          const enableNextPaste = () => {\n            setTimeout(() => {\n              document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n              window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n            }, 100);\n          };\n\n          document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n          window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n        }\n\n        this.setState({\n          scrollX: normalizeScroll(this.state.scrollX - deltaX / this.state.zoom.value),\n          scrollY: normalizeScroll(this.state.scrollY - deltaY / this.state.zoom.value)\n        });\n      });\n      const teardown = withBatchedUpdates(lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n\n        if (!isHoldingSpace) {\n          setCursorForShape(this.state.elementType);\n        }\n\n        this.setState({\n          cursorButton: \"up\"\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      });\n      window.addEventListener(EVENT.BLUR, teardown);\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n        passive: true\n      });\n      window.addEventListener(EVENT.POINTER_UP, teardown);\n      return true;\n    };\n\n    this.clearSelectionIfNotUsingSelection = () => {\n      if (this.state.elementType !== \"selection\") {\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null\n        });\n      }\n    };\n\n    this.handleSelectionOnPointerDown = (event, pointerDownState) => {\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        const selectedElements = getSelectedElements(elements, this.state);\n\n        if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n          const elementWithTransformHandleType = getElementWithTransformHandleType(elements, this.state, pointerDownState.origin.x, pointerDownState.origin.y, this.state.zoom, event.pointerType);\n\n          if (elementWithTransformHandleType != null) {\n            this.setState({\n              resizingElement: elementWithTransformHandleType.element\n            });\n            pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;\n          }\n        } else if (selectedElements.length > 1) {\n          pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(getCommonBounds(selectedElements), pointerDownState.origin.x, pointerDownState.origin.y, this.state.zoom, event.pointerType);\n        }\n\n        if (pointerDownState.resize.handleType) {\n          document.documentElement.style.cursor = getCursorForResizingElement({\n            transformHandleType: pointerDownState.resize.handleType\n          });\n          pointerDownState.resize.isResizing = true;\n          pointerDownState.resize.offset = tupleToCoors(getResizeOffsetXY(pointerDownState.resize.handleType, selectedElements, pointerDownState.origin.x, pointerDownState.origin.y));\n\n          if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {\n            pointerDownState.resize.arrowDirection = getResizeArrowDirection(pointerDownState.resize.handleType, selectedElements[0]);\n          }\n        } else {\n          var _pointerDownState$hit;\n\n          if (this.state.editingLinearElement) {\n            const ret = LinearElementEditor.handlePointerDown(event, this.state, appState => this.setState(appState), history, pointerDownState.origin);\n\n            if (ret.hitElement) {\n              pointerDownState.hit.element = ret.hitElement;\n            }\n\n            if (ret.didAddPoint) {\n              return true;\n            }\n          } // hitElement may already be set above, so check first\n\n\n          pointerDownState.hit.element = (_pointerDownState$hit = pointerDownState.hit.element) !== null && _pointerDownState$hit !== void 0 ? _pointerDownState$hit : this.getElementAtPosition(pointerDownState.origin.x, pointerDownState.origin.y); // For overlapped elements one position may hit\n          // multiple elements\n\n          pointerDownState.hit.allHitElements = this.getElementsAtPosition(pointerDownState.origin.x, pointerDownState.origin.y);\n          const hitElement = pointerDownState.hit.element;\n          const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(element => this.isASelectedElement(element));\n\n          if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {\n            this.clearSelection(hitElement);\n          } // If we click on something\n\n\n          if (hitElement != null) {\n            // on CMD/CTRL, drill down to hit element regardless of groups etc.\n            if (event[KEYS.CTRL_OR_CMD]) {\n              this.setState(prevState => ({ ...editGroupForSelectedElement(prevState, hitElement),\n                previousSelectedElementIds: this.state.selectedElementIds\n              })); // mark as not completely handled so as to allow dragging etc.\n\n              return false;\n            } // deselect if item is selected\n            // if shift is not clicked, this will always return true\n            // otherwise, it will trigger selection based on current\n            // state of the box\n\n\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              // if we are currently editing a group, exiting editing mode and deselect the group.\n              if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {\n                this.setState({\n                  selectedElementIds: {},\n                  selectedGroupIds: {},\n                  editingGroupId: null\n                });\n              } // Add hit element to selection. At this point if we're not holding\n              // SHIFT the previously selected element(s) were deselected above\n              // (make sure you use setState updater to use latest state)\n\n\n              if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {\n                this.setState(prevState => {\n                  return selectGroupsForSelectedElements({ ...prevState,\n                    selectedElementIds: { ...prevState.selectedElementIds,\n                      [hitElement.id]: true\n                    }\n                  }, this.scene.getElements());\n                });\n                pointerDownState.hit.wasAddedToSelection = true;\n              }\n            }\n          }\n\n          this.setState({\n            previousSelectedElementIds: this.state.selectedElementIds\n          });\n        }\n      }\n\n      return false;\n    };\n\n    this.handleTextOnPointerDown = (event, pointerDownState) => {\n      var _this$state$editingEl2;\n\n      // if we're currently still editing text, clicking outside\n      // should only finalize it, not create another (irrespective\n      // of state.elementLocked)\n      if (((_this$state$editingEl2 = this.state.editingElement) === null || _this$state$editingEl2 === void 0 ? void 0 : _this$state$editingEl2.type) === \"text\") {\n        return;\n      }\n\n      this.startTextEditing({\n        sceneX: pointerDownState.origin.x,\n        sceneY: pointerDownState.origin.y,\n        insertAtParentCenter: !event.altKey\n      });\n      resetCursor();\n\n      if (!this.state.elementLocked) {\n        this.setState({\n          elementType: \"selection\"\n        });\n      }\n    };\n\n    this.handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {\n      if (this.state.multiElement) {\n        const {\n          multiElement\n        } = this.state; // finalize if completing a loop\n\n        if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n          mutateElement(multiElement, {\n            lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n          });\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n\n        const {\n          x: rx,\n          y: ry,\n          lastCommittedPoint\n        } = multiElement; // clicking inside commit zone → finalize arrow\n\n        if (multiElement.points.length > 1 && lastCommittedPoint && distance2d(pointerDownState.origin.x - rx, pointerDownState.origin.y - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n\n        this.setState(prevState => ({\n          selectedElementIds: { ...prevState.selectedElementIds,\n            [multiElement.id]: true\n          }\n        })); // clicking outside commit zone → update reference for last committed\n        // point\n\n        mutateElement(multiElement, {\n          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n        });\n        document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n      } else {\n        const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, elementType === \"draw\" ? null : this.state.gridSize);\n        /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n        If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n        an arrow, we want it to be null for both. Otherwise, we want it to use the\n        values from appState. */\n\n        const {\n          currentItemStartArrowhead,\n          currentItemEndArrowhead\n        } = this.state;\n        const [startArrowhead, endArrowhead] = elementType === \"arrow\" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];\n        const element = newLinearElement({\n          type: elementType,\n          x: gridX,\n          y: gridY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n          startArrowhead,\n          endArrowhead\n        });\n        this.setState(prevState => ({\n          selectedElementIds: { ...prevState.selectedElementIds,\n            [element.id]: false\n          }\n        }));\n        mutateElement(element, {\n          points: [...element.points, [0, 0]]\n        });\n        const boundElement = getHoveredElementForBinding(pointerDownState.origin, this.scene);\n        this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), element]);\n        this.setState({\n          draggingElement: element,\n          editingElement: element,\n          startBoundElement: boundElement,\n          suggestedBindings: []\n        });\n      }\n    };\n\n    this.createGenericElementOnPointerDown = (elementType, pointerDownState) => {\n      const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, this.state.gridSize);\n      const element = newElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemStrokeSharpness\n      });\n\n      if (element.type === \"selection\") {\n        this.setState({\n          selectionElement: element,\n          draggingElement: element\n        });\n      } else {\n        this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), element]);\n        this.setState({\n          multiElement: null,\n          draggingElement: element,\n          editingElement: element\n        });\n      }\n    };\n\n    this.updateBindingEnabledOnPointerMove = event => {\n      const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n\n      if (this.state.isBindingEnabled !== shouldEnableBinding) {\n        this.setState({\n          isBindingEnabled: shouldEnableBinding\n        });\n      }\n    };\n\n    this.maybeSuggestBindingAtCursor = pointerCoords => {\n      const hoveredBindableElement = getHoveredElementForBinding(pointerCoords, this.scene);\n      this.setState({\n        suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []\n      });\n    };\n\n    this.maybeSuggestBindingForLinearElementAtCursor = (linearElement, startOrEnd, pointerCoords, oppositeBindingBoundElement) => {\n      const hoveredBindableElement = getHoveredElementForBinding(pointerCoords, this.scene);\n      this.setState({\n        suggestedBindings: hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(linearElement, oppositeBindingBoundElement === null || oppositeBindingBoundElement === void 0 ? void 0 : oppositeBindingBoundElement.id, hoveredBindableElement) ? [hoveredBindableElement] : []\n      });\n    };\n\n    this.handleCanvasRef = canvas => {\n      // canvas is null when unmounting\n      if (canvas !== null) {\n        this.canvas = canvas;\n        this.rc = rough.canvas(this.canvas);\n        this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n          passive: false\n        });\n        this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n        this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n      } else {\n        var _this$canvas, _this$canvas2, _this$canvas3;\n\n        (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.removeEventListener(EVENT.WHEEL, this.handleWheel);\n        (_this$canvas2 = this.canvas) === null || _this$canvas2 === void 0 ? void 0 : _this$canvas2.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n        (_this$canvas3 = this.canvas) === null || _this$canvas3 === void 0 ? void 0 : _this$canvas3.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n      }\n    };\n\n    this.handleCanvasOnDrop = async (event) => {\n      var _event$dataTransfer;\n\n      try {\n        const file = event.dataTransfer.files[0];\n\n        if ((file === null || file === void 0 ? void 0 : file.type) === \"image/png\" || (file === null || file === void 0 ? void 0 : file.type) === \"image/svg+xml\") {\n          const {\n            elements,\n            appState\n          } = await loadFromBlob(file, this.state);\n          this.syncActionResult({\n            elements,\n            appState: { ...(appState || this.state),\n              isLoading: false\n            },\n            commitToHistory: true\n          });\n          return;\n        }\n      } catch (error) {\n        return this.setState({\n          isLoading: false,\n          errorMessage: error.message\n        });\n      }\n\n      const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n\n      if (libraryShapes !== \"\") {\n        this.addElementsFromPasteOrLibrary(JSON.parse(libraryShapes), event.clientX, event.clientY);\n        return;\n      }\n\n      const file = (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.files[0];\n\n      if ((file === null || file === void 0 ? void 0 : file.type) === \"application/json\" || (file === null || file === void 0 ? void 0 : file.name.endsWith(\".excalidraw\"))) {\n        this.setState({\n          isLoading: true\n        });\n\n        if (\"chooseFileSystemEntries\" in window || \"showOpenFilePicker\" in window) {\n          try {\n            // This will only work as of Chrome 86,\n            // but can be safely ignored on older releases.\n            const item = event.dataTransfer.items[0]; // TODO: Make this part of `AppState`.\n\n            file.handle = await item.getAsFileSystemHandle();\n          } catch (error) {\n            console.warn(error.name, error.message);\n          }\n        }\n\n        loadFromBlob(file, this.state).then(({\n          elements,\n          appState\n        }) => this.syncActionResult({\n          elements,\n          appState: { ...(appState || this.state),\n            isLoading: false\n          },\n          commitToHistory: true\n        })).catch(error => {\n          this.setState({\n            isLoading: false,\n            errorMessage: error.message\n          });\n        });\n      } else if ((file === null || file === void 0 ? void 0 : file.type) === MIME_TYPES.excalidrawlib || (file === null || file === void 0 ? void 0 : file.name.endsWith(\".excalidrawlib\"))) {\n        Library.importLibrary(file).then(() => {\n          this.setState({\n            isLibraryOpen: false\n          });\n        }).catch(error => this.setState({\n          isLoading: false,\n          errorMessage: error.message\n        }));\n      } else {\n        this.setState({\n          isLoading: false,\n          errorMessage: t(\"alerts.couldNotLoadInvalidFile\")\n        });\n      }\n    };\n\n    this.handleCanvasContextMenu = event => {\n      event.preventDefault();\n      this.openContextMenu(event);\n    };\n\n    this.maybeDragNewGenericElement = (pointerDownState, event) => {\n      const draggingElement = this.state.draggingElement;\n      const pointerCoords = pointerDownState.lastCoords;\n\n      if (!draggingElement) {\n        return;\n      }\n\n      if (draggingElement.type === \"selection\") {\n        dragNewElement(draggingElement, this.state.elementType, pointerDownState.origin.x, pointerDownState.origin.y, pointerCoords.x, pointerCoords.y, distance(pointerDownState.origin.x, pointerCoords.x), distance(pointerDownState.origin.y, pointerCoords.y), getResizeWithSidesSameLengthKey(event), getResizeCenterPointKey(event));\n      } else {\n        const [gridX, gridY] = getGridPoint(pointerCoords.x, pointerCoords.y, this.state.gridSize);\n        dragNewElement(draggingElement, this.state.elementType, pointerDownState.originInGrid.x, pointerDownState.originInGrid.y, gridX, gridY, distance(pointerDownState.originInGrid.x, gridX), distance(pointerDownState.originInGrid.y, gridY), getResizeWithSidesSameLengthKey(event), getResizeCenterPointKey(event));\n        this.maybeSuggestBindingForAll([draggingElement]);\n      }\n    };\n\n    this.maybeHandleResize = (pointerDownState, event) => {\n      const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n      const transformHandleType = pointerDownState.resize.handleType;\n      this.setState({\n        // TODO: rename this state field to \"isScaling\" to distinguish\n        // it from the generic \"isResizing\" which includes scaling and\n        // rotating\n        isResizing: transformHandleType && transformHandleType !== \"rotation\",\n        isRotating: transformHandleType === \"rotation\"\n      });\n      const pointerCoords = pointerDownState.lastCoords;\n      const [resizeX, resizeY] = getGridPoint(pointerCoords.x - pointerDownState.resize.offset.x, pointerCoords.y - pointerDownState.resize.offset.y, this.state.gridSize);\n\n      if (transformElements(pointerDownState, transformHandleType, selectedElements, pointerDownState.resize.arrowDirection, getRotateWithDiscreteAngleKey(event), getResizeCenterPointKey(event), getResizeWithSidesSameLengthKey(event), resizeX, resizeY, pointerDownState.resize.center.x, pointerDownState.resize.center.y)) {\n        this.maybeSuggestBindingForAll(selectedElements);\n        return true;\n      }\n\n      return false;\n    };\n\n    this.openContextMenu = ({\n      clientX,\n      clientY\n    }) => {\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords({\n        clientX,\n        clientY\n      }, this.state);\n      const elements = this.scene.getElements();\n      const element = this.getElementAtPosition(x, y);\n\n      if (!element) {\n        ContextMenu.push({\n          options: [navigator.clipboard && {\n            shortcutName: \"paste\",\n            label: t(\"labels.paste\"),\n            action: () => this.pasteFromClipboard(null)\n          }, probablySupportsClipboardBlob && elements.length > 0 && {\n            shortcutName: \"copyAsPng\",\n            label: t(\"labels.copyAsPng\"),\n            action: this.copyToClipboardAsPng\n          }, probablySupportsClipboardWriteText && elements.length > 0 && {\n            shortcutName: \"copyAsSvg\",\n            label: t(\"labels.copyAsSvg\"),\n            action: this.copyToClipboardAsSvg\n          }, ...this.actionManager.getContextMenuItems(action => CANVAS_ONLY_ACTIONS.includes(action.name)), {\n            checked: this.state.gridSize !== null,\n            shortcutName: \"gridMode\",\n            label: t(\"labels.gridMode\"),\n            action: this.toggleGridMode\n          }, {\n            checked: this.state.zenModeEnabled,\n            shortcutName: \"zenMode\",\n            label: t(\"buttons.zenMode\"),\n            action: this.toggleZenMode\n          }, {\n            checked: this.state.showStats,\n            shortcutName: \"stats\",\n            label: t(\"stats.title\"),\n            action: this.toggleStats\n          }],\n          top: clientY,\n          left: clientX\n        });\n        return;\n      }\n\n      if (!this.state.selectedElementIds[element.id]) {\n        this.setState({\n          selectedElementIds: {\n            [element.id]: true\n          }\n        });\n      }\n\n      ContextMenu.push({\n        options: [{\n          shortcutName: \"cut\",\n          label: t(\"labels.cut\"),\n          action: this.cutAll\n        }, navigator.clipboard && {\n          shortcutName: \"copy\",\n          label: t(\"labels.copy\"),\n          action: this.copyAll\n        }, navigator.clipboard && {\n          shortcutName: \"paste\",\n          label: t(\"labels.paste\"),\n          action: () => this.pasteFromClipboard(null)\n        }, probablySupportsClipboardBlob && {\n          shortcutName: \"copyAsPng\",\n          label: t(\"labels.copyAsPng\"),\n          action: this.copyToClipboardAsPng\n        }, probablySupportsClipboardWriteText && {\n          shortcutName: \"copyAsSvg\",\n          label: t(\"labels.copyAsSvg\"),\n          action: this.copyToClipboardAsSvg\n        }, ...this.actionManager.getContextMenuItems(action => !CANVAS_ONLY_ACTIONS.includes(action.name))],\n        top: clientY,\n        left: clientX\n      });\n    };\n\n    this.handleWheel = withBatchedUpdates(event => {\n      event.preventDefault();\n\n      if (isPanning) {\n        return;\n      }\n\n      const {\n        deltaX,\n        deltaY\n      } = event;\n      const {\n        selectedElementIds,\n        previousSelectedElementIds\n      } = this.state; // note that event.ctrlKey is necessary to handle pinch zooming\n\n      if (event.metaKey || event.ctrlKey) {\n        const sign = Math.sign(deltaY);\n        const MAX_STEP = 10;\n        let delta = Math.abs(deltaY);\n\n        if (delta > MAX_STEP) {\n          delta = MAX_STEP;\n        }\n\n        delta *= sign;\n\n        if (Object.keys(previousSelectedElementIds).length !== 0) {\n          setTimeout(() => {\n            this.setState({\n              selectedElementIds: previousSelectedElementIds,\n              previousSelectedElementIds: {}\n            });\n          }, 1000);\n        }\n\n        this.setState(({\n          zoom,\n          offsetLeft,\n          offsetTop\n        }) => ({\n          zoom: getNewZoom(getNormalizedZoom(zoom.value - delta / 100), zoom, {\n            left: offsetLeft,\n            top: offsetTop\n          }, {\n            x: cursorX,\n            y: cursorY\n          }),\n          selectedElementIds: {},\n          previousSelectedElementIds: Object.keys(selectedElementIds).length !== 0 ? selectedElementIds : previousSelectedElementIds,\n          shouldCacheIgnoreZoom: true\n        }));\n        this.resetShouldCacheIgnoreZoomDebounced();\n        return;\n      } // scroll horizontally when shift pressed\n\n\n      if (event.shiftKey) {\n        this.setState(({\n          zoom,\n          scrollX\n        }) => ({\n          // on Mac, shift+wheel tends to result in deltaX\n          scrollX: normalizeScroll(scrollX - (deltaY || deltaX) / zoom.value)\n        }));\n        return;\n      }\n\n      this.setState(({\n        zoom,\n        scrollX,\n        scrollY\n      }) => ({\n        scrollX: normalizeScroll(scrollX - deltaX / zoom.value),\n        scrollY: normalizeScroll(scrollY - deltaY / zoom.value)\n      }));\n    });\n\n    this.savePointer = (x, y, button) => {\n      var _this$props$onPointer, _this$props;\n\n      if (!x || !y) {\n        return;\n      }\n\n      const pointer = viewportCoordsToSceneCoords({\n        clientX: x,\n        clientY: y\n      }, this.state);\n\n      if (isNaN(pointer.x) || isNaN(pointer.y)) {// sometimes the pointer goes off screen\n      }\n\n      (_this$props$onPointer = (_this$props = this.props).onPointerUpdate) === null || _this$props$onPointer === void 0 ? void 0 : _this$props$onPointer.call(_this$props, {\n        pointer,\n        button,\n        pointersMap: gesture.pointers\n      });\n    };\n\n    this.resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n      if (!this.unmounted) {\n        this.setState({\n          shouldCacheIgnoreZoom: false\n        });\n      }\n    }, 300);\n    const defaultAppState = getDefaultAppState();\n    const {\n      width = window.innerWidth,\n      height = window.innerHeight,\n      offsetLeft: _offsetLeft,\n      offsetTop: _offsetTop,\n      excalidrawRef\n    } = props;\n    this.state = { ...defaultAppState,\n      isLoading: true,\n      width,\n      height,\n      ...this.getCanvasOffsets({\n        offsetLeft: _offsetLeft,\n        offsetTop: _offsetTop\n      })\n    };\n\n    if (excalidrawRef) {\n      var _excalidrawRef$curren;\n\n      const readyPromise = \"current\" in excalidrawRef && ((_excalidrawRef$curren = excalidrawRef.current) === null || _excalidrawRef$curren === void 0 ? void 0 : _excalidrawRef$curren.readyPromise) || resolvablePromise();\n      const api = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory\n        },\n        setScrollToCenter: this.setScrollToCenter,\n        getSceneElements: this.getSceneElements\n      };\n\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n\n      readyPromise.resolve(api);\n    }\n\n    this.scene = new Scene();\n    this.actionManager = new ActionManager(this.syncActionResult, () => this.state, () => this.scene.getElementsIncludingDeleted());\n    this.actionManager.registerAll(actions);\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  render() {\n    const {\n      zenModeEnabled,\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      offsetTop,\n      offsetLeft\n    } = this.state;\n    const {\n      onCollabButtonClick,\n      onExportToBackend,\n      renderFooter\n    } = this.props;\n    const canvasScale = window.devicePixelRatio;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    const DEFAULT_PASTE_X = canvasDOMWidth / 2;\n    const DEFAULT_PASTE_Y = canvasDOMHeight / 2;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"excalidraw\",\n      ref: this.excalidrawContainerRef,\n      style: {\n        width: canvasDOMWidth,\n        height: canvasDOMHeight,\n        top: offsetTop,\n        left: offsetLeft\n      },\n      children: [/*#__PURE__*/_jsxDEV(LayerUI, {\n        canvas: this.canvas,\n        appState: this.state,\n        setAppState: this.setAppState,\n        actionManager: this.actionManager,\n        elements: this.scene.getElements(),\n        onCollabButtonClick: onCollabButtonClick,\n        onLockToggle: this.toggleLock,\n        onInsertElements: elements => this.addElementsFromPasteOrLibrary(elements, DEFAULT_PASTE_X, DEFAULT_PASTE_Y),\n        zenModeEnabled: zenModeEnabled,\n        toggleZenMode: this.toggleZenMode,\n        langCode: getLanguage().code,\n        isCollaborating: this.props.isCollaborating || false,\n        onExportToBackend: onExportToBackend,\n        renderCustomFooter: renderFooter\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 9\n      }, this), this.state.showStats && /*#__PURE__*/_jsxDEV(Stats, {\n        appState: this.state,\n        elements: this.scene.getElements(),\n        onClose: this.toggleStats\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 374,\n        columnNumber: 11\n      }, this), this.state.toastMessage !== null && /*#__PURE__*/_jsxDEV(Toast, {\n        message: this.state.toastMessage,\n        clearToast: this.clearToast\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n        children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n          id: \"canvas\",\n          style: {\n            width: canvasDOMWidth,\n            height: canvasDOMHeight\n          },\n          width: canvasWidth,\n          height: canvasHeight,\n          ref: this.handleCanvasRef,\n          onContextMenu: this.handleCanvasContextMenu,\n          onPointerDown: this.handleCanvasPointerDown,\n          onDoubleClick: this.handleCanvasDoubleClick,\n          onPointerMove: this.handleCanvasPointerMove,\n          onPointerUp: this.removePointer,\n          onPointerCancel: this.removePointer,\n          onTouchMove: this.handleTouchMove,\n          onDrop: this.handleCanvasOnDrop,\n          children: t(\"labels.drawingCanvas\")\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 387,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 341,\n      columnNumber: 7\n    }, this);\n  }\n\n  async componentDidMount() {\n    if (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          }\n        },\n        setState: {\n          configurable: true,\n          value: (...args) => {\n            return this.setState(...args);\n          }\n        },\n        app: {\n          configurable: true,\n          value: this\n        }\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners(); // optim to avoid extra render on init\n\n    if (typeof this.props.offsetLeft === \"number\" && typeof this.props.offsetTop === \"number\") {\n      this.initializeScene();\n    } else {\n      this.setState(this.getCanvasOffsets(this.props), () => {\n        this.initializeScene();\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  removeEventListeners() {\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(EVENT.MOUSE_MOVE, this.updateCurrentCursorPosition, false);\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n    document.removeEventListener(EVENT.GESTURE_START, this.onGestureStart, false);\n    document.removeEventListener(EVENT.GESTURE_CHANGE, this.onGestureChange, false);\n    document.removeEventListener(EVENT.GESTURE_END, this.onGestureEnd, false);\n  }\n\n  addEventListeners() {\n    var _document$fonts, _document$fonts$addEv;\n\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n    document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, {\n      passive: true\n    });\n    document.addEventListener(EVENT.MOUSE_MOVE, this.updateCurrentCursorPosition);\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false); // rerender text elements on font load to fix #637 && #1553\n\n    (_document$fonts = document.fonts) === null || _document$fonts === void 0 ? void 0 : (_document$fonts$addEv = _document$fonts.addEventListener) === null || _document$fonts$addEv === void 0 ? void 0 : _document$fonts$addEv.call(_document$fonts, \"loadingdone\", this.onFontLoaded); // Safari-only desktop pinch zoom\n\n    document.addEventListener(EVENT.GESTURE_START, this.onGestureStart, false);\n    document.addEventListener(EVENT.GESTURE_CHANGE, this.onGestureChange, false);\n    document.addEventListener(EVENT.GESTURE_END, this.onGestureEnd, false);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    var _document$querySelect, _this$state$editingEl3;\n\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (prevProps.width !== this.props.width || prevProps.height !== this.props.height || typeof this.props.offsetLeft === \"number\" && prevProps.offsetLeft !== this.props.offsetLeft || typeof this.props.offsetTop === \"number\" && prevProps.offsetTop !== this.props.offsetTop) {\n      var _this$props$width, _this$props$height;\n\n      this.setState({\n        width: (_this$props$width = this.props.width) !== null && _this$props$width !== void 0 ? _this$props$width : window.innerWidth,\n        height: (_this$props$height = this.props.height) !== null && _this$props$height !== void 0 ? _this$props$height : window.innerHeight,\n        ...this.getCanvasOffsets(this.props)\n      });\n    }\n\n    (_document$querySelect = document.querySelector(\".excalidraw\")) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.classList.toggle(\"Appearance_dark\", this.state.appearance === \"dark\");\n\n    if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n\n    const {\n      multiElement\n    } = prevState;\n\n    if (prevState.elementType !== this.state.elementType && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement)) {\n      maybeBindLinearElement(multiElement, this.state, this.scene, tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(multiElement, -1)));\n    }\n\n    const cursorButton = {};\n    const pointerViewportCoords = {};\n    const remoteSelectedElementIds = {};\n    const pointerUsernames = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n\n      if (!user.pointer) {\n        return;\n      }\n\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords({\n        sceneX: user.pointer.x,\n        sceneY: user.pointer.y\n      }, this.state);\n      cursorButton[socketId] = user.button;\n    });\n    const elements = this.scene.getElements();\n    const {\n      atLeastOneVisibleElement,\n      scrollBars\n    } = renderScene(elements.filter(element => {\n      // don't render text element that's being currently edited (it's\n      // rendered on remote only)\n      return !this.state.editingElement || this.state.editingElement.type !== \"text\" || element.id !== this.state.editingElement.id;\n    }), this.state, this.state.selectionElement, window.devicePixelRatio, this.rc, this.canvas, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor,\n      zoom: this.state.zoom,\n      remotePointerViewportCoords: pointerViewportCoords,\n      remotePointerButton: cursorButton,\n      remoteSelectedElementIds,\n      remotePointerUsernames: pointerUsernames,\n      shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom\n    }, {\n      renderOptimizations: true\n    });\n\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n\n    const scrolledOutside = // hide when editing text\n    ((_this$state$editingEl3 = this.state.editingElement) === null || _this$state$editingEl3 === void 0 ? void 0 : _this$state$editingEl3.type) === \"text\" ? false : !atLeastOneVisibleElement && elements.length > 0;\n\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({\n        scrolledOutside\n      });\n    }\n\n    history.record(this.state, this.scene.getElementsIncludingDeleted()); // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n\n    if (!this.state.isLoading) {\n      var _this$props$onChange, _this$props2;\n\n      (_this$props$onChange = (_this$props2 = this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props2, this.scene.getElementsIncludingDeleted(), this.state);\n    }\n  } // Copy/paste\n\n\n  static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  addTextFromPaste(text) {\n    const {\n      x,\n      y\n    } = viewportCoordsToSceneCoords({\n      clientX: cursorX,\n      clientY: cursorY\n    }, this.state);\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN\n    });\n    this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), element]);\n    this.setState({\n      selectedElementIds: {\n        [element.id]: true\n      }\n    });\n    history.resumeRecording();\n  } // Collaboration\n\n\n  selectShapeTool(elementType) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n\n    if (!isLinearElementType(elementType)) {\n      this.setState({\n        suggestedBindings: []\n      });\n    }\n\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null\n      });\n    } else {\n      this.setState({\n        elementType\n      });\n    }\n  }\n\n  handleTextWysiwyg(element, {\n    isExistingElement = false\n  }) {\n    const updateElement = (text, isDeleted = false) => {\n      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted().map(_element => {\n        if (_element.id === element.id && isTextElement(_element)) {\n          return updateTextElement(_element, {\n            text,\n            isDeleted\n          });\n        }\n\n        return _element;\n      })]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      getViewportCoords: (x, y) => {\n        const {\n          x: viewportX,\n          y: viewportY\n        } = sceneCoordsToViewportCoords({\n          sceneX: x,\n          sceneY: y\n        }, this.state);\n        return [viewportX, viewportY];\n      },\n      onChange: withBatchedUpdates(text => {\n        updateElement(text);\n\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates(text => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n\n        if (!isDeleted) {\n          this.setState(prevState => ({\n            selectedElementIds: { ...prevState.selectedElementIds,\n              [element.id]: true\n            }\n          }));\n        } else {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n\n        if (!isDeleted || isExistingElement) {\n          history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null\n        });\n\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n      }),\n      element\n    }); // deselect all other elements when inserting text\n\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null\n    }); // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n\n    updateElement(element.text);\n  }\n\n  getTextElementAtPosition(x, y) {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n\n    return null;\n  }\n\n  getElementAtPosition(x, y) {\n    const allHitElements = this.getElementsAtPosition(x, y);\n\n    if (allHitElements.length > 1) {\n      const elementWithHighestZIndex = allHitElements[allHitElements.length - 1]; // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n\n      return isHittingElementBoundingBoxWithoutHittingElement(elementWithHighestZIndex, this.state, x, y) ? allHitElements[allHitElements.length - 2] : elementWithHighestZIndex;\n    }\n\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n\n    return null;\n  }\n\n  getElementsAtPosition(x, y) {\n    return getElementsAtPosition(this.scene.getElements(), element => hitTest(element, this.state, x, y));\n  }\n\n  maybeCleanupAfterMissingPointerUp(event) {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  } // Returns whether the event is a panning\n\n\n  updateGestureOnPointerDown(event) {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(Array.from(gesture.pointers.values()));\n    }\n  }\n\n  initialPointerDownState(event) {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n    return {\n      origin,\n      originInGrid: tupleToCoors(getGridPoint(origin.x, origin.y, this.state.gridSize)),\n      scrollbars: isOverScrollBars(currentScrollBars, event.clientX, event.clientY),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin\n      },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map()),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: {\n          x: 0,\n          y: 0\n        },\n        arrowDirection: \"origin\",\n        center: {\n          x: (maxX + minX) / 2,\n          y: (maxY + minY) / 2\n        }\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(origin, selectedElements)\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null\n      }\n    };\n  } // Returns whether the event is a dragging a scrollbar\n\n\n  handleDraggingScrollBar(event, pointerDownState) {\n    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {\n      return false;\n    }\n\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates(event => {\n      const target = event.target;\n\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\"\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n    lastPointerUp = onPointerUp;\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  isASelectedElement(hitElement) {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  isHittingCommonBoundingBoxOfSelectedElements(point, selectedElements) {\n    if (selectedElements.length < 2) {\n      return false;\n    } // How many pixels off the shape boundary we still consider a hit\n\n\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return point.x > x1 - threshold && point.x < x2 + threshold && point.y > y1 - threshold && point.y < y2 + threshold;\n  }\n\n  onKeyDownFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(event => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  onKeyUpFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(event => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  onPointerMoveFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(event => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(getDragOffsetXY(getSelectedElements(this.scene.getElements(), this.state), pointerDownState.origin.x, pointerDownState.origin.y));\n      }\n\n      const target = event.target;\n\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(pointerCoords.x, pointerCoords.y, this.state.gridSize); // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n\n      if (!pointerDownState.drag.hasOccurred && (this.state.elementType === \"arrow\" || this.state.elementType === \"line\")) {\n        if (distance2d(pointerCoords.x, pointerCoords.y, pointerDownState.origin.x, pointerDownState.origin.y) < DRAGGING_THRESHOLD) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(this.state, appState => this.setState(appState), pointerCoords.x, pointerCoords.y, (element, startOrEnd) => {\n          this.maybeSuggestBindingForLinearElementAtCursor(element, startOrEnd, pointerCoords);\n        });\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(element => this.isASelectedElement(element));\n\n      if (hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(this.scene.getElements(), this.state);\n\n        if (selectedElements.length > 0) {\n          const [dragX, dragY] = getGridPoint(pointerCoords.x - pointerDownState.drag.offset.x, pointerCoords.y - pointerDownState.drag.offset.y, this.state.gridSize);\n          const [dragDistanceX, dragDistanceY] = [Math.abs(pointerCoords.x - pointerDownState.origin.x), Math.abs(pointerCoords.y - pointerDownState.origin.y)]; // We only drag in one direction if shift is pressed\n\n          const lockDirection = event.shiftKey;\n          dragSelectedElements(pointerDownState, selectedElements, dragX, dragY, this.scene, lockDirection, dragDistanceX, dragDistanceY);\n          this.maybeSuggestBindingForAll(selectedElements); // We duplicate the selected element if alt is pressed on pointer move\n\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n            pointerDownState.hit.hasBeenDuplicated = true;\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (this.state.selectedElementIds[element.id] || // case: the state.selectedElementIds might not have been\n              // updated yet by the time this mousemove event is fired\n              element.id === (hitElement === null || hitElement === void 0 ? void 0 : hitElement.id) && pointerDownState.hit.wasAddedToSelection) {\n                const duplicatedElement = duplicateElement(this.state.editingGroupId, groupIdMap, element);\n                const [originDragX, originDragY] = getGridPoint(pointerDownState.origin.x - pointerDownState.drag.offset.x, pointerDownState.origin.y - pointerDownState.drag.offset.y, this.state.gridSize);\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY)\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(nextSceneElements, elementsToAppend, oldIdToDuplicatedId, \"duplicatesServeAsOld\");\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n\n          return;\n        }\n      } // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n\n\n      const draggingElement = this.state.draggingElement;\n\n      if (!draggingElement) {\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx;\n        let dy;\n\n        if (draggingElement.type === \"draw\") {\n          dx = pointerCoords.x - draggingElement.x;\n          dy = pointerCoords.y - draggingElement.y;\n        } else {\n          dx = gridX - draggingElement.x;\n          dy = gridY - draggingElement.y;\n        }\n\n        if (getRotateWithDiscreteAngleKey(event) && points.length === 2) {\n          ({\n            width: dx,\n            height: dy\n          } = getPerfectElementSize(this.state.elementType, dx, dy));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, {\n            points: [...points, [dx, dy]]\n          });\n        } else if (points.length > 1) {\n          if (draggingElement.type === \"draw\") {\n            mutateElement(draggingElement, {\n              points: simplify([...points, [dx, dy]], 0.7 / this.state.zoom.value)\n            });\n          } else {\n            mutateElement(draggingElement, {\n              points: [...points.slice(0, -1), [dx, dy]]\n            });\n          }\n        }\n\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(draggingElement, \"end\", pointerCoords, this.state.startBoundElement);\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({\n            selectedElementIds: {},\n            selectedGroupIds: {},\n            editingGroupId: null\n          });\n        }\n\n        const elementsWithinSelection = getElementsWithinSelection(elements, draggingElement);\n        this.setState(prevState => selectGroupsForSelectedElements({ ...prevState,\n          selectedElementIds: { ...prevState.selectedElementIds,\n            ...elementsWithinSelection.reduce((map, element) => {\n              map[element.id] = true;\n              return map;\n            }, {})\n          }\n        }, this.scene.getElements()));\n      }\n    });\n  } // Returns whether the pointer move happened over either scrollbar\n\n\n  handlePointerMoveOverScrollbars(event, pointerDownState) {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom.value)\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom.value)\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n\n    return false;\n  }\n\n  onPointerUpFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(childEvent => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating\n      } = this.state;\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement: multiElement || isTextElement(this.state.editingElement) ? this.state.editingElement : null\n      });\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\"); // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(childEvent, this.state.editingLinearElement, this.state);\n\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: []\n          });\n        }\n      }\n\n      lastPointerUp = null;\n      window.removeEventListener(EVENT.POINTER_MOVE, pointerDownState.eventListeners.onMove);\n      window.removeEventListener(EVENT.POINTER_UP, pointerDownState.eventListeners.onUp);\n      window.removeEventListener(EVENT.KEYDOWN, pointerDownState.eventListeners.onKeyDown);\n      window.removeEventListener(EVENT.KEYUP, pointerDownState.eventListeners.onKeyUp);\n\n      if ((draggingElement === null || draggingElement === void 0 ? void 0 : draggingElement.type) === \"draw\") {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement.points.length > 1) {\n          history.resumeRecording();\n        }\n\n        const pointerCoords = viewportCoordsToSceneCoords(childEvent, this.state);\n\n        if (!pointerDownState.drag.hasOccurred && draggingElement && !multiElement) {\n          mutateElement(draggingElement, {\n            points: [...draggingElement.points, [pointerCoords.x - draggingElement.x, pointerCoords.y - draggingElement.y]]\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (isBindingEnabled(this.state) && isBindingElement(draggingElement)) {\n            maybeBindLinearElement(draggingElement, this.state, this.scene, pointerCoords);\n          }\n\n          this.setState({\n            suggestedBindings: [],\n            startBoundElement: null\n          });\n\n          if (!elementLocked && elementType !== \"draw\") {\n            resetCursor();\n            this.setState(prevState => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: { ...prevState.selectedElementIds,\n                [this.state.draggingElement.id]: true\n              }\n            }));\n          } else {\n            this.setState(prevState => ({\n              draggingElement: null,\n              selectedElementIds: { ...prevState.selectedElementIds,\n                [this.state.draggingElement.id]: true\n              }\n            }));\n          }\n        }\n\n        return;\n      }\n\n      if (elementType !== \"selection\" && draggingElement && isInvisiblySmallElement(draggingElement)) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().slice(0, -1));\n        this.setState({\n          draggingElement: null\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(draggingElement, getNormalizedDimensions(draggingElement));\n      }\n\n      if (resizingElement) {\n        history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().filter(el => el.id !== resizingElement.id));\n      } // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n\n\n      const hitElement = pointerDownState.hit.element;\n\n      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds.flatMap(groupId => getElementsInGroup(this.scene.getElements(), groupId)).map(element => ({\n                [element.id]: false\n              })).reduce((prevId, acc) => ({ ...prevId,\n                ...acc\n              }), {});\n              this.setState(_prevState => ({\n                selectedGroupIds: { ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds.map(gId => ({\n                    [gId]: false\n                  })).reduce((prev, acc) => ({ ...prev,\n                    ...acc\n                  }), {})\n                },\n                selectedElementIds: { ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups\n                }\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState(prevState => ({\n                selectedElementIds: { ...prevState.selectedElementIds,\n                  [hitElement.id]: false\n                }\n              }));\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState(_prevState => ({\n              selectedElementIds: { ..._prevState.selectedElementIds,\n                [hitElement.id]: true\n              }\n            }));\n          }\n        } else {\n          this.setState(prevState => ({ ...selectGroupsForSelectedElements({ ...prevState,\n              selectedElementIds: {\n                [hitElement.id]: true\n              }\n            }, this.scene.getElements())\n          }));\n        }\n      }\n\n      if (!this.state.editingLinearElement && !pointerDownState.drag.hasOccurred && !this.state.isResizing && (hitElement && isHittingElementBoundingBoxWithoutHittingElement(hitElement, this.state, pointerDownState.origin.x, pointerDownState.origin.y) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null\n        });\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"draw\" && draggingElement) {\n        this.setState(prevState => ({\n          selectedElementIds: { ...prevState.selectedElementIds,\n            [draggingElement.id]: true\n          }\n        }));\n      }\n\n      if (elementType !== \"selection\" || isSomeElementSelected(this.scene.getElements(), this.state)) {\n        history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state) ? bindOrUnbindSelectedElements : unbindLinearElements)(getSelectedElements(this.scene.getElements(), this.state));\n      }\n\n      if (!elementLocked && elementType !== \"draw\") {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\"\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: []\n        });\n      }\n    });\n  }\n\n  maybeSuggestBindingForAll(selectedElements) {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({\n      suggestedBindings\n    });\n  }\n\n  clearSelection(hitElement) {\n    this.setState(prevState => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds\n    });\n  }\n\n  getTextWysiwygSnappedToCenterPosition(x, y, appState, canvas, scale) {\n    const elementClickedInside = getElementContainingPosition(this.scene.getElementsIncludingDeleted().filter(element => !isTextElement(element)), x, y);\n\n    if (elementClickedInside) {\n      const elementCenterX = elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY = elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(x - elementCenterX, y - elementCenterY);\n      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n\n      if (isSnappedToCenter) {\n        const {\n          x: viewportX,\n          y: viewportY\n        } = sceneCoordsToViewportCoords({\n          sceneX: elementCenterX,\n          sceneY: elementCenterY\n        }, appState);\n        return {\n          viewportX,\n          viewportY,\n          elementCenterX,\n          elementCenterY\n        };\n      }\n    }\n  }\n\n  getCanvasOffsets(offsets) {\n    var _this$excalidrawConta, _this$excalidrawConta2;\n\n    if (typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetLeft) === \"number\" && typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetTop) === \"number\") {\n      return {\n        offsetLeft: offsets.offsetLeft,\n        offsetTop: offsets.offsetTop\n      };\n    }\n\n    if ((_this$excalidrawConta = this.excalidrawContainerRef) === null || _this$excalidrawConta === void 0 ? void 0 : (_this$excalidrawConta2 = _this$excalidrawConta.current) === null || _this$excalidrawConta2 === void 0 ? void 0 : _this$excalidrawConta2.parentElement) {\n      const parentElement = this.excalidrawContainerRef.current.parentElement;\n      const {\n        left,\n        top\n      } = parentElement.getBoundingClientRect();\n      return {\n        offsetLeft: typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetLeft) === \"number\" ? offsets.offsetLeft : left,\n        offsetTop: typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetTop) === \"number\" ? offsets.offsetTop : top\n      };\n    }\n\n    return {\n      offsetLeft: typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetLeft) === \"number\" ? offsets.offsetLeft : 0,\n      offsetTop: typeof (offsets === null || offsets === void 0 ? void 0 : offsets.offsetTop) === \"number\" ? offsets.offsetTop : 0\n    };\n  }\n\n  async updateLanguage() {\n    const currentLang = languages.find(lang => lang.code === this.props.langCode) || defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n\n} // -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\n\nApp.defaultProps = {\n  width: window.innerWidth,\n  height: window.innerHeight\n};\n\nif (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  window.h = window.h || {};\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n\n      set(elements) {\n        return this.app.scene.replaceAllElements(elements);\n      }\n\n    },\n    history: {\n      configurable: true,\n      get: () => history\n    },\n    library: {\n      configurable: true,\n      value: Library\n    }\n  });\n}\n\nexport default App;","map":{"version":3,"sources":["/var/www/html/excalidraw/src/components/App.tsx"],"names":["simplify","React","rough","actionDeleteSelected","actionFinalize","createRedoAction","createUndoAction","ActionManager","actions","trackEvent","getDefaultAppState","copyToClipboard","parseClipboard","probablySupportsClipboardBlob","probablySupportsClipboardWriteText","APP_NAME","CANVAS_ONLY_ACTIONS","CURSOR_TYPE","DEFAULT_VERTICAL_ALIGN","DRAGGING_THRESHOLD","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","ENV","EVENT","GRID_SIZE","LINE_CONFIRM_THRESHOLD","MIME_TYPES","POINTER_BUTTON","TAP_TWICE_TIMEOUT","TEXT_TO_CENTER_SNAP_THRESHOLD","TOUCH_CTX_MENU_TIMEOUT","exportCanvas","loadFromBlob","isValidLibrary","Library","restore","dragNewElement","dragSelectedElements","duplicateElement","getCommonBounds","getCursorForResizingElement","getDragOffsetXY","getElementWithTransformHandleType","getNonDeletedElements","getNormalizedDimensions","getPerfectElementSize","getResizeArrowDirection","getResizeOffsetXY","getTransformHandleTypeFromCoords","hitTest","isHittingElementBoundingBoxWithoutHittingElement","isInvisiblySmallElement","isNonDeletedElement","isTextElement","newElement","newLinearElement","newTextElement","textWysiwyg","transformElements","updateTextElement","bindOrUnbindSelectedElements","fixBindingsAfterDeletion","fixBindingsAfterDuplication","getEligibleElementsForBinding","getHoveredElementForBinding","isBindingEnabled","isLinearElementSimpleAndAlreadyBound","maybeBindLinearElement","shouldEnableBindingForPointerEvent","unbindLinearElements","updateBoundElements","LinearElementEditor","mutateElement","deepCopyElement","isBindingElement","isBindingElementType","isLinearElement","isLinearElementType","getCenter","getDistance","editGroupForSelectedElement","getElementsInGroup","getSelectedGroupIdForElement","getSelectedGroupIds","isElementInGroup","isSelectedViaGroup","selectGroupsForSelectedElements","createHistory","defaultLang","getLanguage","languages","setLanguage","t","CODES","getResizeCenterPointKey","getResizeWithSidesSameLengthKey","getRotateWithDiscreteAngleKey","isArrowKey","KEYS","distance2d","getGridPoint","isPathALoop","renderScene","invalidateShapeForElement","calculateScrollCenter","getElementContainingPosition","getElementsAtPosition","getElementsWithinSelection","getNormalizedZoom","getSelectedElements","isOverScrollBars","isSomeElementSelected","normalizeScroll","Scene","getNewZoom","findShapeByKey","debounce","distance","isInputLike","isToolIcon","isWritableElement","resetCursor","resolvablePromise","sceneCoordsToViewportCoords","setCursorForShape","tupleToCoors","viewportCoordsToSceneCoords","withBatchedUpdates","ContextMenu","LayerUI","Stats","Toast","history","didTapTwice","tappedTwiceTimer","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","horizontal","vertical","touchTimeout","invalidateContextMenu","lastPointerUp","gesture","pointers","Map","lastCenter","initialDistance","initialScale","App","Component","constructor","props","canvas","rc","unmounted","actionManager","excalidrawContainerRef","createRef","scene","getSceneElementsIncludingDeleted","getElementsIncludingDeleted","getSceneElements","getElements","syncActionResult","actionResult","editingElement","elements","forEach","element","state","id","replaceAllElements","commitToHistory","resumeRecording","appState","setState","width","height","offsetTop","offsetLeft","syncHistory","setCurrentState","onBlur","onUnload","disableEvent","event","preventDefault","onFontLoaded","onSceneUpdated","importLibraryFromUrl","url","window","replaceState","location","origin","request","fetch","blob","json","JSON","parse","text","Error","confirm","numShapes","library","length","importLibrary","isLibraryOpen","error","alert","console","resetHistory","clear","resetScene","opts","isLoading","resetLoadingState","appearance","initializeScene","launchQueue","setConsumer","launchParams","files","fileHandle","getFile","handle","then","catch","errorMessage","message","initialData","addToLibraryUrl","URLSearchParams","search","get","onResize","onCut","target","cutAll","onCopy","copyAll","executeAction","copyToClipboardAsPng","selectedElements","toastMessage","copyToClipboardAsSvg","onTapStart","clearTimeout","setTimeout","resetTapTwice","touches","touch","handleCanvasDoubleClick","clientX","clientY","selectedElementIds","onTapEnd","previousSelectedElementIds","pasteFromClipboard","document","activeElement","elementUnderCursor","elementFromPoint","HTMLCanvasElement","data","spreadsheet","pasteDialog","shown","addElementsFromPasteOrLibrary","addTextFromPaste","selectShapeTool","clipboardElements","minX","minY","maxX","maxY","elementsCenterX","elementsCenterY","x","y","dx","dy","groupIdMap","gridX","gridY","gridSize","oldIdToDuplicatedId","newElements","map","editingGroupId","set","nextElements","reduce","selectedGroupIds","setAppState","obj","removePointer","pointerType","delete","pointerId","toggleLock","prevState","elementLocked","elementType","toggleZenMode","zenModeEnabled","toggleGridMode","toggleStats","showStats","setScrollToCenter","remoteElements","clearToast","updateScene","sceneData","viewBackgroundColor","collaborators","updateCurrentCursorPosition","onKeyDown","shiftKey","test","key","Proxy","ev","prop","value","bind","toUpperCase","toLowerCase","ESCAPE","QUESTION_MARK","showShortcutsDialog","CTRL_OR_CMD","altKey","code","Z","QUOTE","C","handleKeyDown","NINE","step","filter","offsetX","offsetY","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","simultaneouslyUpdated","maybeSuggestBindingForAll","ENTER","editingLinearElement","elementId","selectedElement","startTextEditing","sceneX","sceneY","ctrlKey","metaKey","draggingElement","shape","Q","SPACE","size","documentElement","style","cursor","GRABBING","onKeyUp","suggestedBindings","onGestureStart","zoom","onGestureChange","scale","left","top","onGestureEnd","insertAtParentCenter","existingTextElement","getTextElementAtPosition","parentCenterPosition","getTextWysiwygSnappedToCenterPosition","devicePixelRatio","elementCenterX","elementCenterY","strokeColor","currentItemStrokeColor","backgroundColor","currentItemBackgroundColor","fillStyle","currentItemFillStyle","strokeWidth","currentItemStrokeWidth","strokeStyle","currentItemStrokeStyle","roughness","currentItemRoughness","opacity","currentItemOpacity","strokeSharpness","currentItemStrokeSharpness","fontSize","currentItemFontSize","fontFamily","currentItemFontFamily","textAlign","currentItemTextAlign","verticalAlign","baseline","handleTextWysiwyg","isExistingElement","multiElement","hitElement","getElementAtPosition","selectedGroupId","handleCanvasPointerMove","savePointer","cursorButton","has","center","deltaX","deltaY","Array","from","values","scaleFactor","scrollX","scrollY","shouldCacheIgnoreZoom","resetShouldCacheIgnoreZoomDebounced","isPointerOverScrollBars","isOverScrollBar","isOverEither","scenePointer","scenePointerX","scenePointerY","isDragging","handlePointerMove","lastUncommittedPoint","maybeSuggestBindingAtCursor","maybeSuggestBindingForLinearElementAtCursor","startBoundElement","rx","ry","points","lastCommittedPoint","lastPoint","POINTER","slice","hasDeselectedButton","Boolean","buttons","elementWithTransformHandleType","transformHandleType","TEXT","CROSSHAIR","AUTO","isHittingCommonBoundingBoxOfSelectedElements","MOVE","handleTouchMove","handleCanvasPointerDown","persist","maybeOpenContextMenuAfterPointerDownOnTouchDevices","maybeCleanupAfterMissingPointerUp","lastPointerDownWith","handleCanvasPanUsingWheelOrSpaceDrag","button","MAIN","TOUCH","updateGestureOnPointerDown","HTMLElement","blur","pointerDownState","initialPointerDownState","handleDraggingScrollBar","clearSelectionIfNotUsingSelection","updateBindingEnabledOnPointerMove","handleSelectionOnPointerDown","handleTextOnPointerDown","handleLinearElementOnPointerDown","createGenericElementOnPointerDown","onPointerMove","onPointerMoveFromPointerDownHandler","onPointerUp","onPointerUpFromPointerDownHandler","onKeyDownFromPointerDownHandler","onKeyUpFromPointerDownHandler","addEventListener","POINTER_MOVE","POINTER_UP","KEYDOWN","KEYUP","eventListeners","onMove","onUp","openContextMenu","WHEEL","nextPastePrevented","isLinux","navigator","platform","lastX","lastY","Math","abs","preventNextPaste","body","removeEventListener","PASTE","stopPropagation","enableNextPaste","teardown","BLUR","passive","resizingElement","resize","handleType","isResizing","offset","arrowDirection","ret","handlePointerDown","hit","didAddPoint","allHitElements","someHitElementIsSelected","some","isASelectedElement","hasHitCommonBoundingBoxOfSelectedElements","clearSelection","wasAddedToSelection","type","currentItemStartArrowhead","currentItemEndArrowhead","startArrowhead","endArrowhead","currentItemLinearStrokeSharpness","boundElement","selectionElement","shouldEnableBinding","pointerCoords","hoveredBindableElement","linearElement","startOrEnd","oppositeBindingBoundElement","handleCanvasRef","handleWheel","TOUCH_START","TOUCH_END","handleCanvasOnDrop","file","dataTransfer","libraryShapes","getData","excalidrawlib","name","endsWith","item","items","getAsFileSystemHandle","warn","handleCanvasContextMenu","maybeDragNewGenericElement","lastCoords","originInGrid","maybeHandleResize","isRotating","resizeX","resizeY","push","options","clipboard","shortcutName","label","action","getContextMenuItems","includes","checked","sign","MAX_STEP","delta","Object","keys","pointer","isNaN","onPointerUpdate","pointersMap","defaultAppState","innerWidth","innerHeight","excalidrawRef","getCanvasOffsets","readyPromise","current","api","ready","resolve","registerAll","registerAction","render","canvasDOMWidth","canvasDOMHeight","onCollabButtonClick","onExportToBackend","renderFooter","canvasScale","canvasWidth","canvasHeight","DEFAULT_PASTE_X","DEFAULT_PASTE_Y","isCollaborating","componentDidMount","process","env","NODE_ENV","TEST","DEVELOPMENT","defineProperties","h","configurable","args","app","addCallback","addEventListeners","componentWillUnmount","removeEventListeners","destroy","COPY","CUT","MOUSE_MOVE","RESIZE","UNLOAD","DRAG_OVER","DROP","GESTURE_START","GESTURE_CHANGE","GESTURE_END","fonts","componentDidUpdate","prevProps","langCode","updateLanguage","querySelector","classList","toggle","getPointAtIndexGlobalCoordinates","pointerViewportCoords","remoteSelectedElementIds","pointerUsernames","user","socketId","username","atLeastOneVisibleElement","scrollBars","remotePointerViewportCoords","remotePointerButton","remotePointerUsernames","renderOptimizations","scrolledOutside","record","onChange","updateElement","isDeleted","_element","getViewportCoords","viewportX","viewportY","onSubmit","trim","elementWithHighestZIndex","scrollbars","originalElements","acc","hasBeenDuplicated","drag","hasOccurred","handlePointerMoveOverScrollbars","point","threshold","x1","y1","x2","y2","ALT","didDrag","handlePointDragging","hasHitASelectedElement","dragX","dragY","dragDistanceX","dragDistanceY","lockDirection","elementsToAppend","duplicatedElement","originDragX","originDragY","nextSceneElements","elementsWithinSelection","isOverHorizontal","isOverVertical","childEvent","handlePointerUp","el","idsOfSelectedElementsThatAreInGroups","groupIds","flatMap","groupId","prevId","_prevState","gId","prev","elementClickedInside","distanceToCenter","hypot","isSnappedToCenter","offsets","parentElement","getBoundingClientRect","currentLang","find","lang","defaultProps"],"mappings":"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","sourcesContent":["import { Point, simplify } from \"points-on-curve\";\nimport React from \"react\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport \"../actions\";\nimport { actionDeleteSelected, actionFinalize } from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  copyToClipboard,\n  parseClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport {\n  APP_NAME,\n  CANVAS_ONLY_ACTIONS,\n  CURSOR_TYPE,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  GRID_SIZE,\n  LINE_CONFIRM_THRESHOLD,\n  MIME_TYPES,\n  POINTER_BUTTON,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  TOUCH_CTX_MENU_TIMEOUT,\n} from \"../constants\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { restore } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNonDeletedElements,\n  getNormalizedDimensions,\n  getPerfectElementSize,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n} from \"../element\";\nimport {\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { deepCopyElement } from \"../element/newElement\";\nimport { MaybeTransformHandleType } from \"../element/transformHandles\";\nimport {\n  isBindingElement,\n  isBindingElementType,\n  isLinearElement,\n  isLinearElementType,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport { createHistory, SceneHistory } from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  getResizeCenterPointKey,\n  getResizeWithSidesSameLengthKey,\n  getRotateWithDiscreteAngleKey,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementContainingPosition,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  isOverScrollBars,\n  isSomeElementSelected,\n  normalizeScroll,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { SceneState, ScrollBars } from \"../scene/types\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport {\n  AppState,\n  ExcalidrawProps,\n  Gesture,\n  GestureEvent,\n  SceneData,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  ResolvablePromise,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n} from \"../utils\";\nimport ContextMenu from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\n\nconst { history } = createHistory();\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  drag: {\n    // Might change during the pointer interation\n    hasOccurred: boolean;\n    // Might change during the pointer interation\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  setScrollToCenter: InstanceType<typeof App>[\"setScrollToCenter\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n};\n\nclass App extends React.Component<ExcalidrawProps, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<ExcalidrawProps> = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n  private scene: Scene;\n  constructor(props: ExcalidrawProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n\n    const {\n      width = window.innerWidth,\n      height = window.innerHeight,\n      offsetLeft,\n      offsetTop,\n      excalidrawRef,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      isLoading: true,\n      width,\n      height,\n      ...this.getCanvasOffsets({ offsetLeft, offsetTop }),\n    };\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        setScrollToCenter: this.setScrollToCenter,\n        getSceneElements: this.getSceneElements,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n    this.scene = new Scene();\n\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  public render() {\n    const {\n      zenModeEnabled,\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      offsetTop,\n      offsetLeft,\n    } = this.state;\n\n    const { onCollabButtonClick, onExportToBackend, renderFooter } = this.props;\n    const canvasScale = window.devicePixelRatio;\n\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n\n    const DEFAULT_PASTE_X = canvasDOMWidth / 2;\n    const DEFAULT_PASTE_Y = canvasDOMHeight / 2;\n\n    return (\n      <div\n        className=\"excalidraw\"\n        ref={this.excalidrawContainerRef}\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n          top: offsetTop,\n          left: offsetLeft,\n        }}\n      >\n        <LayerUI\n          canvas={this.canvas}\n          appState={this.state}\n          setAppState={this.setAppState}\n          actionManager={this.actionManager}\n          elements={this.scene.getElements()}\n          onCollabButtonClick={onCollabButtonClick}\n          onLockToggle={this.toggleLock}\n          onInsertElements={(elements) =>\n            this.addElementsFromPasteOrLibrary(\n              elements,\n              DEFAULT_PASTE_X,\n              DEFAULT_PASTE_Y,\n            )\n          }\n          zenModeEnabled={zenModeEnabled}\n          toggleZenMode={this.toggleZenMode}\n          langCode={getLanguage().code}\n          isCollaborating={this.props.isCollaborating || false}\n          onExportToBackend={onExportToBackend}\n          renderCustomFooter={renderFooter}\n        />\n        {this.state.showStats && (\n          <Stats\n            appState={this.state}\n            elements={this.scene.getElements()}\n            onClose={this.toggleStats}\n          />\n        )}\n        {this.state.toastMessage !== null && (\n          <Toast\n            message={this.state.toastMessage}\n            clearToast={this.clearToast}\n          />\n        )}\n        <main>\n          <canvas\n            id=\"canvas\"\n            style={{\n              width: canvasDOMWidth,\n              height: canvasDOMHeight,\n            }}\n            width={canvasWidth}\n            height={canvasHeight}\n            ref={this.handleCanvasRef}\n            onContextMenu={this.handleCanvasContextMenu}\n            onPointerDown={this.handleCanvasPointerDown}\n            onDoubleClick={this.handleCanvasDoubleClick}\n            onPointerMove={this.handleCanvasPointerMove}\n            onPointerUp={this.removePointer}\n            onPointerCancel={this.removePointer}\n            onTouchMove={this.handleTouchMove}\n            onDrop={this.handleCanvasOnDrop}\n          >\n            {t(\"labels.drawingCanvas\")}\n          </canvas>\n        </main>\n      </div>\n    );\n  }\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getElements();\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n        this.setState(\n          (state) => ({\n            ...actionResult.appState,\n            editingElement:\n              editingElement || actionResult.appState?.editingElement || null,\n            width: state.width,\n            height: state.height,\n            offsetTop: state.offsetTop,\n            offsetLeft: state.offsetLeft,\n          }),\n          () => {\n            if (actionResult.syncHistory) {\n              history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventHandlerNonNull = (event) => {\n    event.preventDefault();\n  };\n\n  private onFontLoaded = () => {\n    this.scene.getElementsIncludingDeleted().forEach((element) => {\n      if (isTextElement(element)) {\n        invalidateShapeForElement(element);\n      }\n    });\n    this.onSceneUpdated();\n  };\n\n  private importLibraryFromUrl = async (url: string) => {\n    window.history.replaceState({}, APP_NAME, window.location.origin);\n    try {\n      const request = await fetch(url);\n      const blob = await request.blob();\n      const json = JSON.parse(await blob.text());\n      if (!isValidLibrary(json)) {\n        throw new Error();\n      }\n      if (\n        window.confirm(\n          t(\"alerts.confirmAddLibrary\", { numShapes: json.library.length }),\n        )\n      ) {\n        await Library.importLibrary(blob);\n        this.setState({\n          isLibraryOpen: true,\n        });\n      }\n    } catch (error) {\n      window.alert(t(\"alerts.errorLoadingLibrary\"));\n      console.error(error);\n    }\n  };\n\n  private resetHistory = () => {\n    history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        appearance: this.state.appearance,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(blob, this.state)\n            .then(({ elements, appState }) =>\n              this.syncActionResult({\n                elements,\n                appState: {\n                  ...(appState || this.state),\n                  isLoading: false,\n                },\n                commitToHistory: true,\n              }),\n            )\n            .catch((error) => {\n              this.setState({ isLoading: false, errorMessage: error.message });\n            });\n        },\n      );\n    }\n\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n    } catch (error) {\n      console.error(error);\n    }\n\n    const scene = restore(initialData, null);\n\n    scene.appState = {\n      ...scene.appState,\n      ...calculateScrollCenter(\n        scene.elements,\n        {\n          ...scene.appState,\n          width: this.state.width,\n          height: this.state.height,\n          offsetTop: this.state.offsetTop,\n          offsetLeft: this.state.offsetLeft,\n        },\n        null,\n      ),\n      isLoading: false,\n    };\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n\n    const addToLibraryUrl = new URLSearchParams(window.location.search).get(\n      \"addLibrary\",\n    );\n\n    if (addToLibraryUrl) {\n      await this.importLibraryFromUrl(addToLibraryUrl);\n    }\n  };\n\n  public async componentDidMount() {\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n\n    this.addEventListeners();\n\n    // optim to avoid extra render on init\n    if (\n      typeof this.props.offsetLeft === \"number\" &&\n      typeof this.props.offsetTop === \"number\"\n    ) {\n      this.initializeScene();\n    } else {\n      this.setState(this.getCanvasOffsets(this.props), () => {\n        this.initializeScene();\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n  }\n\n  private addEventListeners() {\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n\n    document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false);\n\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", this.onFontLoaded);\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n  }\n\n  componentDidUpdate(prevProps: ExcalidrawProps, prevState: AppState) {\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      (typeof this.props.offsetLeft === \"number\" &&\n        prevProps.offsetLeft !== this.props.offsetLeft) ||\n      (typeof this.props.offsetTop === \"number\" &&\n        prevProps.offsetTop !== this.props.offsetTop)\n    ) {\n      this.setState({\n        width: this.props.width ?? window.innerWidth,\n        height: this.props.height ?? window.innerHeight,\n        ...this.getCanvasOffsets(this.props),\n      });\n    }\n\n    document\n      .querySelector(\".excalidraw\")\n      ?.classList.toggle(\"Appearance_dark\", this.state.appearance === \"dark\");\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n    const { multiElement } = prevState;\n    if (\n      prevState.elementType !== this.state.elementType &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n    const elements = this.scene.getElements();\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements.filter((element) => {\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      }),\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n      },\n      {\n        renderOptimizations: true,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingElement?.type === \"text\"\n        ? false\n        : !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n      );\n    }\n  }\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private cutAll = () => {\n    this.copyAll();\n    this.actionManager.executeAction(actionDeleteSelected);\n  };\n\n  private copyAll = () => {\n    copyToClipboard(this.scene.getElements(), this.state);\n  };\n\n  private copyToClipboardAsPng = async () => {\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length ? selectedElements : elements,\n        this.state,\n        this.canvas!,\n        this.state,\n      );\n      this.setState({ toastMessage: t(\"toast.copyToClipboardAsPng\") });\n    } catch (error) {\n      console.error(error);\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  private copyToClipboardAsSvg = async () => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length ? selectedElements : this.scene.getElements(),\n        this.state,\n        this.canvas!,\n        this.state,\n      );\n    } catch (error) {\n      console.error(error);\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds,\n      });\n    }\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        // thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n      const data = await parseClipboard(event);\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (\n    clipboardElements: readonly ExcalidrawElement[],\n    clientX = cursorX,\n    clientY = cursorY,\n  ) => {\n    const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n    const groupIdMap = new Map();\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const oldIdToDuplicatedId = new Map();\n    const newElements = clipboardElements.map((element) => {\n      const newElement = duplicateElement(\n        this.state.editingGroupId,\n        groupIdMap,\n        element,\n        {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        },\n      );\n      oldIdToDuplicatedId.set(element.id, newElement.id);\n      return newElement;\n    });\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n    fixBindingsAfterDuplication(\n      nextElements,\n      clipboardElements,\n      oldIdToDuplicatedId,\n    );\n\n    this.scene.replaceAllElements(nextElements);\n    history.resumeRecording();\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          isLibraryOpen: false,\n          selectedElementIds: newElements.reduce((map, element) => {\n            map[element.id] = true;\n            return map;\n          }, {} as any),\n          selectedGroupIds: {},\n        },\n        this.scene.getElements(),\n      ),\n    );\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n    );\n\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    // remove touch handler for context menu on touch devices\n    if (event.pointerType === \"touch\" && touchTimeout) {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => {\n      return {\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked\n          ? \"selection\"\n          : prevState.elementType,\n      };\n    });\n  };\n\n  toggleZenMode = () => {\n    this.setState({\n      zenModeEnabled: !this.state.zenModeEnabled,\n    });\n  };\n\n  toggleGridMode = () => {\n    this.setState({\n      gridSize: this.state.gridSize ? null : GRID_SIZE,\n    });\n  };\n\n  toggleStats = () => {\n    if (!this.state.showStats) {\n      trackEvent(\"dialog\", \"stats\");\n    }\n    this.setState({\n      showStats: !this.state.showStats,\n    });\n  };\n\n  setScrollToCenter = (remoteElements: readonly ExcalidrawElement[]) => {\n    this.setState({\n      ...calculateScrollCenter(\n        getNonDeletedElements(remoteElements),\n        this.state,\n        this.canvas,\n      ),\n    });\n  };\n\n  clearToast = () => {\n    this.setState({ toastMessage: null });\n  };\n\n  public updateScene = withBatchedUpdates((sceneData: SceneData) => {\n    if (sceneData.commitToHistory) {\n      history.resumeRecording();\n    }\n\n    // currently we only support syncing background color\n    if (sceneData.appState?.viewBackgroundColor) {\n      this.setState({\n        viewBackgroundColor: sceneData.appState.viewBackgroundColor,\n      });\n    }\n\n    if (sceneData.elements) {\n      this.scene.replaceAllElements(sceneData.elements);\n    }\n\n    if (sceneData.collaborators) {\n      this.setState({ collaborators: sceneData.collaborators });\n    }\n  });\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.x;\n      cursorY = event.y;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates((event: KeyboardEvent) => {\n    // normalize `event.key` when CapsLock is pressed #2372\n    if (\n      \"Proxy\" in window &&\n      ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n        (event.shiftKey && /^[a-z]$/.test(event.key)))\n    ) {\n      event = new Proxy(event, {\n        get(ev: any, prop) {\n          const value = ev[prop];\n          if (typeof value === \"function\") {\n            // fix for Proxies hijacking `this`\n            return value.bind(ev);\n          }\n          return prop === \"key\"\n            ? // CapsLock inverts capitalization based on ShiftKey, so invert\n              // it back\n              event.shiftKey\n              ? ev.key.toUpperCase()\n              : ev.key.toLowerCase()\n            : value;\n        },\n      });\n    }\n\n    if (\n      (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n      // case: using arrows to move between buttons\n      (isArrowKey(event.key) && isInputLike(event.target))\n    ) {\n      return;\n    }\n\n    if (event.key === KEYS.QUESTION_MARK) {\n      this.setState({\n        showShortcutsDialog: true,\n      });\n    }\n\n    if (!event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z) {\n      this.toggleZenMode();\n    }\n\n    if (event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE) {\n      this.toggleGridMode();\n    }\n    if (event[KEYS.CTRL_OR_CMD]) {\n      this.setState({ isBindingEnabled: false });\n    }\n\n    if (event.code === CODES.C && event.altKey && event.shiftKey) {\n      this.copyToClipboardAsPng();\n      event.preventDefault();\n      return;\n    }\n\n    if (this.actionManager.handleKeyDown(event)) {\n      return;\n    }\n\n    if (event.code === CODES.NINE) {\n      this.setState({ isLibraryOpen: !this.state.isLibraryOpen });\n    }\n\n    if (isArrowKey(event.key)) {\n      const step =\n        (this.state.gridSize &&\n          (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize)) ||\n        (event.shiftKey\n          ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n          : ELEMENT_TRANSLATE_AMOUNT);\n\n      const selectedElements = this.scene\n        .getElements()\n        .filter((element) => this.state.selectedElementIds[element.id]);\n\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (event.key === KEYS.ARROW_LEFT) {\n        offsetX = -step;\n      } else if (event.key === KEYS.ARROW_RIGHT) {\n        offsetX = step;\n      } else if (event.key === KEYS.ARROW_UP) {\n        offsetY = -step;\n      } else if (event.key === KEYS.ARROW_DOWN) {\n        offsetY = step;\n      }\n\n      selectedElements.forEach((element) => {\n        mutateElement(element, {\n          x: element.x + offsetX,\n          y: element.y + offsetY,\n        });\n\n        updateBoundElements(element, {\n          simultaneouslyUpdated: selectedElements,\n        });\n      });\n\n      this.maybeSuggestBindingForAll(selectedElements);\n\n      event.preventDefault();\n    } else if (event.key === KEYS.ENTER) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n\n      if (\n        selectedElements.length === 1 &&\n        isLinearElement(selectedElements[0])\n      ) {\n        if (\n          !this.state.editingLinearElement ||\n          this.state.editingLinearElement.elementId !== selectedElements[0].id\n        ) {\n          history.resumeRecording();\n          this.setState({\n            editingLinearElement: new LinearElementEditor(\n              selectedElements[0],\n              this.scene,\n            ),\n          });\n        }\n      } else if (\n        selectedElements.length === 1 &&\n        !isLinearElement(selectedElements[0])\n      ) {\n        const selectedElement = selectedElements[0];\n        this.startTextEditing({\n          sceneX: selectedElement.x + selectedElement.width / 2,\n          sceneY: selectedElement.y + selectedElement.height / 2,\n        });\n        event.preventDefault();\n        return;\n      }\n    } else if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      this.state.draggingElement === null\n    ) {\n      const shape = findShapeByKey(event.key);\n      if (shape) {\n        this.selectShapeTool(shape);\n      } else if (event.key === KEYS.Q) {\n        this.toggleLock();\n      }\n    }\n    if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n      isHoldingSpace = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    }\n  });\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    if (!isLinearElementType(elementType)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      selectedElementIds: {},\n    });\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location on the touchMove handler already.\n    // On Macbook, we don't have those events so will zoom in at the\n    // current location instead.\n    if (gesture.pointers.size === 2) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * event.scale),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          { x: cursorX, y: cursorY },\n        ),\n      }));\n    }\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      previousSelectedElementIds: {},\n      selectedElementIds: this.state.previousSelectedElementIds,\n    });\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (text: string, isDeleted = false) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [viewportX, viewportY];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates((text) => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n        if (!isDeleted) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n        } else {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n      }),\n      element,\n    });\n    // deselect all other elements when inserting text\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(x, y);\n    if (allHitElements.length > 1) {\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement>[] {\n    return getElementsAtPosition(this.scene.getElements(), (element) =>\n      hitTest(element, this.state, x, y),\n    );\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n  }) => {\n    const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n\n    const parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n          x: parentCenterPosition\n            ? parentCenterPosition.elementCenterX\n            : sceneX,\n          y: parentCenterPosition\n            ? parentCenterPosition.elementCenterY\n            : sceneY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          strokeSharpness: this.state.currentItemStrokeSharpness,\n          text: \"\",\n          fontSize: this.state.currentItemFontSize,\n          fontFamily: this.state.currentItemFontFamily,\n          textAlign: parentCenterPosition\n            ? \"center\"\n            : this.state.currentItemTextAlign,\n          verticalAlign: parentCenterPosition\n            ? \"middle\"\n            : DEFAULT_VERTICAL_ALIGN,\n        });\n\n    this.setState({ editingElement: element });\n\n    if (existingTextElement) {\n      // if text element is no longer centered to a container, reset\n      // verticalAlign to default because it's currently internal-only\n      if (!parentCenterPosition || element.textAlign !== \"center\") {\n        mutateElement(element, { verticalAlign: DEFAULT_VERTICAL_ALIGN });\n      }\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      // case: creating new text not centered to parent elemenent → offset Y\n      // so that the text is centered to cursor position\n      if (!parentCenterPosition) {\n        mutateElement(element, {\n          y: element.y - element.baseline / 2,\n        });\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        !this.state.editingLinearElement ||\n        this.state.editingLinearElement.elementId !== selectedElements[0].id\n      ) {\n        history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n      }\n      return;\n    }\n\n    resetCursor();\n\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getElements(),\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor();\n\n    if (!event[KEYS.CTRL_OR_CMD]) {\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n      });\n    }\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      this.setState(({ zoom, scrollX, scrollY, offsetLeft, offsetTop }) => ({\n        scrollX: normalizeScroll(scrollX + deltaX / zoom.value),\n        scrollY: normalizeScroll(scrollY + deltaY / zoom.value),\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * scaleFactor),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          center,\n        ),\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX,\n      event.clientY,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state.editingLinearElement,\n        this.state.gridSize,\n      );\n      if (editingLinearElement !== this.state.editingLinearElement) {\n        this.setState({ editingLinearElement });\n      }\n      if (editingLinearElement.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        this.setState({ suggestedBindings: [] });\n      }\n    }\n\n    if (isBindingElementType(this.state.elementType)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement)) {\n        this.maybeSuggestBindingForLinearElementAtCursor(\n          draggingElement,\n          \"end\",\n          scenePointer,\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        if (isPathALoop(points)) {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [scenePointerX - rx, scenePointerY - ry],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          elementWithTransformHandleType,\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType,\n        });\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (this.state.elementType === \"text\") {\n      document.documentElement.style.cursor = isTextElement(hitElement)\n        ? CURSOR_TYPE.TEXT\n        : CURSOR_TYPE.CROSSHAIR;\n    } else if (isOverScrollBar) {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    } else if (\n      hitElement ||\n      this.isHittingCommonBoundingBoxOfSelectedElements(\n        scenePointer,\n        selectedElements,\n      )\n    ) {\n      document.documentElement.style.cursor = CURSOR_TYPE.MOVE;\n    } else {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    }\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.persist();\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // fixes pointermove causing selection of UI texts #32\n    event.preventDefault();\n    // Preventing the event above disables default behavior\n    // of defocusing potentially focused element, which is what we\n    // want when clicking inside the canvas.\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur();\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    if (this.state.elementType === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"draw\" ||\n      this.state.elementType === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else {\n      this.createGenericElementOnPointerDown(\n        this.state.elementType,\n        pointerDownState,\n      );\n    }\n\n    const onPointerMove = this.onPointerMoveFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onPointerUp = this.onPointerUpFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n    window.addEventListener(EVENT.KEYUP, onKeyUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n    pointerDownState.eventListeners.onKeyUp = onKeyUp;\n    pointerDownState.eventListeners.onKeyDown = onKeyDown;\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.openContextMenu({\n              clientX: event.clientX,\n              clientY: event.clientY,\n            });\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size === 0 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace))\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - rigth click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.setState({\n        scrollX: normalizeScroll(\n          this.state.scrollX - deltaX / this.state.zoom.value,\n        ),\n        scrollY: normalizeScroll(\n          this.state.scrollY - deltaY / this.state.zoom.value,\n        ),\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          setCursorForShape(this.state.elementType);\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX,\n        event.clientY,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(\n          origin,\n          selectedElements,\n        ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.elementType !== \"selection\") {\n      this.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.elementType === \"selection\") {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(\n          elements,\n          this.state,\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType: pointerDownState.resize.handleType,\n        });\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.editingLinearElement) {\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            (appState) => this.setState(appState),\n            history,\n            pointerDownState.origin,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(\n          (element) => this.isASelectedElement(element),\n        );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        // If we click on something\n        if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: {},\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement.id]: true,\n                    },\n                  },\n                  this.scene.getElements(),\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.elementLocked)\n    if (this.state.editingElement?.type === \"text\") {\n      return;\n    }\n\n    this.startTextEditing({\n      sceneX: pointerDownState.origin.x,\n      sceneY: pointerDownState.origin.y,\n      insertAtParentCenter: !event.altKey,\n    });\n\n    resetCursor();\n    if (!this.state.elementLocked) {\n      this.setState({\n        elementType: \"selection\",\n      });\n    }\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone → finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [multiElement.id]: true,\n        },\n      }));\n      // clicking outside commit zone → update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        elementType === \"draw\" ? null : this.state.gridSize,\n      );\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n        startArrowhead,\n        endArrowhead,\n      });\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [element.id]: false,\n        },\n      }));\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            getSelectedElements(this.scene.getElements(), this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(\n          this.state,\n          (appState) => this.setState(appState),\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, startOrEnd) => {\n            this.maybeSuggestBindingForLinearElementAtCursor(\n              element,\n              startOrEnd,\n              pointerCoords,\n            );\n          },\n        );\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n      if (\n        hasHitASelectedElement ||\n        pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n      ) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        if (selectedElements.length > 0) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          dragSelectedElements(\n            pointerDownState,\n            selectedElements,\n            dragX,\n            dragY,\n            this.scene,\n            lockDirection,\n            dragDistanceX,\n            dragDistanceY,\n          );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx: number;\n        let dy: number;\n        if (draggingElement.type === \"draw\") {\n          dx = pointerCoords.x - draggingElement.x;\n          dy = pointerCoords.y - draggingElement.y;\n        } else {\n          dx = gridX - draggingElement.x;\n          dy = gridY - draggingElement.y;\n        }\n\n        if (getRotateWithDiscreteAngleKey(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          if (draggingElement.type === \"draw\") {\n            mutateElement(draggingElement, {\n              points: simplify(\n                [...(points as Point[]), [dx, dy]],\n                0.7 / this.state.zoom.value,\n              ),\n            });\n          } else {\n            mutateElement(draggingElement, {\n              points: [...points.slice(0, -1), [dx, dy]],\n            });\n          }\n        }\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(\n            draggingElement,\n            \"end\",\n            pointerCoords,\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({\n            selectedElementIds: {},\n            selectedGroupIds: {},\n            editingGroupId: null,\n          });\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                ...elementsWithinSelection.reduce((map, element) => {\n                  map[element.id] = true;\n                  return map;\n                }, {} as any),\n              },\n            },\n            this.scene.getElements(),\n          ),\n        );\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: normalizeScroll(\n          this.state.scrollX - dx / this.state.zoom.value,\n        ),\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: normalizeScroll(\n          this.state.scrollY - dy / this.state.zoom.value,\n        ),\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(\n          childEvent,\n          this.state.editingLinearElement,\n          this.state,\n        );\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: [],\n          });\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (draggingElement?.type === \"draw\") {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!elementLocked && elementType !== \"draw\") {\n            resetCursor();\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection\n      ) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds\n                .flatMap((groupId) =>\n                  getElementsInGroup(this.scene.getElements(), groupId),\n                )\n                .map((element) => ({ [element.id]: false }))\n                .reduce((prevId, acc) => ({ ...prevId, ...acc }), {});\n\n              this.setState((_prevState) => ({\n                selectedGroupIds: {\n                  ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds\n                    .map((gId) => ({ [gId]: false }))\n                    .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                },\n                selectedElementIds: {\n                  ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups,\n                },\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState((prevState) => ({\n                selectedElementIds: {\n                  ...prevState.selectedElementIds,\n                  [hitElement!.id]: false,\n                },\n              }));\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: {\n                ..._prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getElements(),\n            ),\n          }));\n        }\n      }\n\n      if (\n        !this.state.editingLinearElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"draw\" && draggingElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(this.scene.getElements(), this.state)\n      ) {\n        history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(\n          getSelectedElements(this.scene.getElements(), this.state),\n        );\n      }\n\n      if (!elementLocked && elementType !== \"draw\") {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingForLinearElementAtCursor = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    startOrEnd: \"start\" | \"end\",\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null &&\n        !isLinearElementSimpleAndAlreadyBound(\n          linearElement,\n          oppositeBindingBoundElement?.id,\n          hoveredBindableElement,\n        )\n          ? [hoveredBindableElement]\n          : [],\n    });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleCanvasOnDrop = async (\n    event: React.DragEvent<HTMLCanvasElement>,\n  ) => {\n    try {\n      const file = event.dataTransfer.files[0];\n      if (file?.type === \"image/png\" || file?.type === \"image/svg+xml\") {\n        const { elements, appState } = await loadFromBlob(file, this.state);\n        this.syncActionResult({\n          elements,\n          appState: {\n            ...(appState || this.state),\n            isLoading: false,\n          },\n          commitToHistory: true,\n        });\n        return;\n      }\n    } catch (error) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryShapes !== \"\") {\n      this.addElementsFromPasteOrLibrary(\n        JSON.parse(libraryShapes),\n        event.clientX,\n        event.clientY,\n      );\n      return;\n    }\n\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === \"application/json\" ||\n      file?.name.endsWith(\".excalidraw\")\n    ) {\n      this.setState({ isLoading: true });\n      if (\n        \"chooseFileSystemEntries\" in window ||\n        \"showOpenFilePicker\" in window\n      ) {\n        try {\n          // This will only work as of Chrome 86,\n          // but can be safely ignored on older releases.\n          const item = event.dataTransfer.items[0];\n          // TODO: Make this part of `AppState`.\n          (file as any).handle = await (item as any).getAsFileSystemHandle();\n        } catch (error) {\n          console.warn(error.name, error.message);\n        }\n      }\n      loadFromBlob(file, this.state)\n        .then(({ elements, appState }) =>\n          this.syncActionResult({\n            elements,\n            appState: {\n              ...(appState || this.state),\n              isLoading: false,\n            },\n            commitToHistory: true,\n          }),\n        )\n        .catch((error) => {\n          this.setState({ isLoading: false, errorMessage: error.message });\n        });\n    } else if (\n      file?.type === MIME_TYPES.excalidrawlib ||\n      file?.name.endsWith(\".excalidrawlib\")\n    ) {\n      Library.importLibrary(file)\n        .then(() => {\n          this.setState({ isLibraryOpen: false });\n        })\n        .catch((error) =>\n          this.setState({ isLoading: false, errorMessage: error.message }),\n        );\n    } else {\n      this.setState({\n        isLoading: false,\n        errorMessage: t(\"alerts.couldNotLoadInvalidFile\"),\n      });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n    this.openContextMenu(event);\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (draggingElement.type === \"selection\") {\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n      this.maybeSuggestBindingForAll([draggingElement]);\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const transformHandleType = pointerDownState.resize.handleType;\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        getRotateWithDiscreteAngleKey(event),\n        getResizeCenterPointKey(event),\n        getResizeWithSidesSameLengthKey(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n      return true;\n    }\n    return false;\n  };\n\n  private openContextMenu = ({\n    clientX,\n    clientY,\n  }: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const elements = this.scene.getElements();\n    const element = this.getElementAtPosition(x, y);\n    if (!element) {\n      ContextMenu.push({\n        options: [\n          navigator.clipboard && {\n            shortcutName: \"paste\",\n            label: t(\"labels.paste\"),\n            action: () => this.pasteFromClipboard(null),\n          },\n          probablySupportsClipboardBlob &&\n            elements.length > 0 && {\n              shortcutName: \"copyAsPng\",\n              label: t(\"labels.copyAsPng\"),\n              action: this.copyToClipboardAsPng,\n            },\n          probablySupportsClipboardWriteText &&\n            elements.length > 0 && {\n              shortcutName: \"copyAsSvg\",\n              label: t(\"labels.copyAsSvg\"),\n              action: this.copyToClipboardAsSvg,\n            },\n          ...this.actionManager.getContextMenuItems((action) =>\n            CANVAS_ONLY_ACTIONS.includes(action.name),\n          ),\n          {\n            checked: this.state.gridSize !== null,\n            shortcutName: \"gridMode\",\n            label: t(\"labels.gridMode\"),\n            action: this.toggleGridMode,\n          },\n          {\n            checked: this.state.zenModeEnabled,\n            shortcutName: \"zenMode\",\n            label: t(\"buttons.zenMode\"),\n            action: this.toggleZenMode,\n          },\n          {\n            checked: this.state.showStats,\n            shortcutName: \"stats\",\n            label: t(\"stats.title\"),\n            action: this.toggleStats,\n          },\n        ],\n        top: clientY,\n        left: clientX,\n      });\n      return;\n    }\n\n    if (!this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } });\n    }\n\n    ContextMenu.push({\n      options: [\n        {\n          shortcutName: \"cut\",\n          label: t(\"labels.cut\"),\n          action: this.cutAll,\n        },\n        navigator.clipboard && {\n          shortcutName: \"copy\",\n          label: t(\"labels.copy\"),\n          action: this.copyAll,\n        },\n        navigator.clipboard && {\n          shortcutName: \"paste\",\n          label: t(\"labels.paste\"),\n          action: () => this.pasteFromClipboard(null),\n        },\n        probablySupportsClipboardBlob && {\n          shortcutName: \"copyAsPng\",\n          label: t(\"labels.copyAsPng\"),\n          action: this.copyToClipboardAsPng,\n        },\n        probablySupportsClipboardWriteText && {\n          shortcutName: \"copyAsSvg\",\n          label: t(\"labels.copyAsSvg\"),\n          action: this.copyToClipboardAsSvg,\n        },\n        ...this.actionManager.getContextMenuItems(\n          (action) => !CANVAS_ONLY_ACTIONS.includes(action.name),\n        ),\n      ],\n      top: clientY,\n      left: clientX,\n    });\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n\n    if (isPanning) {\n      return;\n    }\n\n    const { deltaX, deltaY } = event;\n    const { selectedElementIds, previousSelectedElementIds } = this.state;\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      if (Object.keys(previousSelectedElementIds).length !== 0) {\n        setTimeout(() => {\n          this.setState({\n            selectedElementIds: previousSelectedElementIds,\n            previousSelectedElementIds: {},\n          });\n        }, 1000);\n      }\n\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(zoom.value - delta / 100),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          {\n            x: cursorX,\n            y: cursorY,\n          },\n        ),\n        selectedElementIds: {},\n        previousSelectedElementIds:\n          Object.keys(selectedElementIds).length !== 0\n            ? selectedElementIds\n            : previousSelectedElementIds,\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n      return;\n    }\n\n    // scroll horizontally when shift pressed\n    if (event.shiftKey) {\n      this.setState(({ zoom, scrollX }) => ({\n        // on Mac, shift+wheel tends to result in deltaX\n        scrollX: normalizeScroll(scrollX - (deltaY || deltaX) / zoom.value),\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: normalizeScroll(scrollX - deltaX / zoom.value),\n      scrollY: normalizeScroll(scrollY - deltaY / zoom.value),\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      this.scene\n        .getElementsIncludingDeleted()\n        .filter((element) => !isTextElement(element)),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private getCanvasOffsets(offsets?: {\n    offsetLeft?: number;\n    offsetTop?: number;\n  }): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (\n      typeof offsets?.offsetLeft === \"number\" &&\n      typeof offsets?.offsetTop === \"number\"\n    ) {\n      return {\n        offsetLeft: offsets.offsetLeft,\n        offsetTop: offsets.offsetTop,\n      };\n    }\n    if (this.excalidrawContainerRef?.current?.parentElement) {\n      const parentElement = this.excalidrawContainerRef.current.parentElement;\n      const { left, top } = parentElement.getBoundingClientRect();\n      return {\n        offsetLeft:\n          typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : left,\n        offsetTop:\n          typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : top,\n      };\n    }\n    return {\n      offsetLeft:\n        typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : 0,\n      offsetTop: typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      history: SceneHistory;\n      app: InstanceType<typeof App>;\n      library: typeof Library;\n      collab: InstanceType<\n        typeof import(\"../excalidraw-app/collab/CollabWrapper\").default\n      >;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app.scene.replaceAllElements(elements);\n      },\n    },\n    history: {\n      configurable: true,\n      get: () => history,\n    },\n    library: {\n      configurable: true,\n      value: Library,\n    },\n  });\n}\nexport default App;\n"]},"metadata":{},"sourceType":"module"}