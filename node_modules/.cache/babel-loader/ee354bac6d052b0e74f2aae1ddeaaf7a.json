{"ast":null,"code":"import { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\nexport const isInvisiblySmallElement = element => {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n\n  return element.width === 0 && element.height === 0;\n};\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\n\nexport const getPerfectElementSize = (elementType, width, height) => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (elementType === \"line\" || elementType === \"arrow\" || elementType === \"draw\") {\n    const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;\n\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n\n  return {\n    width,\n    height\n  };\n};\nexport const resizePerfectLineForNWHandler = (element, x, y) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0\n    });\n  } else {\n    const nextHeight = Math.sign(distanceToAnchorY) * Math.sign(distanceToAnchorX) * element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight\n    });\n  }\n};\nexport const getNormalizedDimensions = element => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/element/sizeHelpers.ts"],"names":["mutateElement","isLinearElement","SHIFT_LOCKING_ANGLE","isInvisiblySmallElement","element","points","length","width","height","getPerfectElementSize","elementType","absWidth","Math","abs","absHeight","lockedAngle","round","atan","PI","tan","sign","resizePerfectLineForNWHandler","x","y","anchorX","anchorY","distanceToAnchorX","distanceToAnchorY","nextHeight","getNormalizedDimensions","ret","nextWidth"],"mappings":"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","sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"draw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n"]},"metadata":{},"sourceType":"module"}