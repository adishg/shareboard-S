{"ast":null,"code":"import { getElementsInGroup } from \"./groups\";\nimport { findIndex, findLastIndex } from \"./utils\";\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n */\n\nconst getIndicesToMove = (elements, appState) => {\n  let selectedIndices = [];\n  let deletedIndices = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n\n  while (++index < elements.length) {\n    if (appState.selectedElementIds[elements[index].id]) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (elements[index].isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n\n  return selectedIndices;\n};\n\nconst toContiguousGroups = array => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, []);\n};\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\n\n\nconst getTargetIndex = (appState, elements, boundaryIndex, direction) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = element => {\n    if (element.isDeleted) {\n      return false;\n    } // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n\n\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n\n    return true;\n  };\n\n  const candidateIndex = direction === \"left\" ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1)) : findIndex(elements, indexFilter, boundaryIndex + 1);\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if ( // candidate element is a sibling in current editing group → return\n    (sourceElement === null || sourceElement === void 0 ? void 0 : sourceElement.groupIds.join(\"\")) === (nextElement === null || nextElement === void 0 ? void 0 : nextElement.groupIds.join(\"\"))) {\n      return candidateIndex;\n    } else if (!(nextElement === null || nextElement === void 0 ? void 0 : nextElement.groupIds.includes(appState.editingGroupId))) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return candidateIndex;\n  }\n\n  const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length - 1]);\n  }\n\n  return candidateIndex;\n};\n\nconst shiftElements = (appState, elements, direction) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n    const targetIndex = getTargetIndex(appState, elements, boundaryIndex, direction);\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements = direction === \"left\" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements = direction === \"left\" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements = direction === \"left\" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);\n    elements = direction === \"left\" ? [...leadingElements, ...targetElements, ...displacedElements, ...trailingElements] : [...leadingElements, ...displacedElements, ...targetElements, ...trailingElements];\n  });\n  return elements;\n};\n\nconst shiftElementsToEnd = (elements, appState, direction) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElements = [];\n  const displacedElements = [];\n  let leadingIndex;\n  let trailingIndex;\n\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(elements, appState.editingGroupId);\n\n      if (!groupElements.length) {\n        return elements;\n      }\n\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(elements, appState.editingGroupId);\n\n      if (!groupElements.length) {\n        return elements;\n      }\n\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (indicesToMove.includes(index)) {\n      targetElements.push(elements[index]);\n    } else {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n  return direction === \"left\" ? [...leadingElements, ...targetElements, ...displacedElements, ...trailingElements] : [...leadingElements, ...displacedElements, ...targetElements, ...trailingElements];\n}; // public API\n// -----------------------------------------------------------------------------\n\n\nexport const moveOneLeft = (elements, appState) => {\n  return shiftElements(appState, elements.slice(), \"left\");\n};\nexport const moveOneRight = (elements, appState) => {\n  return shiftElements(appState, elements.slice(), \"right\");\n};\nexport const moveAllLeft = (elements, appState) => {\n  return shiftElementsToEnd(elements, appState, \"left\");\n};\nexport const moveAllRight = (elements, appState) => {\n  return shiftElementsToEnd(elements, appState, \"right\");\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/zindex.ts"],"names":["getElementsInGroup","findIndex","findLastIndex","getIndicesToMove","elements","appState","selectedIndices","deletedIndices","includeDeletedIndex","index","length","selectedElementIds","id","concat","push","isDeleted","toContiguousGroups","array","cursor","reduce","acc","value","getTargetIndex","boundaryIndex","direction","sourceElement","indexFilter","element","editingGroupId","groupIds","includes","candidateIndex","Math","max","nextElement","join","siblingGroupId","indexOf","elementsInSiblingGroup","shiftElements","indicesToMove","groupedIndices","reverse","forEach","indices","i","leadingIndex","trailingIndex","targetIndex","leadingElements","slice","targetElements","displacedElements","trailingElements","shiftElementsToEnd","groupElements","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight"],"mappings":"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","sourcesContent":["import { ExcalidrawElement } from \"./element/types\";\nimport { getElementsInGroup } from \"./groups\";\nimport { AppState } from \"./types\";\nimport { findIndex, findLastIndex } from \"./utils\";\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  while (++index < elements.length) {\n    if (appState.selectedElementIds[elements[index].id]) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (elements[index].isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group → return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return candidateIndex;\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return candidateIndex;\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements;\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElements: ExcalidrawElement[] = [];\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (indicesToMove.includes(index)) {\n      targetElements.push(elements[index]);\n    } else {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements.slice(), \"left\");\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements.slice(), \"right\");\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\");\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\");\n};\n"]},"metadata":{},"sourceType":"module"}