{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { getGlobalObject, logger, uuid4 } from '@sentry/utils'; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nvar localForage = require('localforage');\n/**\n * cache offline errors and send when connected\n */\n\n\nvar Offline =\n/** @class */\nfunction () {\n  /**\n   * @inheritDoc\n   */\n  function Offline(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    this.name = Offline.id; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    this.global = getGlobalObject();\n    this.maxStoredEvents = options.maxStoredEvents || 30; // set a reasonable default\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    this.offlineEventStore = localForage.createInstance({\n      name: 'sentry/offlineEventStore'\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Offline.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    var _this = this;\n\n    this.hub = getCurrentHub();\n\n    if ('addEventListener' in this.global) {\n      this.global.addEventListener('online', function () {\n        _this._sendEvents().catch(function () {\n          logger.warn('could not send cached events');\n        });\n      });\n    }\n\n    addGlobalEventProcessor(function (event) {\n      if (_this.hub && _this.hub.getIntegration(Offline)) {\n        // cache if we are positively offline\n        if ('navigator' in _this.global && 'onLine' in _this.global.navigator && !_this.global.navigator.onLine) {\n          _this._cacheEvent(event).then(function (_event) {\n            return _this._enforceMaxEvents();\n          }).catch(function (_error) {\n            logger.warn('could not cache event while offline');\n          }); // return null on success or failure, because being offline will still result in an error\n\n\n          return null;\n        }\n      }\n\n      return event;\n    }); // if online now, send any events stored in a previous offline session\n\n    if ('navigator' in this.global && 'onLine' in this.global.navigator && this.global.navigator.onLine) {\n      this._sendEvents().catch(function () {\n        logger.warn('could not send cached events');\n      });\n    }\n  };\n  /**\n   * cache an event to send later\n   * @param event an event\n   */\n\n\n  Offline.prototype._cacheEvent = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.offlineEventStore.setItem(uuid4(), event)];\n      });\n    });\n  };\n  /**\n   * purge excess events if necessary\n   */\n\n\n  Offline.prototype._enforceMaxEvents = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var events;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        events = [];\n        return [2\n        /*return*/\n        , this.offlineEventStore.iterate(function (event, cacheKey, _index) {\n          // aggregate events\n          events.push({\n            cacheKey: cacheKey,\n            event: event\n          });\n        }).then(function () {\n          // this promise resolves when the iteration is finished\n          return _this._purgeEvents( // purge all events past maxStoredEvents in reverse chronological order\n          events.sort(function (a, b) {\n            return (b.event.timestamp || 0) - (a.event.timestamp || 0);\n          }).slice(_this.maxStoredEvents < events.length ? _this.maxStoredEvents : events.length).map(function (event) {\n            return event.cacheKey;\n          }));\n        }).catch(function (_error) {\n          logger.warn('could not enforce max events');\n        })];\n      });\n    });\n  };\n  /**\n   * purge event from cache\n   */\n\n\n  Offline.prototype._purgeEvent = function (cacheKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.offlineEventStore.removeItem(cacheKey)];\n      });\n    });\n  };\n  /**\n   * purge events from cache\n   */\n\n\n  Offline.prototype._purgeEvents = function (cacheKeys) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        // trail with .then to ensure the return type as void and not void|void[]\n        return [2\n        /*return*/\n        , Promise.all(cacheKeys.map(function (cacheKey) {\n          return _this._purgeEvent(cacheKey);\n        })).then()];\n      });\n    });\n  };\n  /**\n   * send all events\n   */\n\n\n  Offline.prototype._sendEvents = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.offlineEventStore.iterate(function (event, cacheKey, _index) {\n          if (_this.hub) {\n            _this.hub.captureEvent(event);\n\n            _this._purgeEvent(cacheKey).catch(function (_error) {\n              logger.warn('could not purge event from cache');\n            });\n          } else {\n            logger.warn('no hub found - could not send cached event');\n          }\n        })];\n      });\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Offline.id = 'Offline';\n  return Offline;\n}();\n\nexport { Offline };","map":{"version":3,"sources":["../src/offline.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { Event, EventProcessor, Hub, Integration } from '@sentry/types';\nimport { getGlobalObject, logger, uuid4 } from '@sentry/utils';\nimport * as localForageType from 'localforage';\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst localForage = require('localforage');\n/**\n * cache offline errors and send when connected\n */\nexport class Offline implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Offline';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = Offline.id;\n\n  /**\n   * the global instance\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public global: any;\n\n  /**\n   * the current hub instance\n   */\n  public hub?: Hub;\n\n  /**\n   * maximum number of events to store while offline\n   */\n  public maxStoredEvents: number;\n\n  /**\n   * event cache\n   */\n  public offlineEventStore: typeof localForageType; // type imported from localforage\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { maxStoredEvents?: number } = {}) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.global = getGlobalObject<any>();\n    this.maxStoredEvents = options.maxStoredEvents || 30; // set a reasonable default\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    this.offlineEventStore = localForage.createInstance({\n      name: 'sentry/offlineEventStore',\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this.hub = getCurrentHub();\n\n    if ('addEventListener' in this.global) {\n      this.global.addEventListener('online', () => {\n        this._sendEvents().catch(() => {\n          logger.warn('could not send cached events');\n        });\n      });\n    }\n\n    addGlobalEventProcessor((event: Event) => {\n      if (this.hub && this.hub.getIntegration(Offline)) {\n        // cache if we are positively offline\n        if ('navigator' in this.global && 'onLine' in this.global.navigator && !this.global.navigator.onLine) {\n          this._cacheEvent(event)\n            .then((_event: Event): Promise<void> => this._enforceMaxEvents())\n            .catch((_error): void => {\n              logger.warn('could not cache event while offline');\n            });\n\n          // return null on success or failure, because being offline will still result in an error\n          return null;\n        }\n      }\n\n      return event;\n    });\n\n    // if online now, send any events stored in a previous offline session\n    if ('navigator' in this.global && 'onLine' in this.global.navigator && this.global.navigator.onLine) {\n      this._sendEvents().catch(() => {\n        logger.warn('could not send cached events');\n      });\n    }\n  }\n\n  /**\n   * cache an event to send later\n   * @param event an event\n   */\n  private async _cacheEvent(event: Event): Promise<Event> {\n    return this.offlineEventStore.setItem<Event>(uuid4(), event);\n  }\n\n  /**\n   * purge excess events if necessary\n   */\n  private async _enforceMaxEvents(): Promise<void> {\n    const events: Array<{ event: Event; cacheKey: string }> = [];\n\n    return this.offlineEventStore\n      .iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n        // aggregate events\n        events.push({ cacheKey, event });\n      })\n      .then(\n        (): Promise<void> =>\n          // this promise resolves when the iteration is finished\n          this._purgeEvents(\n            // purge all events past maxStoredEvents in reverse chronological order\n            events\n              .sort((a, b) => (b.event.timestamp || 0) - (a.event.timestamp || 0))\n              .slice(this.maxStoredEvents < events.length ? this.maxStoredEvents : events.length)\n              .map(event => event.cacheKey),\n          ),\n      )\n      .catch((_error): void => {\n        logger.warn('could not enforce max events');\n      });\n  }\n\n  /**\n   * purge event from cache\n   */\n  private async _purgeEvent(cacheKey: string): Promise<void> {\n    return this.offlineEventStore.removeItem(cacheKey);\n  }\n\n  /**\n   * purge events from cache\n   */\n  private async _purgeEvents(cacheKeys: string[]): Promise<void> {\n    // trail with .then to ensure the return type as void and not void|void[]\n    return Promise.all(cacheKeys.map(cacheKey => this._purgeEvent(cacheKey))).then();\n  }\n\n  /**\n   * send all events\n   */\n  private async _sendEvents(): Promise<void> {\n    return this.offlineEventStore.iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n      if (this.hub) {\n        this.hub.captureEvent(event);\n\n        this._purgeEvent(cacheKey).catch((_error): void => {\n          logger.warn('could not purge event from cache');\n        });\n      } else {\n        logger.warn('no hub found - could not send cached event');\n      }\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}