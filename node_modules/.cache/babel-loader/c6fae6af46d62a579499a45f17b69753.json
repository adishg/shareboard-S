{"ast":null,"code":"import { getElementAbsoluteCoords } from \"../element\";\nexport const hasBackground = type => type === \"rectangle\" || type === \"ellipse\" || type === \"diamond\" || type === \"draw\" || type === \"line\";\nexport const hasStroke = type => type === \"rectangle\" || type === \"ellipse\" || type === \"diamond\" || type === \"arrow\" || type === \"draw\" || type === \"line\";\nexport const canChangeSharpness = type => type === \"rectangle\" || type === \"arrow\" || type === \"draw\" || type === \"line\";\nexport const hasText = type => type === \"text\";\nexport const canHaveArrowheads = type => type === \"arrow\";\nexport const getElementAtPosition = (elements, isAtPositionFn) => {\n  let hitElement = null; // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n\n    if (element.isDeleted) {\n      continue;\n    }\n\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\nexport const getElementsAtPosition = (elements, isAtPositionFn) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(element => !element.isDeleted && isAtPositionFn(element));\n};\nexport const getElementContainingPosition = (elements, x, y) => {\n  let hitElement = null; // We need to to hit testing from front (end of the array) to back (beginning of the array)\n\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n\n  return hitElement;\n};","map":{"version":3,"sources":["/var/www/html/excalidraw/src/scene/comparisons.ts"],"names":["getElementAbsoluteCoords","hasBackground","type","hasStroke","canChangeSharpness","hasText","canHaveArrowheads","getElementAtPosition","elements","isAtPositionFn","hitElement","index","length","element","isDeleted","getElementsAtPosition","filter","getElementContainingPosition","x","y","x1","y1","x2","y2"],"mappings":"AAKA,SAASA,wBAAT,QAAyC,YAAzC;AAEA,OAAO,MAAMC,aAAa,GAAIC,IAAD,IAC3BA,IAAI,KAAK,WAAT,IACAA,IAAI,KAAK,SADT,IAEAA,IAAI,KAAK,SAFT,IAGAA,IAAI,KAAK,MAHT,IAIAA,IAAI,KAAK,MALJ;AAOP,OAAO,MAAMC,SAAS,GAAID,IAAD,IACvBA,IAAI,KAAK,WAAT,IACAA,IAAI,KAAK,SADT,IAEAA,IAAI,KAAK,SAFT,IAGAA,IAAI,KAAK,OAHT,IAIAA,IAAI,KAAK,MAJT,IAKAA,IAAI,KAAK,MANJ;AAQP,OAAO,MAAME,kBAAkB,GAAIF,IAAD,IAChCA,IAAI,KAAK,WAAT,IACAA,IAAI,KAAK,OADT,IAEAA,IAAI,KAAK,MAFT,IAGAA,IAAI,KAAK,MAJJ;AAMP,OAAO,MAAMG,OAAO,GAAIH,IAAD,IAAkBA,IAAI,KAAK,MAA3C;AAEP,OAAO,MAAMI,iBAAiB,GAAIJ,IAAD,IAAkBA,IAAI,KAAK,OAArD;AAEP,OAAO,MAAMK,oBAAoB,GAAG,CAClCC,QADkC,EAElCC,cAFkC,KAG/B;AACH,MAAIC,UAAU,GAAG,IAAjB,CADG,CAEH;AACA;AACA;;AACA,OAAK,IAAIC,KAAK,GAAGH,QAAQ,CAACI,MAAT,GAAkB,CAAnC,EAAsCD,KAAK,IAAI,CAA/C,EAAkD,EAAEA,KAApD,EAA2D;AACzD,UAAME,OAAO,GAAGL,QAAQ,CAACG,KAAD,CAAxB;;AACA,QAAIE,OAAO,CAACC,SAAZ,EAAuB;AACrB;AACD;;AACD,QAAIL,cAAc,CAACI,OAAD,CAAlB,EAA6B;AAC3BH,MAAAA,UAAU,GAAGG,OAAb;AACA;AACD;AACF;;AAED,SAAOH,UAAP;AACD,CApBM;AAsBP,OAAO,MAAMK,qBAAqB,GAAG,CACnCP,QADmC,EAEnCC,cAFmC,KAGhC;AACH;AACA;AACA,SAAOD,QAAQ,CAACQ,MAAT,CACJH,OAAD,IAAa,CAACA,OAAO,CAACC,SAAT,IAAsBL,cAAc,CAACI,OAAD,CAD5C,CAAP;AAGD,CATM;AAWP,OAAO,MAAMI,4BAA4B,GAAG,CAC1CT,QAD0C,EAE1CU,CAF0C,EAG1CC,CAH0C,KAIvC;AACH,MAAIT,UAAU,GAAG,IAAjB,CADG,CAEH;;AACA,OAAK,IAAIC,KAAK,GAAGH,QAAQ,CAACI,MAAT,GAAkB,CAAnC,EAAsCD,KAAK,IAAI,CAA/C,EAAkD,EAAEA,KAApD,EAA2D;AACzD,QAAIH,QAAQ,CAACG,KAAD,CAAR,CAAgBG,SAApB,EAA+B;AAC7B;AACD;;AACD,UAAM,CAACM,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,IAAmBvB,wBAAwB,CAACQ,QAAQ,CAACG,KAAD,CAAT,CAAjD;;AACA,QAAIS,EAAE,GAAGF,CAAL,IAAUA,CAAC,GAAGI,EAAd,IAAoBD,EAAE,GAAGF,CAAzB,IAA8BA,CAAC,GAAGI,EAAtC,EAA0C;AACxCb,MAAAA,UAAU,GAAGF,QAAQ,CAACG,KAAD,CAArB;AACA;AACD;AACF;;AACD,SAAOD,UAAP;AACD,CAlBM","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const hasStroke = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const canChangeSharpness = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"arrow\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n\nexport const getElementContainingPosition = (\n  elements: readonly ExcalidrawElement[],\n  x: number,\n  y: number,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return hitElement;\n};\n"]},"metadata":{},"sourceType":"module"}